{"version":3,"sources":["webpack://vscroll-native/./node_modules/tslib/tslib.es6.js","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/props.ts","webpack://vscroll-native/./node_modules/vscroll/src/version.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/reactive.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/validation.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/context.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/enums.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/interfaces/direction.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/base.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/init.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reset.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reload.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/item.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/append.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/check.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/remove.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/insert.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/replace.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/fix.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/start.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/postFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adjust.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preClip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/end.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/logger.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/domRoutines.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/paddings.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/viewport.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/cache.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/cycle.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/scroller.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow-transducer.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","pop","push","__values","o","m","__read","r","ar","error","__spread","concat","AdapterPropName","AdapterPropType","ValidatorType","Name","Type","noop","emptyPackageInfo","bufferInfoDefault","EMPTY_ITEM","getDefaultAdapterProps","instanceCount","mock","id","makeDatasource","getConfig","Datasource","DatasourceProps","getError","msg","arg","getNumber","onNumber","onMoreOrEqual","limit","fallback","onFunction","onOneOf","tokens","must","context","VALIDATORS","argsCount","validators","runValidator","current","validator","getDefault","prop","validateOne","name","validate","params","OBJECT","FUNC_WITH_X_AND_MORE_ARGUMENTS","Settings","DevSettings","DATASOURCE","get","settings","devSettings","NUMBER","INTEGER","INTEGER_UNLIMITED","MORE_OR_EQUAL","BOOLEAN","ELEMENT","FUNC","OR","CommonProcess","AdapterProcess","ProcessStatus","MIN","itemSize","bufferSize","padding","throttle","initDelay","initWindowDelay","SETTINGS","adapter","startIndex","minIndex","maxIndex","infinite","horizontal","windowViewport","viewportElement","inverse","onBeforeClip","DEV_SETTINGS","debug","immediateLog","logProcessRun","logTime","cacheData","changeOverflow","dismissOverflowAnchor","AdapterNoParams","ITEM_LIST","FUNC_WITH_X_ARGUMENTS","ONE_OF_MUST","ONE_OF_CAN","AdapterReloadParams","RESET_METHOD_PARAMS","AdapterAppendParams","RELOAD_METHOD_PARAMS","reloadIndex","AdapterRemoveParams","APPEND_METHOD_PARAMS","items","bof","eof","AdapterClipParams","REMOVE_METHOD_PARAMS","predicate","indexes","increase","AdapterInsertParams","CLIP_METHOD_PARAMS","backwardOnly","forwardOnly","AdapterReplaceParams","INSERT_METHOD_PARAMS","before","after","decrease","AdapterFixParams","REPLACE_METHOD_PARAMS","fixRight","Direction","FIX_METHOD_PARAMS","scrollPosition","updater","scrollToItem","scrollToItemOpt","AdapterMethods","ADAPTER_METHODS","BaseProcessFactory","process","BaseAdapterProcessFactory","initProcesses","init","reset","reload","cycle","workflow","scrollState","log","position","time","state","scroll","datasource","viewport","$index","data","buffer","append","item","check","sequenceOnly","clip","remove","insert","replace","FixParams","fix","start","positions","last","fetch","pack","preFetch","postFetch","render","size","adjust","preClip","toRemove","isInterrupted","end","logs","logAdapterMethod","element","style","diff","min","max","virtual","backward","forward","ADAPTER_PROPS_STUB","_has","obj","convertAppendArgs","prepend","options","adapterMethodPreResult","source","box","demand","wanted","reactive","core","scrollEventReceiver","status","input","payload","methods","scroller"],"mappings":"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","file":"vendors.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Reactive } from '../reactive';\nimport { IAdapterProp, IBufferInfo, ItemAdapter, IPackages } from '../../interfaces/index';\n\nexport enum AdapterPropName {\n  id = 'id',\n  mock = 'mock',\n  version = 'version',\n  init = 'init',\n  init$ = 'init$',\n  packageInfo = 'packageInfo',\n  itemsCount = 'itemsCount',\n  bufferInfo = 'bufferInfo',\n  isLoading = 'isLoading',\n  isLoading$ = 'isLoading$',\n  loopPending = 'loopPending',\n  loopPending$ = 'loopPending$',\n  firstVisible = 'firstVisible',\n  firstVisible$ = 'firstVisible$',\n  lastVisible = 'lastVisible',\n  lastVisible$ = 'lastVisible$',\n  bof = 'bof',\n  bof$ = 'bof$',\n  eof = 'eof',\n  eof$ = 'eof$',\n  reset = 'reset',\n  reload = 'reload',\n  append = 'append',\n  prepend = 'prepend',\n  check = 'check',\n  remove = 'remove',\n  clip = 'clip',\n  insert = 'insert',\n  replace = 'replace',\n  fix = 'fix',\n  relax = 'relax',\n  showLog = 'showLog',\n}\n\nexport enum AdapterPropType {\n  Scalar,\n  Reactive,\n  WorkflowRunner,\n  Function,\n}\n\nconst Name = AdapterPropName;\nconst Type = AdapterPropType;\n\nconst noop = () => null;\n\nconst emptyPackageInfo: IPackages = {\n  core: {\n    name: '',\n    version: ''\n  },\n  consumer: {\n    name: '',\n    version: ''\n  }\n};\n\nconst bufferInfoDefault: IBufferInfo = {\n  firstIndex: NaN,\n  lastIndex: NaN,\n  minIndex: NaN,\n  maxIndex: NaN,\n  absMinIndex: -Infinity,\n  absMaxIndex: +Infinity,\n};\n\nexport const EMPTY_ITEM = {\n  data: {},\n  element: {}\n} as ItemAdapter;\n\nexport const getDefaultAdapterProps = (): IAdapterProp[] => [\n  {\n    type: Type.Scalar,\n    name: Name.id,\n    value: 0,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.mock,\n    value: true,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.version,\n    value: '',\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.init,\n    value: false,\n    reactive: Name.init$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.packageInfo,\n    value: emptyPackageInfo,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.itemsCount,\n    value: 0,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bufferInfo,\n    value: bufferInfoDefault,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.isLoading,\n    value: false,\n    reactive: Name.isLoading$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.loopPending,\n    value: false,\n    reactive: Name.loopPending$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.firstVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.firstVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.lastVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.lastVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bof,\n    value: false,\n    reactive: Name.bof$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.eof,\n    value: false,\n    reactive: Name.eof$\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reset,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reload,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.append,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.prepend,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.check,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.remove,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.clip,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.insert,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.replace,\n    value: noop\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.fix,\n    value: noop\n  },\n  {\n    type: Type.Function,\n    name: Name.relax,\n    value: noop\n  },\n  {\n    type: Type.Function,\n    name: Name.showLog,\n    value: noop\n  },\n  {\n    type: Type.Reactive,\n    name: Name.init$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.isLoading$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.loopPending$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.firstVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.lastVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.bof$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.eof$,\n    value: new Reactive<boolean>()\n  }\n];\n","export default {\n  name: 'vscroll',\n  version: '1.0.0-rc.2'\n};\n","type On<T> = (value: T) => void;\ntype Off = () => void;\n\ninterface Subscription<T> {\n  emit: On<T>;\n  off: Off;\n}\n\ninterface Options {\n  emitOnSubscribe?: boolean; // if set, emit right on subscribe (like rxjs BehaviorSubject)\n  emitEqual?: boolean; // if set, emit when new value is equal to the old one\n}\n\nexport class Reactive<T> {\n\n  private value: T;\n  private id: number;\n  private options: Options;\n  private subscriptions: Map<number, Subscription<T>>;\n\n  constructor(value?: T, options?: Options) {\n    this.id = 0;\n    if (value !== void 0) {\n      this.value = value;\n    }\n    this.options = options || {};\n    this.subscriptions = new Map();\n  }\n\n  set(value: T): void {\n    if (this.value === value && !this.options.emitEqual) {\n      return;\n    }\n    this.value = value;\n    for (const [, sub] of this.subscriptions) {\n      sub.emit(value);\n      if (this.value !== value) {\n        break;\n      }\n    }\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  on(func: On<T>): Off {\n    const id = this.id++;\n    const subscription: Subscription<T> = {\n      emit: func,\n      off: () => {\n        subscription.emit = () => null;\n        this.subscriptions.delete(id);\n      }\n    };\n    this.subscriptions.set(id, subscription);\n    if (this.options.emitOnSubscribe) {\n      subscription.emit(this.value);\n    }\n    return () => subscription.off();\n  }\n\n  once(func: On<T>): Off {\n    const off = this.on(v => {\n      off();\n      func(v);\n    });\n    return off;\n  }\n\n  dispose(): void {\n    this.subscriptions.forEach(sub => sub.off());\n  }\n}\n","import { IValidationContext } from '../interfaces/validation';\nimport {\n  IValidator,\n  ValidatedValue,\n  IValidatedData,\n  IValidatedCommonProps,\n  ICommonProps,\n  ICommonProp,\n} from '../interfaces/index';\n\nexport enum ValidatorType {\n  number = 'must be a number',\n  integer = 'must be an integer',\n  integerUnlimited = 'must be an integer or infinity',\n  moreOrEqual = 'must be a number greater than (or equal to) {arg1}',\n  itemList = 'must be an array of items {arg1}',\n  boolean = 'must be a boolean',\n  object = 'must be an object',\n  element = 'must be an html element',\n  function = 'must be a function',\n  funcOfxArguments = 'must have {arg1} argument(s)',\n  funcOfxAndMoreArguments = 'must have at least {arg1} argument(s)',\n  oneOfCan = 'can be present as only one item of {arg1} list',\n  oneOfMust = 'must be present as only one item of {arg1} list',\n  or = 'must satisfy at least 1 validator from {arg1} list',\n}\n\nconst getError = (msg: ValidatorType, arg?: string) =>\n  msg.replace('{arg1}', arg || '');\n\n\nconst getNumber = (value: unknown): number =>\n  typeof value === 'number' || (typeof value === 'string' && value !== '')\n    ? Number(value)\n    : NaN;\n\nconst onNumber = (value: unknown): ValidatedValue => {\n  const parsedValue = getNumber(value);\n  const errors = [];\n  if (Number.isNaN(parsedValue)) {\n    errors.push(ValidatorType.number);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onInteger = (value: unknown): ValidatedValue => {\n  const errors = [];\n  value = getNumber(value);\n  const parsedValue = parseInt(String(value), 10);\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integer);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onIntegerUnlimited = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  value = getNumber(value);\n  if (!Number.isFinite(value)) {\n    parsedValue = value;\n  } else {\n    parsedValue = parseInt(String(value), 10);\n  }\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integerUnlimited);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onMoreOrEqual = (limit: number, fallback?: boolean) => (value: unknown): ValidatedValue => {\n  const result = onNumber(value);\n  if (!result.isValid) {\n    return result;\n  }\n  let parsedValue = result.value as number;\n  const errors = [];\n  if (parsedValue < limit) {\n    if (!fallback) {\n      errors.push(getError(ValidatorType.moreOrEqual, String(limit)));\n    } else {\n      parsedValue = limit;\n    }\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onBoolean = (value: unknown): ValidatedValue => {\n  const errors = [];\n  let parsedValue = value;\n  if (value === 'true') {\n    parsedValue = true;\n  } else if (value === 'false') {\n    parsedValue = false;\n  }\n  if (typeof parsedValue !== 'boolean') {\n    errors.push(ValidatorType.boolean);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onObject = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    errors.push(ValidatorType.object);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onHtmlElement = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {\n    errors.push(ValidatorType.element);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onItemList = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  if (!Array.isArray(value)) {\n    errors.push(ValidatorType.itemList);\n    parsedValue = [];\n  } else if (!value.length) {\n    errors.push(getError(ValidatorType.itemList, 'with at least 1 item'));\n  } else if (value.length > 1) {\n    const type = typeof value[0];\n    if (value.some((v: unknown) => typeof v !== type)) {\n      errors.push(getError(ValidatorType.itemList, 'of items of the same type'));\n    }\n  }\n  return { value: parsedValue as unknown[], isSet: true, isValid: !errors.length, errors };\n};\n\ntype Func = (...args: any[]) => void;\n\nconst onFunction = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (typeof value !== 'function') {\n    errors.push(ValidatorType.function);\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXArguments = (argsCount: number) => (value: unknown) => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length !== argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, String(argsCount)));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXAndMoreArguments = (argsCount: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, String(argsCount)));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onOneOf = (tokens: string[], must: boolean) => (value: unknown, context?: IValidationContext): ValidatedValue => {\n  const errors = [];\n  const isSet = value !== void 0;\n  let noOneIsPresent = !isSet;\n  const err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;\n  if (!Array.isArray(tokens) || !tokens.length) {\n    errors.push(getError(err, 'undefined'));\n  } else {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        errors.push(getError(err, tokens.join('\", \"')) + ' (non-string token)');\n        break;\n      }\n      const isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);\n      if (isSet && isAnotherPresent) {\n        errors.push(getError(err, tokens.join('\", \"')) + ` (${token} is present)`);\n        break;\n      }\n      if (noOneIsPresent && isAnotherPresent) {\n        noOneIsPresent = false;\n      }\n    }\n    if (must && noOneIsPresent) {\n      errors.push(getError(err, tokens.join('\", \"')));\n    }\n  }\n  return { value, isSet, isValid: !errors.length, errors };\n};\n\nconst onOr = (validators: IValidator[]) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (validators.every(validator => !validator.method(value).isValid)) {\n    errors.push(validators.map(v => v.type).join(' OR '));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nexport const VALIDATORS = {\n  NUMBER: {\n    type: ValidatorType.number,\n    method: onNumber\n  },\n  INTEGER: {\n    type: ValidatorType.integer,\n    method: onInteger\n  },\n  INTEGER_UNLIMITED: {\n    type: ValidatorType.integerUnlimited,\n    method: onIntegerUnlimited\n  },\n  MORE_OR_EQUAL: (limit: number, fallback?: boolean): IValidator => ({\n    type: ValidatorType.moreOrEqual,\n    method: onMoreOrEqual(limit, fallback)\n  }),\n  BOOLEAN: {\n    type: ValidatorType.boolean,\n    method: onBoolean\n  },\n  OBJECT: {\n    type: ValidatorType.object,\n    method: onObject\n  },\n  ITEM_LIST: {\n    type: ValidatorType.itemList,\n    method: onItemList\n  },\n  ELEMENT: {\n    type: ValidatorType.element,\n    method: onHtmlElement\n  },\n  FUNC: {\n    type: ValidatorType.function,\n    method: onFunction\n  },\n  FUNC_WITH_X_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxArguments,\n    method: onFunctionWithXArguments(count)\n  }),\n  FUNC_WITH_X_AND_MORE_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxAndMoreArguments,\n    method: onFunctionWithXAndMoreArguments(count)\n  }),\n  ONE_OF_CAN: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfCan,\n    method: onOneOf(list, false)\n  }),\n  ONE_OF_MUST: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfMust,\n    method: onOneOf(list, true)\n  }),\n  OR: (list: IValidator[]): IValidator => ({\n    type: ValidatorType.or,\n    method: onOr(list)\n  }),\n};\n\nexport class ValidatedData implements IValidatedData {\n\n  context: IValidationContext;\n  isValidContext: boolean;\n  isValid: boolean;\n  errors: string[];\n  params: IValidatedCommonProps<PropertyKey>;\n\n  private contextErrors: string[];\n\n  constructor(context: unknown) {\n    this.params = {};\n    this.contextErrors = [];\n    this.errors = [];\n    this.isValid = true;\n    this.setContext(context);\n  }\n\n  private setContext(context: unknown): void {\n    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {\n      this.setCommonError('context is not an object');\n      this.isValidContext = false;\n    } else {\n      this.isValidContext = true;\n    }\n    this.context = context as IValidationContext;\n  }\n\n  private setValidity() {\n    this.errors = Object.keys(this.params).reduce((acc: string[], key: string) => [\n      ...acc, ...this.params[key].errors\n    ], []);\n    this.isValid = !this.errors.length;\n  }\n\n  setCommonError(error: string): void {\n    this.contextErrors.push(error);\n    this.errors.push(error);\n    this.isValid = false;\n  }\n\n  setParam(token: string, value: ValidatedValue): void {\n    if (!value.isValid) {\n      value.errors = !value.isSet\n        ? [`\"${token}\" must be set`]\n        : value.errors.map((err: string) =>\n          `\"${token}\" ${err}`\n        );\n    }\n    this.params[token] = value;\n    this.setValidity();\n  }\n\n  showErrors(): string {\n    return this.errors.length\n      ? 'validation failed: ' + this.errors.join(', ')\n      : '';\n  }\n}\n\nexport const runValidator = (\n  current: ValidatedValue,\n  validator: IValidator,\n  context: IValidationContext\n): ValidatedValue => {\n  const { value, errors } = current;\n  const result = validator.method(value, context);\n  const _errors = [...errors, ...result.errors];\n  return {\n    value: result.value,\n    isSet: result.isSet,\n    isValid: !_errors.length,\n    errors: _errors\n  };\n};\n\nconst getDefault = (value: unknown, prop: ICommonProp): ValidatedValue => {\n  const empty = value === void 0;\n  const auto = !prop.mandatory && prop.defaultValue !== void 0;\n  return {\n    value: !empty ? value : (auto ? prop.defaultValue : void 0),\n    isSet: !empty || auto,\n    isValid: !empty || !prop.mandatory,\n    errors: []\n  };\n};\n\nexport const validateOne = (\n  context: IValidationContext, name: string, prop: ICommonProp\n): ValidatedValue => {\n  const result = getDefault(context[name], prop);\n  if (!result.isSet) {\n    const oneOfMust = prop.validators.find(v => v.type === ValidatorType.oneOfMust);\n    if (oneOfMust) {\n      return runValidator(result, oneOfMust, context);\n    }\n  } else {\n    for (const validator of Object.values(prop.validators)) {\n      const current = runValidator(result, validator, context);\n      if (!current.isValid && prop.defaultValue !== void 0) {\n        return {\n          value: prop.defaultValue,\n          isSet: true,\n          isValid: true,\n          errors: []\n        };\n      }\n      Object.assign(result, current);\n    }\n  }\n  return result;\n};\n\nexport const validate = (\n  context: unknown, params: ICommonProps<PropertyKey>\n): IValidatedData => {\n  const data = new ValidatedData(context);\n  Object.entries(params).forEach(([key, prop]) =>\n    data.setParam(key, data.isValidContext\n      ? validateOne(data.context, key, prop)\n      : getDefault(void 0, prop)\n    )\n  );\n  return data;\n};\n","import { AdapterPropName, AdapterPropType, getDefaultAdapterProps } from './props';\nimport core from '../../version';\nimport { IReactivePropsStore, IAdapterConfig } from '../../interfaces/index';\n\nlet instanceCount = 0;\n\nexport class AdapterContext {\n\n  reactiveConfiguredProps?: IReactivePropsStore;\n\n  constructor(config: IAdapterConfig) {\n    const { mock, reactive } = config;\n    const id = ++instanceCount;\n    const conf = { configurable: !mock };\n\n    // set up permanent props\n    Object.defineProperty(this, AdapterPropName.id, { get: () => id, ...conf });\n    Object.defineProperty(this, AdapterPropName.mock, { get: () => mock, ...conf });\n    Object.defineProperty(this, AdapterPropName.version, { get: () => core.version, ...conf });\n\n    // set up default props, they will be reassigned during the Adapter instantiation\n    getDefaultAdapterProps()\n      .filter(({ permanent }) => !permanent)\n      .forEach(({ name, value, type }) => {\n\n        // reactive props might be reconfigured\n        if (reactive && type === AdapterPropType.Reactive) {\n          this.reactiveConfiguredProps = this.reactiveConfiguredProps || {};\n          const react = reactive[name];\n          if (react) {\n            // here we have a configured reactive prop that came from the outer config\n            // this prop must be exposed via Adapter, but at the same time we need to\n            // persist the original default value as it will be used by the Adapter internally\n            this.reactiveConfiguredProps[name] = {\n              ...react,\n              default: value // persisting the default\n            };\n            value = react.source; // exposing the configured prop instead of the default one\n          }\n        }\n\n        Object.defineProperty(this, name, {\n          get: () => value,\n          ...conf\n        });\n      });\n  }\n}\n","import { AdapterContext } from './adapter/context';\r\nimport {\r\n  IDatasourceConstructedGeneric,\r\n  DatasourceGet,\r\n  Settings,\r\n  DevSettings,\r\n  IDatasourceGeneric,\r\n  IAdapterConfig,\r\n  IAdapter,\r\n} from '../interfaces/index';\r\n\r\nexport class DatasourceGeneric<A> implements IDatasourceConstructedGeneric<A> {\r\n  get: DatasourceGet;\r\n  settings?: Settings;\r\n  devSettings?: DevSettings;\r\n  adapter: A;\r\n\r\n  constructor(datasource: IDatasourceGeneric<A>, config?: IAdapterConfig) {\r\n    this.get = datasource.get;\r\n    if (datasource.settings) {\r\n      this.settings = datasource.settings;\r\n    }\r\n    if (datasource.devSettings) {\r\n      this.devSettings = datasource.devSettings;\r\n    }\r\n    const adapterContext = new AdapterContext(config || { mock: false });\r\n    this.adapter = adapterContext as A;\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport const makeDatasource = <A>(getConfig?: () => IAdapterConfig) =>\r\n  class <T = A> extends DatasourceGeneric<T> {\r\n    constructor(datasource: IDatasourceGeneric<T>) {\r\n      const config = typeof getConfig === 'function' ? getConfig() : void 0;\r\n      super(datasource, config);\r\n    }\r\n  };\r\n\r\nexport const Datasource = makeDatasource<IAdapter>();\r\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\n\nconst { OBJECT, FUNC_WITH_X_AND_MORE_ARGUMENTS } = VALIDATORS;\n\nexport enum DatasourceProps {\n  get = 'get',\n  settings = 'settings',\n  devSettings = 'devSettings',\n}\n\nexport const DATASOURCE: ICommonProps<DatasourceProps> = {\n  [DatasourceProps.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)],\n    mandatory: true\n  },\n  [DatasourceProps.settings]: {\n    validators: [OBJECT]\n  },\n  [DatasourceProps.devSettings]: {\n    validators: [OBJECT]\n  }\n};\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\n\nconst { NUMBER, INTEGER, INTEGER_UNLIMITED, MORE_OR_EQUAL, BOOLEAN, ELEMENT, FUNC, OR } = VALIDATORS;\n\nenum Settings {\n  adapter = 'adapter',\n  startIndex = 'startIndex',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  itemSize = 'itemSize',\n  bufferSize = 'bufferSize',\n  padding = 'padding',\n  infinite = 'infinite',\n  horizontal = 'horizontal',\n  windowViewport = 'windowViewport',\n  viewportElement = 'viewportElement',\n  inverse = 'inverse',\n  onBeforeClip = 'onBeforeClip',\n}\n\nenum DevSettings {\n  debug = 'debug',\n  immediateLog = 'immediateLog',\n  logProcessRun = 'logProcessRun',\n  logTime = 'logTime',\n  throttle = 'throttle',\n  initDelay = 'initDelay',\n  initWindowDelay = 'initWindowDelay',\n  cacheData = 'cacheData',\n  changeOverflow = 'changeOverflow',\n  dismissOverflowAnchor = 'dismissOverflowAnchor',\n}\n\nexport const MIN = {\n  [Settings.itemSize]: 1,\n  [Settings.bufferSize]: 1,\n  [Settings.padding]: 0.01,\n  [DevSettings.throttle]: 0,\n  [DevSettings.initDelay]: 0,\n  [DevSettings.initWindowDelay]: 0,\n};\n\nexport const SETTINGS: ICommonProps<Settings> = {\n  [Settings.adapter]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.startIndex]: {\n    validators: [INTEGER],\n    defaultValue: 1\n  },\n  [Settings.minIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: -Infinity\n  },\n  [Settings.maxIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: Infinity\n  },\n  [Settings.itemSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.itemSize], true)],\n    defaultValue: NaN\n  },\n  [Settings.bufferSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.bufferSize], true)],\n    defaultValue: 5\n  },\n  [Settings.padding]: {\n    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings.padding], true)],\n    defaultValue: 0.5\n  },\n  [Settings.infinite]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.horizontal]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.windowViewport]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.viewportElement]: {\n    validators: [OR([ELEMENT, FUNC])],\n    defaultValue: null\n  },\n  [Settings.inverse]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.onBeforeClip]: {\n    validators: [FUNC],\n    defaultValue: null\n  },\n};\n\nexport const DEV_SETTINGS: ICommonProps<DevSettings> = {\n  [DevSettings.debug]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.immediateLog]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n  [DevSettings.logProcessRun]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.logTime]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.throttle]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],\n    defaultValue: 40\n  },\n  [DevSettings.initDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],\n    defaultValue: 1\n  },\n  [DevSettings.initWindowDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],\n    defaultValue: 40\n  },\n  [DevSettings.cacheData]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.changeOverflow]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.dismissOverflowAnchor]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n};\n","export enum CommonProcess {\n  init = 'init',\n  scroll = 'scroll',\n  start = 'start',\n  preFetch = 'preFetch',\n  fetch = 'fetch',\n  postFetch = 'postFetch',\n  render = 'render',\n  preClip = 'preClip',\n  clip = 'clip',\n  adjust = 'adjust',\n  end = 'end',\n}\n\nexport enum AdapterProcess {\n  reset = 'adapter.reset',\n  reload = 'adapter.reload',\n  append = 'adapter.append',\n  prepend = 'adapter.prepend',\n  check = 'adapter.check',\n  remove = 'adapter.remove',\n  replace = 'adapter.replace',\n  clip = 'adapter.clip',\n  insert = 'adapter.insert',\n  fix = 'adapter.fix',\n}\n\nexport enum ProcessStatus {\n  start = 'start',\n  next = 'next',\n  done = 'done',\n  error = 'error'\n}\n","import { VALIDATORS } from './validation';\nimport { DatasourceProps as AdapterResetParams } from './datasource';\nimport { AdapterProcess as Process } from '../processes/misc/enums';\nimport { ICommonProps, AdapterProcessMap } from '../interfaces/index';\n\nconst {\n  INTEGER,\n  INTEGER_UNLIMITED,\n  BOOLEAN,\n  OBJECT,\n  ITEM_LIST,\n  FUNC_WITH_X_ARGUMENTS,\n  FUNC_WITH_X_AND_MORE_ARGUMENTS,\n  ONE_OF_MUST,\n  ONE_OF_CAN,\n  OR,\n} = VALIDATORS;\n\nenum AdapterNoParams { }\nconst NO_METHOD_PARAMS: ICommonProps<AdapterNoParams> = {};\n\nconst RESET_METHOD_PARAMS: ICommonProps<AdapterResetParams> = {\n  [AdapterResetParams.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]\n  },\n  [AdapterResetParams.settings]: {\n    validators: [OBJECT]\n  },\n  [AdapterResetParams.devSettings]: {\n    validators: [OBJECT]\n  },\n};\n\nenum AdapterReloadParams {\n  reloadIndex = 'reloadIndex',\n}\n\nconst RELOAD_METHOD_PARAMS: ICommonProps<AdapterReloadParams> = {\n  [AdapterReloadParams.reloadIndex]: {\n    validators: [INTEGER]\n  },\n};\n\nenum AdapterAppendParams {\n  items = 'items',\n  bof = 'bof',\n  eof = 'eof',\n}\n\nconst APPEND_METHOD_PARAMS: ICommonProps<AdapterAppendParams> = {\n  [AdapterAppendParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterAppendParams.bof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.eof])]\n  },\n  [AdapterAppendParams.eof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.bof])]\n  },\n};\n\nenum AdapterRemoveParams {\n  predicate = 'predicate',\n  indexes = 'indexes',\n  increase = 'increase',\n}\n\nconst REMOVE_METHOD_PARAMS: ICommonProps<AdapterRemoveParams> = {\n  [AdapterRemoveParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]\n  },\n  [AdapterRemoveParams.indexes]: {\n    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]\n  },\n  [AdapterRemoveParams.increase]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterClipParams {\n  backwardOnly = 'backwardOnly',\n  forwardOnly = 'forwardOnly',\n}\n\nconst CLIP_METHOD_PARAMS: ICommonProps<AdapterClipParams> = {\n  [AdapterClipParams.backwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],\n    defaultValue: false\n  },\n  [AdapterClipParams.forwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],\n    defaultValue: false\n  },\n};\n\nenum AdapterInsertParams {\n  items = 'items',\n  before = 'before',\n  after = 'after',\n  decrease = 'decrease',\n}\n\nconst INSERT_METHOD_PARAMS: ICommonProps<AdapterInsertParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterInsertParams.before]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.after])]\n  },\n  [AdapterInsertParams.after]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.before])]\n  },\n  [AdapterInsertParams.decrease]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterReplaceParams {\n  items = 'items',\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst REPLACE_METHOD_PARAMS: ICommonProps<AdapterReplaceParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterReplaceParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterReplaceParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  }\n};\n\nenum AdapterFixParams {\n  scrollPosition = 'scrollPosition',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  updater = 'updater',\n  scrollToItem = 'scrollToItem',\n  scrollToItemOpt = 'scrollToItemOpt',\n}\n\nconst FIX_METHOD_PARAMS: ICommonProps<AdapterFixParams> = {\n  [AdapterFixParams.scrollPosition]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.minIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.maxIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.updater]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)]\n  },\n  [AdapterFixParams.scrollToItem]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)]\n  },\n  [AdapterFixParams.scrollToItemOpt]: {\n    validators: [OR([BOOLEAN, OBJECT])]\n  },\n};\n\nexport const AdapterMethods: AdapterProcessMap<{ [key: string]: string }> = {\n  [Process.reset]: AdapterResetParams,\n  [Process.reload]: AdapterReloadParams,\n  [Process.append]: AdapterAppendParams,\n  [Process.prepend]: AdapterAppendParams,\n  [Process.check]: AdapterNoParams,\n  [Process.remove]: AdapterRemoveParams,\n  [Process.clip]: AdapterClipParams,\n  [Process.insert]: AdapterInsertParams,\n  [Process.replace]: AdapterReplaceParams,\n  [Process.fix]: AdapterFixParams,\n};\n\nexport const ADAPTER_METHODS: AdapterProcessMap<ICommonProps<PropertyKey>> = {\n  [Process.reset]: RESET_METHOD_PARAMS,\n  [Process.reload]: RELOAD_METHOD_PARAMS,\n  [Process.append]: APPEND_METHOD_PARAMS,\n  [Process.prepend]: APPEND_METHOD_PARAMS,\n  [Process.check]: NO_METHOD_PARAMS,\n  [Process.remove]: REMOVE_METHOD_PARAMS,\n  [Process.clip]: CLIP_METHOD_PARAMS,\n  [Process.insert]: INSERT_METHOD_PARAMS,\n  [Process.replace]: REPLACE_METHOD_PARAMS,\n  [Process.fix]: FIX_METHOD_PARAMS,\n};\n","export enum Direction {\n  forward = 'forward',\n  backward = 'backward'\n}\n","import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS } from '../inputs/index';\nimport { Settings as ISettings, DevSettings as IDevSettings, ICommonProps, ItemsProcessor } from '../interfaces/index';\n\nexport class Settings implements ISettings, IDevSettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n  viewportElement: HTMLElement | (() => void) | null;\n  inverse: boolean; // if true, bwd padding element will have a priority when filling the viewport (if lack of items)\n  onBeforeClip: ItemsProcessor | null;\n\n  // development settings\n  debug: boolean; // if true, logging is enabled; need to turn off when release\n  immediateLog: boolean; // if false, logging is not immediate and could be done via Workflow.logForce call\n  logTime: boolean; // if true, time differences will be logged\n  logProcessRun: boolean; // if true, process fire/run info will be logged\n  throttle: number; // if > 0, scroll event handling is throttled (ms)\n  initDelay: number; // if set, the Workflow initialization will be postponed (ms)\n  initWindowDelay: number; // if set and the entire window is scrollable, the Workflow init will be postponed (ms)\n  cacheData: boolean; // if true, item's data will be cached along with item's size and index\n  changeOverflow: boolean; // if true, scroll will be disabled per each item's average size change\n  dismissOverflowAnchor: boolean; // if true, the viewport will receive \"overflowAnchor: none\"\n\n  // internal settings, managed by scroller itself\n  instanceIndex: number;\n  initializeDelay: number;\n  viewport: HTMLElement | null;\n\n  constructor(\n    settings: ISettings | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    this.parseInput(settings, SETTINGS);\n    this.parseInput(devSettings, DEV_SETTINGS);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    this.viewport = this.getViewport();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  parseInput(input: ISettings | IDevSettings | undefined, props: ICommonProps<PropertyKey>): void {\n    const result = validate(input, props);\n    if (!result.isValid) {\n      throw new Error('Invalid settings');\n    }\n    Object.entries(result.params).forEach(([key, par]) =>\n      Object.assign(this, { [key]: par.value })\n    );\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n\n  getViewport(): HTMLElement | null {\n    if (typeof this.viewportElement !== 'function') {\n      return this.viewportElement;\n    }\n    const value = this.viewportElement();\n    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });\n    if (!result.isValid) {\n      return null; // fallback to default (null) if Function didn't return HTML element synchronously\n    }\n    return result.value as HTMLElement;\n  }\n}\n","import { AdapterProcess, ProcessStatus } from './enums';\nimport { Scroller } from '../../scroller';\nimport { ADAPTER_METHODS, validate } from '../../inputs/index';\nimport { ProcessName, IValidatedData } from '../../interfaces/index';\n\nexport interface IParseInput<T> {\n  data: IValidatedData;\n  params?: T;\n}\n\nexport interface IBaseProcess {\n  new(): any; // eslint-disable-line @typescript-eslint/no-explicit-any\n  process: ProcessName;\n}\n\nexport interface IBaseAdapterProcess extends IBaseProcess {\n  parseInput: <T>(scroller: Scroller, options: T, ignoreErrors?: boolean) => IParseInput<T>;\n}\n\nexport const BaseProcessFactory = (process: ProcessName): IBaseProcess =>\n\n  class BaseProcess {\n\n    static process: ProcessName = process;\n\n  };\n\nexport const BaseAdapterProcessFactory = (process: AdapterProcess): IBaseAdapterProcess =>\n\n  class BaseAdapterProcess extends (BaseProcessFactory(process) as IBaseProcess) {\n\n    static process: AdapterProcess = process;\n\n    static parseInput<T>(scroller: Scroller, options: T, ignoreErrors = false): IParseInput<T> {\n      const result: IParseInput<T> = {\n        data: validate(options, ADAPTER_METHODS[process])\n      };\n\n      if (result.data.isValid) {\n        result.params = Object.entries(result.data.params)\n          .reduce((acc, [key, { value }]) => ({\n            ...acc,\n            [key]: value\n          }), {} as T);\n      } else {\n        scroller.logger.log(() => result.data.showErrors());\n        if (!ignoreErrors) {\n          scroller.workflow.call({\n            process,\n            status: ProcessStatus.error,\n            payload: { error: `Wrong argument of the \"${process}\" method call` }\n          });\n        }\n      }\n\n      return result;\n    }\n\n  };\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ProcessName } from '../interfaces/index';\n\nconst initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];\n\nexport default class Init extends BaseProcessFactory(CommonProcess.init) {\n\n  static run(scroller: Scroller, process: ProcessName): void {\n    const { state: { cycle }, workflow } = scroller;\n    const isInitial = initProcesses.includes(process);\n    scroller.logger.logCycle(true);\n    cycle.start(isInitial, process);\n    workflow.call({\n      process: Init.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction, ScrollEventData, ScrollerWorkflow } from '../interfaces/index';\n\nexport default class Scroll extends BaseProcessFactory(CommonProcess.scroll) {\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static run(scroller: Scroller, payload?: { event?: Event }): void {\n    const { workflow, viewport } = scroller;\n    const position = viewport.scrollPosition;\n\n    if (Scroll.onSynthetic(scroller, position)) {\n      return;\n    }\n\n    Scroll.onThrottle(scroller, position, () =>\n      Scroll.onScroll(scroller, workflow)\n    );\n  }\n\n  static onSynthetic(scroller: Scroller, position: number): boolean {\n    const { scrollState } = scroller.state;\n    const synthPos = scrollState.syntheticPosition;\n    if (synthPos !== null) {\n      if (scrollState.syntheticFulfill) {\n        scrollState.syntheticPosition = null;\n      }\n      if (!scrollState.syntheticFulfill || synthPos === position) {\n        scroller.logger.log(() => [\n          'skipping scroll', position, `[${scrollState.syntheticFulfill ? '' : 'pre-'}synthetic]`\n        ]);\n        return true;\n      }\n      scroller.logger.log(() => [\n        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos\n      ]);\n    }\n    return false;\n  }\n\n  static onThrottle(scroller: Scroller, position: number, done: () => void): void {\n    const { state: { scrollState }, settings: { throttle }, logger } = scroller;\n    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);\n    const { direction, time } = scrollState.current;\n    const timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;\n    const delta = throttle - timeDiff;\n    const shouldDelay = isFinite(delta) && delta > 0;\n    const alreadyDelayed = !!scrollState.scrollTimer;\n    logger.log(() => [\n      direction === Direction.backward ? '\\u2934' : '\\u2935',\n      position,\n      shouldDelay ? (timeDiff + 'ms') : '0ms',\n      shouldDelay ? (alreadyDelayed ? 'delayed' : `/ ${delta}ms delay`) : ''\n    ]);\n    if (!shouldDelay) {\n      if (scrollState.scrollTimer) {\n        clearTimeout(scrollState.scrollTimer);\n        scrollState.scrollTimer = null;\n      }\n      done();\n      return;\n    }\n    if (!alreadyDelayed) {\n      scrollState.scrollTimer = setTimeout(() => {\n        logger.log(() => {\n          const curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);\n          return [\n            curr.direction === Direction.backward ? '\\u2934' : '\\u2935',\n            curr.position,\n            (curr.time - time) + 'ms',\n            'triggered by timer set on',\n            position\n          ];\n        });\n        scrollState.scrollTimer = null;\n        done();\n      }, delta);\n    }\n  }\n\n  static getScrollEvent(position: number, previous: ScrollEventData | null): ScrollEventData {\n    const time = Number(new Date());\n    let direction: Direction | null = Direction.forward;\n    if (previous) {\n      if (position === previous.position) {\n        direction = previous.direction;\n      } else if (position < previous.position) {\n        direction = Direction.backward;\n      }\n    }\n    return { position, direction, time };\n  }\n\n  static onScroll(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { state: { scrollState, cycle } } = scroller;\n    scrollState.previous = { ...(scrollState.current as ScrollEventData) };\n    scrollState.current = null;\n\n    if (cycle.busy.get()) {\n      scroller.logger.log(() => ['skipping scroll', (scrollState.previous as ScrollEventData).position, '[pending]']);\n      return;\n    }\n\n    workflow.call({\n      process: Scroll.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { ADAPTER_METHODS } from '../../inputs/index';\nimport { Datasource } from '../../classes/datasource';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { IDatasourceOptional, ProcessPayload } from '../../interfaces/index';\n\nexport default class Reset extends BaseAdapterProcessFactory(AdapterProcess.reset) {\n\n  static run(scroller: Scroller, options?: IDatasourceOptional): void {\n    const { datasource, buffer, viewport: { paddings }, state: { cycle } } = scroller;\n\n    if (options) {\n      const { data } = Reset.parseInput(scroller, options);\n      if (!data.isValid) {\n        return;\n      }\n      const constructed = options instanceof Datasource;\n      Object.keys(ADAPTER_METHODS[Reset.process]).forEach(key => {\n        const param = data.params[key];\n        if (param.isSet || (constructed && datasource[key])) {\n          datasource[key] = param.value;\n        }\n      });\n    }\n\n    buffer.reset(true);\n    paddings.backward.reset();\n    paddings.forward.reset();\n\n    const payload: ProcessPayload = { datasource };\n    if (cycle.busy.get()) {\n      payload.finalize = true;\n      cycle.interrupter = Reset.process;\n    }\n\n    scroller.workflow.call({\n      process: Reset.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { ProcessPayload } from '../../interfaces/index';\n\nexport default class Reload extends BaseAdapterProcessFactory(AdapterProcess.reload) {\n\n  static run(scroller: Scroller, reloadIndex: number): void {\n    const { viewport, state, buffer } = scroller;\n\n    const { params } = Reload.parseInput(scroller, { reloadIndex }, true);\n\n    buffer.reset(true, params ? params.reloadIndex : void 0);\n    viewport.reset(buffer.startIndex);\n\n    const payload: ProcessPayload = {};\n    if (state.cycle.busy.get()) {\n      state.scrollState.cleanupTimers();\n      payload.finalize = true;\n      state.cycle.interrupter = Reload.process;\n    }\n\n    scroller.workflow.call({\n      process: Reload.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Routines } from './domRoutines';\nimport { Direction, ItemAdapter } from '../interfaces/index';\n\nexport class Item<Data = unknown> {\n  nodeId: string;\n  routines: Routines;\n  size: number;\n  invisible: boolean;\n  toRemove: boolean;\n  removeDirection: Direction;\n\n  private container: ItemAdapter<Data>;\n\n  get $index(): number {\n    return this.container.$index;\n  }\n  set $index(value: number) {\n    this.container.$index = value;\n  }\n\n  get data(): Data {\n    return this.container.data;\n  }\n  set data(value: Data) {\n    this.container.data = value;\n  }\n\n  get element(): HTMLElement {\n    return this.container.element as HTMLElement;\n  }\n  set element(value: HTMLElement) {\n    this.container.element = value;\n  }\n\n  constructor($index: number, data: Data, routines: Routines) {\n    this.container = {\n      $index,\n      data\n    };\n    this.nodeId = String($index);\n    this.routines = routines;\n    this.invisible = true;\n  }\n\n  setSize(): void {\n    this.size = this.routines.getSize(this.element);\n  }\n\n  hide(): void {\n    if (this.element) {\n      this.routines.hideElement(this.element);\n    }\n  }\n\n  scrollTo(argument?: boolean | ScrollIntoViewOptions): void {\n    if (this.element) {\n      this.routines.scrollTo(this.element, argument);\n    }\n  }\n\n  updateIndex(index: number): void {\n    this.$index = index;\n    this.nodeId = String(index);\n  }\n\n  get(): ItemAdapter<Data> {\n    return this.container;\n  }\n}\n","import { Scroller } from '../../scroller';\nimport { Item } from '../../classes/item';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterAppendOptions, AdapterPrependOptions } from '../../interfaces/index';\n\ntype AdapterAppendPrependOptions = AdapterAppendOptions & AdapterPrependOptions;\n\ninterface AppendRunOptions {\n  process: AdapterProcess;\n  options: AdapterAppendPrependOptions;\n}\n\nexport default class Append extends BaseAdapterProcessFactory(AdapterProcess.append) {\n\n  static run(scroller: Scroller, { process, options }: AppendRunOptions): void {\n\n    const { params } = Append.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const { items, bof, eof } = params;\n    const prepend = process !== AdapterProcess.append;\n    const _eof = !!(prepend ? bof : eof);\n\n    // virtual prepend case: shift abs min index and update viewport params\n    if (\n      (prepend && _eof && !scroller.buffer.bof.get()) ||\n      (!prepend && _eof && !scroller.buffer.eof.get())\n    ) {\n      Append.doVirtualize(scroller, items, prepend);\n      scroller.workflow.call({\n        process: Append.process,\n        status: ProcessStatus.done\n      });\n      return;\n    }\n\n    Append.simulateFetch(scroller, items, _eof, prepend);\n\n    scroller.workflow.call({\n      process: Append.process,\n      status: ProcessStatus.next\n    });\n  }\n\n  static doVirtualize(scroller: Scroller, items: unknown[], prepend: boolean): void {\n    const { buffer, viewport: { paddings } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    if (isFinite(buffer[bufferToken])) {\n      const size = items.length * buffer.averageSize;\n      const padding = prepend ? paddings.backward : paddings.forward;\n      buffer[bufferToken] += (prepend ? -1 : 1) * items.length;\n      padding.size += size;\n      if (prepend) {\n        scroller.viewport.scrollPosition += size;\n      }\n      scroller.logger.log(() => `buffer.${[bufferToken]} value is set to ${buffer[bufferToken]}`);\n      scroller.logger.stat(`after virtual ${prepend ? 'prepend' : 'append'}`);\n    }\n  }\n\n  static simulateFetch(scroller: Scroller, items: unknown[], eof: boolean, prepend: boolean): boolean {\n    const { buffer, state, state: { fetch } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    let indexToAdd = buffer.getIndexToAdd(eof, prepend);\n    let bufferLimit = buffer[bufferToken];\n    const newItems: Item[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const itemToAdd = new Item(indexToAdd, items[i], scroller.routines);\n      if (isFinite(bufferLimit) && (\n        (prepend && indexToAdd < bufferLimit) ||\n        (!prepend && indexToAdd > bufferLimit)\n      )) {\n        bufferLimit += (prepend ? -1 : 1);\n      }\n      (prepend ? Array.prototype.unshift : Array.prototype.push).apply(newItems, [itemToAdd]);\n      // (prepend ? newItems.unshift : newItems.push)(itemToAdd);\n      indexToAdd += (prepend ? -1 : 1);\n    }\n\n    if (bufferLimit !== buffer[bufferToken]) {\n      buffer[bufferToken] = bufferLimit;\n      scroller.logger.log(() => `buffer.${bufferToken} value is set to ${buffer[bufferToken]}`);\n    }\n\n    (prepend ? fetch.prepend : fetch.append).call(fetch, newItems);\n    (prepend ? buffer.prepend : buffer.append).call(buffer, newItems);\n    fetch.first.indexBuffer = !isNaN(buffer.firstIndex) ? buffer.firstIndex : indexToAdd;\n    fetch.last.indexBuffer = !isNaN(buffer.lastIndex) ? buffer.lastIndex : indexToAdd;\n\n    state.clip.noClip = true;\n    return true;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../interfaces/index';\n\nexport default class Check extends BaseAdapterProcessFactory(AdapterProcess.check) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch }, viewport } = scroller;\n    let min = Infinity, max = -Infinity;\n\n    buffer.items.forEach(item => {\n      const size = item.size;\n      item.setSize();\n      if (item.size !== size) {\n        buffer.cacheItem(item);\n        min = Math.min(min, item.$index);\n        max = Math.max(max, item.$index);\n      }\n    });\n\n    if (Number.isFinite(min)) {\n      scroller.state.clip.noClip = true;\n      fetch.first.indexBuffer = buffer.firstIndex;\n      fetch.last.indexBuffer = buffer.lastIndex;\n      const { item: first, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      fetch.firstVisibleIndex = first ? first.get().$index : NaN;\n      if (!isNaN(fetch.firstVisibleIndex)) {\n        fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(fetch.firstVisibleIndex) + diff;\n      }\n      fetch.replace(\n        buffer.items.filter(item => item.$index >= min && item.$index <= max)\n      );\n    }\n\n    scroller.logger.stat('check');\n\n    workflow.call({\n      process: Check.process,\n      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction, AdapterRemoveOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Remove extends BaseAdapterProcessFactory(AdapterProcess.remove) {\n\n  static run(scroller: Scroller, options: AdapterRemoveOptions): void {\n\n    const { params } = Remove.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    const shouldRemove = Remove.doRemove(scroller, params);\n\n    scroller.workflow.call({\n      process: Remove.process,\n      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doRemove(scroller: Scroller, params: AdapterRemoveOptions, sequenceOnly = false): boolean {\n    const shouldRemove = Remove.removeBufferedItems(scroller, params);\n    const shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);\n\n    if (shouldRemove || shouldRemoveVirtual) {\n      const { clip } = scroller.state;\n      clip.simulate = true;\n      clip.increase = !!params.increase;\n      if (shouldRemove) {\n        clip.doClip = true;\n      } else {\n        clip.virtual.only = true;\n      }\n    }\n\n    return shouldRemove || shouldRemoveVirtual;\n  }\n\n  static removeBufferedItems(scroller: Scroller, options: AdapterRemoveOptions): boolean {\n    const { predicate, indexes } = options;\n    let result = false;\n    if (predicate) {\n      result = Remove.runPredicateOverBuffer(scroller, predicate);\n    }\n    if (indexes) {\n      const indexPredicate: ItemsPredicate = ({ $index }) => indexes.indexOf($index) >= 0;\n      result = Remove.runPredicateOverBuffer(scroller, indexPredicate);\n    }\n    return result;\n  }\n\n  static runPredicateOverBuffer(scroller: Scroller, predicate: ItemsPredicate): boolean {\n    const { viewport, buffer: { items } } = scroller;\n    let result = false;\n    let firstVisibleIndex = NaN;\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (predicate(item.get())) {\n        item.toRemove = true;\n        if (isNaN(firstVisibleIndex)) {\n          const firstVisible = viewport.getEdgeVisibleItem(items, Direction.backward);\n          firstVisibleIndex = firstVisible.item ? firstVisible.item.get().$index : NaN;\n        }\n        item.removeDirection = !isNaN(firstVisibleIndex) && item.$index < firstVisibleIndex\n          ? Direction.backward\n          : Direction.forward;\n        result = true;\n      } else if (result === true) {\n        // allow only first strict uninterrupted sequence\n        break;\n      }\n    }\n    return result;\n  }\n\n  static removeVirtualItems(scroller: Scroller, { indexes }: AdapterRemoveOptions, sequenceOnly: boolean): boolean {\n    if (!indexes) {\n      return false;\n    }\n    let last = NaN;\n    const { state: { clip } } = scroller;\n    const { finiteAbsMinIndex, firstIndex, finiteAbsMaxIndex, lastIndex } = scroller.buffer;\n    for (let i = 0, len = indexes.length; i < len; i++) {\n      let dir = null;\n      const index = indexes[i];\n      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {\n        dir = Direction.backward;\n      }\n      if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {\n        dir = Direction.forward;\n      }\n      if (dir !== null) {\n        if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {\n          // allow only first strict uninterrupted sequence\n          break;\n        }\n        clip.virtual[dir].push(index);\n        last = index;\n      }\n    }\n    return !isNaN(last);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterClipOptions } from '../../interfaces/index';\n\nexport default class UserClip extends BaseAdapterProcessFactory(AdapterProcess.clip) {\n\n  static run(scroller: Scroller, options?: AdapterClipOptions): void {\n    const { params } = UserClip.parseInput(scroller, options);\n\n    scroller.state.clip.forceForward = !(params && params.backwardOnly);\n    scroller.state.clip.forceBackward = !(params && params.forwardOnly);\n\n    scroller.workflow.call({\n      process: UserClip.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { Item } from '../../classes/item';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterInsertOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Insert extends BaseAdapterProcessFactory(AdapterProcess.insert) {\n\n  static run(scroller: Scroller, options: AdapterInsertOptions): void {\n\n    const { params } = Insert.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    const shouldInsert = Insert.doInsert(scroller, params);\n\n    scroller.workflow.call({\n      process: Insert.process,\n      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doInsert(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { before, after, items, decrease } = params;\n    const method = (before || after) as ItemsPredicate;\n    const found = scroller.buffer.items.find(item => method(item.get()));\n    if (!found) {\n      return false;\n    }\n    return Insert.simulateFetch(scroller, found, items, !!before, !!decrease);\n  }\n\n  static simulateFetch(\n    scroller: Scroller, from: Item, items: unknown[], before: boolean, decrement: boolean\n  ): boolean {\n    const { buffer, routines, state: { fetch, clip } } = scroller;\n    const bufferLimit = decrement ? buffer.absMinIndex : buffer.absMaxIndex;\n    const addition = before ? 0 : 1;\n    const count = items.length;\n    const itemsToInsert = items.map((item, i) =>\n      new Item(from.$index + i + addition - (decrement ? count : 0), item, routines)\n    );\n    buffer.insertItems(itemsToInsert, from, addition, !decrement);\n    scroller.logger.log(() => {\n      const newBufferLimit = decrement ? buffer.absMinIndex : buffer.absMaxIndex;\n      const isChange = bufferLimit !== newBufferLimit;\n      const token = decrement ? 'absMinIndex' : 'absMaxIndex';\n      return `buffer.${token} value ` + (\n        isChange ? `has been changed from ${bufferLimit} to ${newBufferLimit}` : 'has not been changed'\n      );\n    });\n    fetch.insert(itemsToInsert);\n    fetch.first.indexBuffer = buffer.firstIndex;\n    fetch.last.indexBuffer = buffer.lastIndex;\n    clip.noClip = true;\n    return true;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Remove from './remove';\nimport Insert from './insert';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterReplaceOptions, AdapterInsertOptions, AdapterRemoveOptions } from '../../interfaces/index';\n\nexport default class Replace extends BaseAdapterProcessFactory(AdapterProcess.replace) {\n\n  static run(scroller: Scroller, options: AdapterReplaceOptions): void {\n    const { params } = Replace.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    if (!Replace.doRemove(scroller, params)) {\n      scroller.logger.log(() => 'no items to replace (not found)');\n      return scroller.workflow.call({\n        process: Replace.process,\n        status: ProcessStatus.done\n      });\n    }\n\n    if (!Replace.doInsert(scroller, params)) {\n      return scroller.workflow.call({\n        process: Replace.process,\n        status: ProcessStatus.done\n      });\n    }\n\n    scroller.workflow.call({\n      process: Replace.process,\n      status: ProcessStatus.next\n    });\n  }\n\n  static doRemove(scroller: Scroller, params: AdapterReplaceOptions): boolean {\n    const removeOptions: AdapterRemoveOptions = {\n      predicate: params.predicate,\n      increase: params.fixRight\n    };\n    return Remove.doRemove(scroller, removeOptions, true);\n  }\n\n  static doInsert(scroller: Scroller, params: AdapterReplaceOptions): boolean {\n    const insertOptions: AdapterInsertOptions = {\n      items: params.items,\n      after: params.predicate,\n      decrease: params.fixRight\n    };\n    return Insert.doInsert(scroller, insertOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { AdapterMethods } from '../../inputs/index';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport {\n  ItemsPredicate,\n  ItemsLooper,\n  AdapterFixOptions,\n  IValidatedData,\n} from '../../interfaces/index';\n\nconst { [AdapterProcess.fix]: FixParams } = AdapterMethods;\n\nexport default class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {\n\n  static run(scroller: Scroller, options: AdapterFixOptions): void {\n    const { workflow } = scroller;\n\n    const { data, params } = Fix.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    Object.entries(data.params).forEach(([key, value]) => {\n      if (value.isSet && value.isValid) {\n        Fix.runByType(scroller, key, value.value, data);\n      }\n    });\n\n    workflow.call({\n      process: Fix.process,\n      status: ProcessStatus.done\n    });\n  }\n\n  static runByType(scroller: Scroller, token: string, value: unknown, methodData: IValidatedData): void {\n    switch (token) {\n      case FixParams.scrollPosition:\n        return Fix.setScrollPosition(scroller, value as number);\n      case FixParams.minIndex:\n        return Fix.setMinIndex(scroller, value as number);\n      case FixParams.maxIndex:\n        return Fix.setMaxIndex(scroller, value as number);\n      case FixParams.updater:\n        return Fix.updateItems(scroller, value as ItemsLooper);\n      case FixParams.scrollToItem:\n        if (methodData.params) {\n          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];\n          const options = scrollToItemOpt ? scrollToItemOpt.value as AdapterFixOptions['scrollToItemOpt'] : void 0;\n          return Fix.scrollToItem(scroller, value as ItemsPredicate, options);\n        }\n        return;\n      case FixParams.scrollToItemOpt:\n        return;\n    }\n  }\n\n  static setScrollPosition({ viewport }: Scroller, value: number): void {\n    let result = value;\n    if (value === -Infinity) {\n      result = 0;\n    } else if (value === Infinity) {\n      result = viewport.getScrollableSize();\n    }\n    viewport.setPosition(result);\n  }\n\n  static setMinIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.minIndex = value;\n    buffer.absMinIndex = value;\n  }\n\n  static setMaxIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.maxIndex = value;\n    buffer.absMaxIndex = value;\n  }\n\n  static updateItems({ buffer }: Scroller, value: ItemsLooper): void {\n    buffer.items.forEach(item => value(item.get()));\n  }\n\n  static scrollToItem(scroller: Scroller, value: ItemsPredicate, options?: boolean | ScrollIntoViewOptions): void {\n    const found = scroller.buffer.items.find(item => value(item.get()));\n    if (!found) {\n      scroller.logger.log(() => 'scrollToItem cancelled, item not found');\n      return;\n    }\n    found.scrollTo(options);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\n\nexport default class Start extends BaseProcessFactory(CommonProcess.start) {\n\n  static run(scroller: Scroller): void {\n    const { state } = scroller;\n\n    state.startInnerLoop();\n\n    scroller.workflow.call({\n      process: Start.process,\n      status: ProcessStatus.next,\n      payload: { ...(state.cycle.innerLoop.first ? { process: state.cycle.initiator } : {}) }\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../interfaces/index';\n\nexport default class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch, cycle } } = scroller;\n    fetch.minIndex = buffer.minIndex;\n\n    // set first and last indexes of items to fetch\n    PreFetch.setPositionsAndIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    if (scroller.settings.infinite) {\n      // fill indexes to include buffer if no clip\n      PreFetch.checkBufferGaps(scroller);\n    }\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    workflow.call({\n      process: PreFetch.process,\n      status: PreFetch.getStatus(scroller),\n      payload: { process: cycle.initiator }\n    });\n  }\n\n  static setPositionsAndIndexes(scroller: Scroller): void {\n    PreFetch.setPositions(scroller);\n    PreFetch.setFirstIndex(scroller);\n    PreFetch.setLastIndex(scroller);\n    scroller.logger.fetch();\n  }\n\n  static setPositions(scroller: Scroller): void {\n    const { state: { fetch: { positions } }, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    positions.before = viewport.scrollPosition;\n    positions.startDelta = PreFetch.getStartDelta(scroller);\n    positions.relative = positions.before - positions.startDelta;\n    positions.start = positions.relative - paddingDelta;\n    positions.end = positions.relative + viewport.getSize() + paddingDelta;\n  }\n\n  static getStartDelta(scroller: Scroller): number { // calculate size before start index\n    const { buffer, viewport: { offset } } = scroller;\n    let startDelta = 0;\n    if (offset) {\n      startDelta += offset;\n    }\n    if (!buffer.hasItemSize) {\n      return startDelta;\n    }\n    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {\n      startDelta += buffer.getSizeByIndex(index);\n    }\n    scroller.logger.log(() => [\n      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])\n    ]);\n    return startDelta;\n  }\n\n  static setFirstIndex(scroller: Scroller): void {\n    const { state, buffer } = scroller;\n    const { positions: { start }, first } = state.fetch;\n    let firstIndex = buffer.startIndex;\n    let firstIndexPosition = 0;\n    if (state.cycle.innerLoop.isInitial) {\n      scroller.logger.log('skipping fetch backward direction [initial loop]');\n    } else if (!buffer.hasItemSize) {\n      scroller.logger.log('skipping fetch backward direction [no item size]');\n    } else {\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) { // eslint-disable-line no-constant-condition\n        if (start >= 0) {\n          const size = buffer.getSizeByIndex(index);\n          const diff = (position + size) - start;\n          if (diff > 0) {\n            firstIndex = index;\n            firstIndexPosition = position;\n            break;\n          }\n          position += size;\n          index++;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n        }\n        if (start < 0) {\n          index--;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n          position -= buffer.getSizeByIndex(index);\n          const diff = position - start;\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (diff <= 0) {\n            break;\n          }\n        }\n      }\n    }\n    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    first.position = firstIndexPosition;\n  }\n\n  static setLastIndex(scroller: Scroller): void {\n    const { state: { fetch, cycle }, buffer, settings } = scroller;\n    const { positions: { relative, end }, first, last } = fetch;\n    let lastIndex;\n    if (!buffer.hasItemSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = buffer.startIndex + settings.bufferSize - 1;\n      scroller.logger.log('forcing fetch forward direction [no item size]');\n    } else {\n      let index = first.indexBuffer;\n      let position = first.position;\n      lastIndex = index;\n      while (1) { // eslint-disable-line no-constant-condition\n        lastIndex = index;\n        const size = buffer.getSizeByIndex(index);\n        position += size;\n        if (isNaN(fetch.firstVisibleIndex) && position > relative) {\n          fetch.firstVisibleIndex = index;\n          if (!cycle.innerLoop.isInitial) {\n            fetch.firstVisibleItemDelta = position - size - relative;\n          }\n        }\n        if (position >= end) {\n          break;\n        }\n        if (index++ > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller): void {\n    const { buffer } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const packs: number[][] = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);\n    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkBufferGaps(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const fetchFirst = fetch.first.index;\n    const bufferLast = buffer.lastIndex;\n    if (fetchFirst > bufferLast) {\n      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;\n    }\n    const bufferFirst = buffer.firstIndex;\n    const fetchLast = fetch.last.index;\n    if (fetchLast < bufferFirst) {\n      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;\n    }\n    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {\n      scroller.logger.fetch('after Buffer filling (no clip case)');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.last.index = fetch.last.indexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.last.index) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n  static getStatus(scroller: Scroller): ProcessStatus {\n    const { cycle, fetch } = scroller.state;\n    if (cycle.initiator === AdapterProcess.clip) {\n      scroller.logger.log(() => `going to skip fetch due to \"${AdapterProcess.clip}\" process`);\n      return ProcessStatus.next;\n    }\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n      return ProcessStatus.next;\n    }\n    return ProcessStatus.done;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ObservableLike } from '../interfaces/index';\n\ninterface Immediate {\n  data: unknown[] | null;\n  error: unknown | null;\n  isError: boolean;\n}\n\ntype FetchGetResult = Immediate | Promise<unknown>;\n\ninterface FetchBox {\n  success: (value: unknown[]) => void;\n  fail: (value: unknown) => void;\n}\n\nexport default class Fetch extends BaseProcessFactory(CommonProcess.fetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n\n    const box = {\n      success: (data: unknown[]) => {\n        scroller.logger.log(() =>\n          `resolved ${data.length} items ` +\n          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`\n        );\n        scroller.state.fetch.newItemsData = data;\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.next\n        });\n      },\n      fail: (error: unknown) =>\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.error,\n          payload: { error }\n        })\n    };\n\n    const result = Fetch.get(scroller);\n    Fetch.complete(scroller, box, result);\n  }\n\n  static complete(scroller: Scroller, box: FetchBox, result: FetchGetResult): void {\n    if (Object.prototype.hasOwnProperty.call(result, 'data')) {\n      const { data, error, isError } = result as Immediate;\n      if (!isError) {\n        box.success(data || []);\n      } else {\n        box.fail(error);\n      }\n    } else {\n      const { state: { scrollState, fetch }, viewport } = scroller;\n      if (scrollState.positionBeforeAsync === null) {\n        scrollState.positionBeforeAsync = viewport.scrollPosition;\n      }\n      fetch.cancel = () => {\n        box.success = () => null;\n        box.fail = () => null;\n      };\n      (result as Promise<unknown[]>).then(\n        (data) => box.success(data),\n        (error) => box.fail(error)\n      );\n    }\n  }\n\n  static get(scroller: Scroller): FetchGetResult {\n    const _get = scroller.datasource.get;\n    const { index, count } = scroller.state.fetch;\n\n    let immediateData, immediateError;\n    let resolve: (value: unknown) => void, reject: (value: unknown) => void;\n\n    const done = (data: unknown[]) => {\n      if (!resolve) {\n        immediateData = data || null;\n        return;\n      }\n      resolve(data);\n    };\n    const fail = (error: unknown) => {\n      if (!reject) {\n        immediateError = error || null;\n        return;\n      }\n      reject(error);\n    };\n\n    const getResult = _get(index, count, done, fail);\n\n    if (getResult && typeof getResult === 'object' && getResult !== null) {\n      if (typeof (getResult as PromiseLike<unknown>).then === 'function') {\n        return getResult as Promise<unknown>;\n      } else if (typeof (getResult as ObservableLike).subscribe === 'function') {\n        const sub = (getResult as ObservableLike).subscribe(done, fail, () => sub.unsubscribe());\n      }\n    }\n\n    if (immediateData || immediateError) { // callback case or immediate observable\n      return {\n        data: immediateError ? null : (immediateData || []),\n        error: immediateError,\n        isError: !!immediateError\n      };\n    }\n\n    return new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class PostFetch extends BaseProcessFactory(CommonProcess.postFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n    if (PostFetch.setItems(scroller)) {\n      PostFetch.setBufferLimits(scroller);\n      workflow.call({\n        process: PostFetch.process,\n        status: scroller.state.fetch.hasNewItems\n          ? ProcessStatus.next\n          : ProcessStatus.done\n      });\n    } else {\n      workflow.call({\n        process: PostFetch.process,\n        status: ProcessStatus.error,\n        payload: { error: 'Can\\'t set buffer items' }\n      });\n    }\n  }\n\n  static setBufferLimits(scroller: Scroller): void {\n    const { buffer, state: { fetch, fetch: { items }, cycle: { innerLoop } } } = scroller;\n    const first = fetch.first.index;\n    const last = fetch.last.index;\n    if (!items.length) {\n      if (last < buffer.minIndex || innerLoop.isInitial) {\n        buffer.absMinIndex = buffer.minIndex;\n      }\n      if (first > buffer.maxIndex || innerLoop.isInitial) {\n        buffer.absMaxIndex = buffer.maxIndex;\n      }\n    } else {\n      const lastIndex = items.length - 1;\n      if (first < items[0].$index) {\n        buffer.absMinIndex = items[0].$index;\n      }\n      if (last > items[lastIndex].$index) {\n        buffer.absMaxIndex = items[lastIndex].$index;\n      }\n    }\n  }\n\n  static setItems(scroller: Scroller): boolean {\n    const { buffer, state: { fetch, cycle } } = scroller;\n    const items = fetch.newItemsData;\n    if (!items || !items.length) { // empty result\n      return true;\n    }\n    // eof/bof case, need to shift fetch index if bof\n    let fetchIndex = fetch.index;\n    if (items.length < fetch.count) {\n      if (cycle.innerLoop.isInitial) {\n        // let's treat initial poor fetch as startIndex-bof\n        fetchIndex = buffer.startIndex;\n      } else if (fetch.first.index < buffer.minIndex) { // normal bof\n        fetchIndex = buffer.minIndex - items.length;\n      }\n    }\n    fetch.items = items.map((item, index: number) =>\n      new Item(fetchIndex + index, item, scroller.routines)\n    );\n    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;\n    return buffer.setItems(fetch.items);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class Render extends BaseProcessFactory(CommonProcess.render) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, state: { cycle, render, scrollState }, viewport } = scroller;\n    scroller.logger.stat('before new items render');\n    if (scrollState.positionBeforeAsync === null) {\n      scrollState.positionBeforeAsync = viewport.scrollPosition;\n    }\n    render.renderTimer = setTimeout(() => {\n      render.renderTimer = null;\n      if (Render.processElements(scroller)) {\n        workflow.call({\n          process: Render.process,\n          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,\n          payload: { process: cycle.initiator }\n        });\n      } else {\n        workflow.call({\n          process: Render.process,\n          status: ProcessStatus.error,\n          payload: { error: 'Can\\'t associate item with element' }\n        });\n      }\n    }, 0);\n  }\n\n  static processElements(scroller: Scroller): boolean {\n    const { state: { fetch, render }, viewport, buffer, logger } = scroller;\n    render.positionBefore = viewport.scrollPosition;\n    if (!fetch.isReplace) {\n      render.sizeBefore = viewport.getScrollableSize();\n      if (\n        fetch.items.map(item => Render.processElement(scroller, item)).some(x => !x)\n      ) {\n        return false;\n      }\n    }\n    buffer.checkAverageSize();\n    render.sizeAfter = viewport.getScrollableSize();\n    logger.stat('after new items render');\n    logger.log(() => render.noSize ? 'viewport size has not been changed' : void 0);\n    return true;\n  }\n\n  static processElement(scroller: Scroller, item: Item): boolean {\n    const { state: { fetch }, viewport, buffer } = scroller;\n    const element = viewport.element.querySelector(`[data-sid=\"${item.nodeId}\"]`);\n    if (!element) {\n      return false;\n    }\n    item.element = element as HTMLElement;\n    item.element.style.left = '';\n    item.element.style.position = '';\n    item.invisible = false;\n    item.setSize();\n    buffer.cacheItem(item);\n    if (item.$index < fetch.minIndex) {\n      fetch.negativeSize += item.size;\n    }\n    return true;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\n\r\nexport default class Adjust extends BaseProcessFactory(CommonProcess.adjust) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow, viewport, state: { scrollState } } = scroller;\r\n    scrollState.positionBeforeAdjust = viewport.scrollPosition;\r\n\r\n    // padding-elements adjustments\r\n    if (!Adjust.setPaddings(scroller)) {\r\n      return workflow.call({\r\n        process: Adjust.process,\r\n        status: ProcessStatus.error,\r\n        payload: { error: 'Can\\'t get visible item' }\r\n      });\r\n    }\r\n    scrollState.positionAfterAdjust = viewport.scrollPosition;\r\n\r\n    // scroll position adjustments\r\n    const position = Adjust.calculatePosition(scroller);\r\n\r\n    // set new position using animation frame\r\n    Adjust.setPosition(scroller, position, () =>\r\n      workflow.call({\r\n        process: Adjust.process,\r\n        status: ProcessStatus.done\r\n      })\r\n    );\r\n  }\r\n\r\n  static setPaddings(scroller: Scroller): boolean {\r\n    const { viewport, buffer, settings: { inverse } } = scroller;\r\n    const firstItem = buffer.getFirstVisibleItem();\r\n    const lastItem = buffer.getLastVisibleItem();\r\n    if (!firstItem || !lastItem) {\r\n      return false;\r\n    }\r\n    const { forward, backward } = viewport.paddings;\r\n    let index, bwdSize = 0, fwdSize = 0;\r\n\r\n    // new backward and forward paddings size\r\n    for (index = buffer.finiteAbsMinIndex; index < firstItem.$index; index++) {\r\n      bwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n    for (index = lastItem.$index + 1; index <= buffer.finiteAbsMaxIndex; index++) {\r\n      fwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n\r\n    // lack of items case\r\n    const bufferSize = viewport.getScrollableSize() - forward.size - backward.size;\r\n    const viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);\r\n    if (viewportSizeDiff > 0) {\r\n      if (inverse) {\r\n        bwdSize += viewportSizeDiff;\r\n      } else {\r\n        fwdSize += viewportSizeDiff;\r\n      }\r\n      scroller.logger.log(() =>\r\n        inverse ? 'backward' : 'forward' + ` padding will be increased by ${viewportSizeDiff} to fill the viewport`\r\n      );\r\n    }\r\n\r\n    backward.size = bwdSize;\r\n    forward.size = fwdSize;\r\n\r\n    scroller.logger.stat('after paddings adjustments');\r\n    return true;\r\n  }\r\n\r\n  static calculatePosition(scroller: Scroller): number {\r\n    const { viewport, buffer, state } = scroller;\r\n    const { fetch, render, scrollState } = state;\r\n    let position = viewport.paddings.backward.size;\r\n\r\n    // backward outlet increase\r\n    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {\r\n      for (let i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {\r\n        position += buffer.getSizeByIndex(i);\r\n      }\r\n      if (fetch.firstVisibleItemDelta) {\r\n        position -= fetch.firstVisibleItemDelta;\r\n      }\r\n    } else {\r\n      if (fetch.isPrepend && fetch.negativeSize) {\r\n        position += fetch.negativeSize;\r\n      }\r\n    }\r\n\r\n    // change per slow fetch/render\r\n    if (scrollState.positionBeforeAsync !== null) {\r\n      const diff = render.positionBefore - scrollState.positionBeforeAsync;\r\n      if (diff !== 0) {\r\n        scroller.logger.log(`shift position due to fetch-render difference (${diff})`);\r\n        position += diff;\r\n      }\r\n    }\r\n\r\n    // offset increase\r\n    if (viewport.offset > 0 && (position || fetch.positions.before)) {\r\n      position += viewport.offset;\r\n    }\r\n\r\n    return Math.round(position);\r\n  }\r\n\r\n  static setPosition(scroller: Scroller, position: number, done: () => void): void {\r\n    const { state: { scrollState }, viewport } = scroller;\r\n    if (!scrollState.hasPositionChanged(position)) {\r\n      return done();\r\n    }\r\n    scrollState.syntheticPosition = position;\r\n    scrollState.syntheticFulfill = false;\r\n\r\n    scrollState.animationFrameId = requestAnimationFrame(() => {\r\n      const inertiaDiff = (scrollState.positionAfterAdjust as number) - viewport.scrollPosition;\r\n      let diffLog = '';\r\n      if (inertiaDiff > 0) {\r\n        position -= inertiaDiff;\r\n        scrollState.syntheticPosition = position;\r\n        diffLog = ` (-${inertiaDiff})`;\r\n      }\r\n      scrollState.syntheticFulfill = true;\r\n      viewport.scrollPosition = position;\r\n      scroller.logger.stat('after scroll adjustment' + diffLog);\r\n      done();\r\n    });\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../interfaces/index';\n\nexport default class PreClip extends BaseProcessFactory(CommonProcess.preClip) {\n\n  static run(scroller: Scroller): void {\n    PreClip.prepareClip(scroller);\n\n    scroller.workflow.call({\n      process: PreClip.process,\n      status: ProcessStatus.next,\n      payload: {\n        doClip: scroller.state.clip.doClip\n      }\n    });\n  }\n\n  static prepareClip(scroller: Scroller): void {\n    const { state: { fetch, clip } } = scroller;\n    if (PreClip.shouldNotClip(scroller)) {\n      return;\n    }\n    const firstIndex = fetch.first.indexBuffer;\n    const lastIndex = fetch.last.indexBuffer;\n    scroller.logger.log(() =>\n      `looking for ${fetch.direction ? 'anti-' + fetch.direction + ' ' : ''}items ` +\n      `that are out of [${firstIndex}..${lastIndex}] range`);\n    if (PreClip.isBackward(scroller, firstIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);\n    }\n    if (PreClip.isForward(scroller, lastIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);\n    }\n    if (!clip.doClip) {\n      scroller.logger.log('skipping clip [no items to clip]');\n    }\n    return;\n  }\n\n  static shouldNotClip(scroller: Scroller): boolean {\n    const { settings, buffer, state } = scroller;\n    if (settings.infinite) {\n      scroller.logger.log('skipping clip [infinite mode]');\n      return true;\n    }\n    if (!buffer.size) {\n      scroller.logger.log('skipping clip [empty buffer]');\n      return true;\n    }\n    if (state.cycle.isInitial) {\n      scroller.logger.log('skipping clip [initial cycle]');\n      return true;\n    }\n    return false;\n  }\n\n  static isBackward(scroller: Scroller, firstIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceBackward;\n    }\n    if (fetch.direction !== Direction.backward) {\n      if (firstIndex - 1 >= buffer.absMinIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static isForward(scroller: Scroller, lastIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceForward;\n    }\n    if (fetch.direction !== Direction.forward) {\n      if (lastIndex + 1 <= buffer.absMaxIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static prepareClipByDirection(scroller: Scroller, direction: Direction, edgeIndex: number): void {\n    const forward = direction === Direction.forward;\n    scroller.buffer.items.forEach(item => {\n      if (\n        (!forward && item.$index < edgeIndex) ||\n        (forward && item.$index > edgeIndex)\n      ) {\n        item.toRemove = true;\n        item.removeDirection = direction;\n        scroller.state.clip.doClip = true;\n      }\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\nimport { Direction } from '../interfaces/index';\r\n\r\nexport default class Clip extends BaseProcessFactory(CommonProcess.clip) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow, state } = scroller;\r\n\r\n    Clip.doClip(scroller);\r\n\r\n    workflow.call({\r\n      process: Clip.process,\r\n      status: ProcessStatus.next,\r\n      payload: { process: state.cycle.initiator }\r\n    });\r\n  }\r\n\r\n  static doClip(scroller: Scroller): void {\r\n    const { viewport, logger, state: { clip } } = scroller;\r\n    const position = viewport.scrollPosition;\r\n\r\n    logger.stat(`before clip (${++clip.callCount})`);\r\n\r\n    if (!clip.virtual.only) {\r\n      Clip.onBuffered(scroller);\r\n    }\r\n    if (clip.virtual.has) {\r\n      Clip.onVirtual(scroller);\r\n    }\r\n    viewport.scrollPosition = position;\r\n\r\n    logger.stat('after clip');\r\n  }\r\n\r\n  static onBuffered(scroller: Scroller): void {\r\n    const { buffer, viewport: { paddings }, logger, state: { clip } } = scroller;\r\n    const size = { backward: 0, forward: 0 };\r\n    const removeViaAdapter = clip.simulate && !clip.force;\r\n\r\n    const itemsToRemove = buffer.items.filter(item => {\r\n      if (!item.toRemove) {\r\n        return false;\r\n      }\r\n      item.hide();\r\n      size[item.removeDirection] += item.size;\r\n      if (!removeViaAdapter) { // do not adjust paddings in case of Adapter remove\r\n        const padding = paddings.byDirection(item.removeDirection);\r\n        padding.size += item.size;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    if (scroller.settings.onBeforeClip && itemsToRemove.length) {\r\n      scroller.settings.onBeforeClip(itemsToRemove.map(item => item.get()));\r\n    }\r\n\r\n    const indexesToRemove = itemsToRemove.map(({ $index }) => $index);\r\n    if (removeViaAdapter) {\r\n      buffer.removeItems(indexesToRemove, !clip.increase, false);\r\n    } else { // common clip case\r\n      buffer.items = buffer.items.filter(({ toRemove }) => !toRemove);\r\n    }\r\n\r\n    logger.log(() => indexesToRemove.length\r\n      ? [\r\n        `clipped ${indexesToRemove.length} item(s) from Buffer` +\r\n        (\r\n          removeViaAdapter\r\n            ? ` (via adapter), -${size.backward + size.forward}px`\r\n            : (size.backward ? `, +${size.backward} fwd px` : '') + (size.forward ? `, +${size.forward} bwd px` : '')\r\n        ) +\r\n        `, range: [${indexesToRemove[0]}..${indexesToRemove[indexesToRemove.length - 1]}]`\r\n      ]\r\n      : 'clipped 0 items from Buffer');\r\n  }\r\n\r\n  static onVirtual(scroller: Scroller): void {\r\n    const { buffer, viewport: { paddings }, logger, state: { clip } } = scroller;\r\n    const size = { backward: 0, forward: 0 };\r\n    const virtualIndexesToRemove = clip.virtual.all;\r\n\r\n    [Direction.backward, Direction.forward].forEach(dir => {\r\n      size[dir] = clip.virtual[dir].reduce((acc, index) => acc + buffer.getSizeByIndex(index), 0);\r\n      paddings[dir].size -= size[dir];\r\n    });\r\n\r\n    buffer.removeItems(virtualIndexesToRemove, !clip.increase, true);\r\n\r\n    logger.log(() => [\r\n      `clipped ${virtualIndexesToRemove.length} virtual item(s)` +\r\n      (size.backward ? `, +${size.backward} fwd px` : '') +\r\n      (size.forward ? `, +${size.forward} bwd px` : '') +\r\n      `, [${virtualIndexesToRemove.join(' ')}]`\r\n    ]);\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { EMPTY_ITEM } from '../classes/adapter/props';\nimport { Direction, ScrollerWorkflow } from '../interfaces/index';\n\nconst isInterrupted = ({ call }: ScrollerWorkflow): boolean => !!call.interrupted;\n\nexport default class End extends BaseProcessFactory(CommonProcess.end) {\n\n  static run(scroller: Scroller, { error }: { error?: unknown } = {}): void {\n    const { workflow, state: { cycle: { interrupter } } } = scroller;\n\n    if (!error && !interrupter) {\n      // set out params accessible via Adapter\n      End.calculateParams(scroller, workflow);\n    }\n\n    // explicit interruption for we don't want to go through the inner loop finalizing\n    if (isInterrupted(workflow)) {\n      workflow.call({ process: End.process, status: ProcessStatus.done });\n      return;\n    }\n\n    const next = End.finalizeInnerLoop(scroller, error);\n\n    workflow.call({\n      process: End.process,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: { ...(interrupter ? { process: interrupter } : {}) }\n    });\n  }\n\n  static calculateParams(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { adapter, viewport, buffer: { items } } = scroller;\n\n    if (adapter.wanted.firstVisible) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.backward);\n      if (!item || item.element !== adapter.firstVisible.element) {\n        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n\n    // the workflow can be interrupter on firstVisible change\n    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.forward);\n      if (!item || item.element !== adapter.lastVisible.element) {\n        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n  }\n\n  static finalizeInnerLoop(scroller: Scroller, error: unknown): boolean {\n    const { state, state: { cycle, clip, fetch } } = scroller;\n    const next = !!cycle.interrupter || (error ? false : End.getNext(scroller));\n    cycle.innerLoop.isInitial = false;\n    fetch.stopSimulate();\n    clip.noClip = scroller.settings.infinite || (next && clip.simulate);\n    clip.forceReset();\n    state.endInnerLoop();\n    return next;\n  }\n\n  static getNext(scroller: Scroller): boolean {\n    const { state: { clip, fetch, render } } = scroller;\n    if (clip.simulate) { // Adapter.remove\n      return true;\n    }\n    if (fetch.simulate && fetch.isReplace) { // Adapter.check (todo: combine with following)\n      return true;\n    }\n    if (fetch.simulate && !render.noSize) { // Adapter.append/prepend/insert affected viewport size\n      return true;\n    }\n    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch\n      !fetch.simulate &&\n      ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { CommonProcess, AdapterProcess, ProcessStatus as Status } from '../processes/index';\nimport { IPackages, ProcessSubject } from '../interfaces/index';\n\ntype LogType = [unknown?, ...unknown[]];\n\nexport class Logger {\n\n  readonly debug: boolean;\n  readonly immediateLog: boolean;\n  readonly logTime: boolean;\n  readonly getTime: () => string;\n  readonly getStat: () => string;\n  readonly getFetchRange: () => string;\n  readonly getWorkflowCycleData: () => string;\n  readonly getLoopId: () => string;\n  readonly getLoopIdNext: () => string;\n  readonly getScrollPosition: (element: HTMLElement) => number;\n  private logs: unknown[][] = [];\n\n  constructor(scroller: Scroller, packageInfo: IPackages) {\n    const { settings } = scroller;\n    this.debug = settings.debug;\n    this.immediateLog = settings.immediateLog;\n    this.logTime = settings.logTime;\n    this.getTime = (): string =>\n      scroller.state && ` // time: ${scroller.state.time}`;\n    this.getStat = (): string => {\n      const { buffer, viewport } = scroller;\n      const first = buffer.getFirstVisibleItem();\n      const last = buffer.getLastVisibleItem();\n      return 'pos: ' + viewport.scrollPosition + ', ' +\n        'size: ' + viewport.getScrollableSize() + ', ' +\n        'bwd_p: ' + viewport.paddings.backward.size + ', ' +\n        'fwd_p: ' + viewport.paddings.forward.size + ', ' +\n        'aver: ' + (buffer.hasItemSize ? buffer.averageSize : 'no') + ', ' +\n        'items: ' + buffer.getVisibleItemsCount() + ', ' +\n        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');\n    };\n    this.getFetchRange = (): string => {\n      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;\n      return !Number.isNaN(first) && !Number.isNaN(last)\n        ? `[${first}..${last}]`\n        : 'no';\n    };\n    this.getLoopId = (): string => scroller.state.cycle.loopId;\n    this.getLoopIdNext = (): string => scroller.state.cycle.loopIdNext;\n    this.getWorkflowCycleData = (): string =>\n      `${settings.instanceIndex}-${scroller.state.cycle.count}`;\n    this.getScrollPosition = (element: HTMLElement) => scroller.routines.getScrollPosition(element);\n    this.log(() =>\n      'uiScroll Workflow has been started, ' +\n      `core: ${packageInfo.core.name} v${packageInfo.core.version} (instance ${settings.instanceIndex}), ` +\n      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}`\n    );\n  }\n\n  object(str: string, obj: unknown, stringify?: boolean): void {\n    this.log(() => [\n      str,\n      stringify\n        ? JSON.stringify(obj, (k, v) => {\n          if (Number.isNaN(v)) {\n            return 'NaN';\n          }\n          if (v === Infinity) {\n            return 'Infinity';\n          }\n          if (v === -Infinity) {\n            return '-Infinity';\n          }\n          if (v instanceof Element) {\n            return 'HTMLElement';\n          }\n          if (v instanceof HTMLDocument) {\n            return 'HTMLDocument';\n          }\n          if (typeof v === 'function') {\n            return 'Function';\n          }\n          return v;\n        })\n          .replace(/\"/g, '')\n          .replace(/(\\{|:|,)/g, '$1 ')\n          .replace(/(\\})/g, ' $1')\n        : obj\n    ]);\n  }\n\n  stat(str?: string): void {\n    if (this.debug) {\n      const logStyles = [\n        'color: #888; border: dashed #888 0; border-bottom-width: 0px',\n        'color: #000; border-width: 0'\n      ];\n      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);\n    }\n  }\n\n  fetch(str?: string): void {\n    if (this.debug) {\n      const _text = 'fetch interval' + (str ? ` ${str}` : '');\n      const logStyles = ['color: #888', 'color: #000'];\n      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);\n    }\n  }\n\n  prepareForLog(data: unknown): unknown {\n    return data instanceof Event && data.target\n      ? this.getScrollPosition(data.target as HTMLElement)\n      : data;\n  }\n\n  logProcess(data: ProcessSubject): void {\n    if (!this.debug) {\n      return;\n    }\n    const { process, status, payload } = data;\n\n    // inner loop start-end log\n    const loopLog: string[] = [];\n    if (\n      process === CommonProcess.init && status === Status.next\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);\n    } else if (\n      process === CommonProcess.end\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);\n      const parent = payload && payload.process;\n      if (status === Status.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {\n        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;\n      }\n    }\n    if (loopLog.length) {\n      this.log(() => [...loopLog, 'color: #006600;']);\n    }\n  }\n\n  logCycle(start = true): void {\n    const logData = this.getWorkflowCycleData();\n    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';\n    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;\n    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);\n  }\n\n  logError(str: string): void {\n    if (this.debug) {\n      const logStyles = ['color: #a00;', 'color: #000'];\n      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);\n    }\n  }\n\n  logAdapterMethod = (methodName: string, args?: unknown, add?: string): void => {\n    if (!this.debug) {\n      return;\n    }\n    const params = (\n      args === void 0 ? [] : (Array.isArray(args) ? args : [args])\n    )\n      .map((arg: unknown) => {\n        if (typeof arg === 'function') {\n          return 'func';\n        } else if (typeof arg !== 'object' || !arg) {\n          return arg;\n        } else if (Array.isArray(arg)) {\n          return `[of ${arg.length}]`;\n        }\n        return '{ ' + Object.keys(arg).join(', ') + ' }';\n      })\n      .join(', ');\n    this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);\n  }\n\n  log(...args: any[]): void {\n    if (this.debug) {\n      if (typeof args[0] === 'function') {\n        args = args[0]();\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n      }\n      if (args.every(item => item === void 0)) {\n        return;\n      }\n      if (this.logTime) {\n        args = [...args, this.getTime()];\n      }\n      args = args.map((arg: unknown) => this.prepareForLog(arg));\n      if (this.immediateLog) {\n        console.log.apply(this, args as LogType);\n      } else {\n        this.logs.push(args);\n      }\n    }\n  }\n\n  // logNow(...args: any[]) {\n  //   const immediateLog = this.immediateLog;\n  //   const debug = this.debug;\n  //   (this as any).debug = true;\n  //   (this as any).immediateLog = true;\n  //   this.log.apply(this, args);\n  //   (this as any).debug = debug;\n  //   (this as any).immediateLog = immediateLog;\n  // }\n\n  logForce(...args: unknown[]): void {\n    if (this.debug) {\n      if (!this.immediateLog && this.logs.length) {\n        this.logs.forEach(logArgs => console.log.apply(this, logArgs));\n        this.logs = [];\n      }\n      if (args.length) {\n        console.log.apply(this, args as LogType);\n      }\n    }\n  }\n}\n","import { Settings } from './settings';\nimport { Direction } from '../interfaces/direction';\n\nexport class Routines {\n\n  readonly horizontal: boolean;\n  readonly window: boolean;\n\n  constructor(settings: Settings) {\n    this.horizontal = settings.horizontal;\n    this.window = settings.windowViewport;\n  }\n\n  checkElement(element: HTMLElement): void {\n    if (!element) {\n      throw new Error('HTML element is not defined');\n    }\n  }\n\n  getScrollPosition(element: HTMLElement): number {\n    if (this.window) {\n      return window.pageYOffset;\n    }\n    this.checkElement(element);\n    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];\n  }\n\n  setScrollPosition(element: HTMLElement, value: number): void {\n    value = Math.max(0, value);\n    if (this.window) {\n      if (this.horizontal) {\n        window.scrollTo(value, window.scrollY);\n      } else {\n        window.scrollTo(window.scrollX, value);\n      }\n      return;\n    }\n    this.checkElement(element);\n    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;\n  }\n\n  getParams(element: HTMLElement, doNotBind?: boolean): ClientRect {\n    this.checkElement(element);\n    if (this.window && doNotBind) {\n      return {\n        'height': element.clientHeight,\n        'width': element.clientWidth,\n        'top': element.clientTop,\n        'bottom': element.clientTop + element.clientHeight,\n        'left': element.clientLeft,\n        'right': element.clientLeft + element.clientWidth\n      };\n    }\n    return element.getBoundingClientRect();\n  }\n\n  getSize(element: HTMLElement, doNotBind?: boolean): number {\n    return this.getParams(element, doNotBind)[this.horizontal ? 'width' : 'height'];\n  }\n\n  getSizeStyle(element: HTMLElement): number {\n    this.checkElement(element);\n    const size = element.style[this.horizontal ? 'width' : 'height'];\n    return parseInt(size as string, 10) || 0;\n  }\n\n  setSizeStyle(element: HTMLElement, value: number): void {\n    this.checkElement(element);\n    value = Math.max(0, Math.round(value));\n    element.style[this.horizontal ? 'width' : 'height'] = `${value}px`;\n  }\n\n  getEdge(element: HTMLElement, direction: Direction, doNotBind?: boolean): number {\n    const params = this.getParams(element, doNotBind);\n    const isFwd = direction === Direction.forward;\n    return params[isFwd ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];\n  }\n\n  getEdge2(element: HTMLElement, direction: Direction, relativeElement: HTMLElement, opposite: boolean): number {\n    // vertical only ?\n    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +\n      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);\n  }\n\n  hideElement(element: HTMLElement): void {\n    this.checkElement(element);\n    element.style.display = 'none';\n  }\n\n  getOffset(element: HTMLElement): number {\n    this.checkElement(element);\n    return (this.horizontal ? element.offsetLeft : element.offsetTop) || 0;\n  }\n\n  scrollTo(element: HTMLElement, argument?: boolean | ScrollIntoViewOptions): void {\n    this.checkElement(element);\n    element.scrollIntoView(argument);\n  }\n\n}\n","import { Routines } from './domRoutines';\r\nimport { Settings } from './settings';\r\nimport { Direction } from '../interfaces/direction';\r\n\r\nexport class Padding {\r\n\r\n  element: HTMLElement;\r\n  direction: Direction;\r\n  routines: Routines;\r\n\r\n  constructor(element: HTMLElement, direction: Direction, routines: Routines) {\r\n    this.element = element.querySelector(`[data-padding-${direction}]`) as HTMLElement;\r\n    this.direction = direction;\r\n    this.routines = routines;\r\n  }\r\n\r\n  reset(size?: number): void {\r\n    this.size = size || 0;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.routines.getSizeStyle(this.element);\r\n  }\r\n\r\n  set size(value: number) {\r\n    this.routines.setSizeStyle(this.element, value);\r\n  }\r\n\r\n}\r\n\r\nexport class Paddings {\r\n  settings: Settings;\r\n  forward: Padding;\r\n  backward: Padding;\r\n\r\n  constructor(element: HTMLElement, routines: Routines, settings: Settings) {\r\n    this.settings = settings;\r\n    this.forward = new Padding(element, Direction.forward, routines);\r\n    this.backward = new Padding(element, Direction.backward, routines);\r\n  }\r\n\r\n  byDirection(direction: Direction, opposite?: boolean): Padding {\r\n    return direction === Direction.backward\r\n      ? (opposite ? this.forward : this.backward)\r\n      : (opposite ? this.backward : this.forward);\r\n  }\r\n\r\n  reset(viewportSize: number, startIndex: number, offset: number): void {\r\n    const positive = this.getPositiveSize(startIndex, viewportSize, offset);\r\n    const negative = this.getNegativeSize(startIndex);\r\n    if (this.settings.inverse) {\r\n      this.forward.reset(negative);\r\n      this.backward.reset(positive);\r\n      const diff = viewportSize - this.backward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size += diff;\r\n        this.forward.size -= diff;\r\n      }\r\n    } else {\r\n      this.forward.reset(positive);\r\n      this.backward.reset(negative);\r\n      const diff = viewportSize - this.forward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size -= diff;\r\n        this.forward.size += diff;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  getPositiveSize(startIndex: number, viewportSize: number, offset: number): number {\r\n    const { settings } = this;\r\n    let positiveSize = viewportSize;\r\n    if (isFinite(settings.maxIndex)) {\r\n      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;\r\n    }\r\n    if (offset) {\r\n      positiveSize = Math.max(positiveSize - offset, 0);\r\n    }\r\n    return positiveSize;\r\n  }\r\n\r\n  getNegativeSize(startIndex: number): number {\r\n    const { settings } = this;\r\n    let negativeSize = 0;\r\n    if (isFinite(settings.minIndex)) {\r\n      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;\r\n    }\r\n    return negativeSize;\r\n  }\r\n}\r\n","import { Paddings } from './paddings';\nimport { Settings } from './settings';\nimport { Routines } from './domRoutines';\nimport { Item } from './item';\nimport { State } from './state';\nimport { Logger } from './logger';\nimport { Direction } from '../interfaces/index';\n\nexport class Viewport {\n\n  offset: number;\n  paddings: Paddings;\n\n  readonly element: HTMLElement;\n  readonly settings: Settings;\n  readonly routines: Routines;\n  readonly state: State;\n  readonly logger: Logger;\n\n  readonly hostElement: HTMLElement;\n  readonly scrollEventReceiver: HTMLElement | Window;\n\n  private disabled: boolean;\n\n  constructor(element: HTMLElement, settings: Settings, routines: Routines, state: State, logger: Logger) {\n    this.element = element;\n    this.settings = settings;\n    this.routines = routines;\n    this.state = state;\n    this.logger = logger;\n    this.disabled = false;\n\n    if (settings.windowViewport) {\n      this.hostElement = document.documentElement as HTMLElement;\n      this.scrollEventReceiver = window;\n    } else {\n      this.hostElement = settings.viewport || this.element.parentElement as HTMLElement;\n      this.scrollEventReceiver = this.hostElement;\n    }\n\n    this.paddings = new Paddings(this.element, this.routines, settings);\n\n    if (settings.windowViewport && 'scrollRestoration' in history) {\n      history.scrollRestoration = 'manual';\n    }\n\n    if (settings.dismissOverflowAnchor) {\n      this.hostElement.style.overflowAnchor = 'none';\n    }\n  }\n\n  reset(startIndex: number): void {\n    this.setOffset();\n    this.paddings.reset(this.getSize(), startIndex, this.offset);\n    this.scrollPosition = this.paddings.backward.size || 0;\n    this.state.scrollState.reset();\n  }\n\n  setPosition(value: number): number {\n    const oldPosition = this.scrollPosition;\n    if (oldPosition === value) {\n      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);\n      return value;\n    }\n    this.routines.setScrollPosition(this.hostElement, value);\n    const position = this.scrollPosition;\n    this.logger.log(() => [\n      'setting scroll position at', position, ...(position !== value ? [`(${value})`] : [])\n    ]);\n    return position;\n  }\n\n  get scrollPosition(): number {\n    return this.routines.getScrollPosition(this.hostElement);\n  }\n\n  set scrollPosition(value: number) {\n    this.setPosition(value);\n  }\n\n  disableScrollForOneLoop(): void {\n    if (this.disabled) {\n      return;\n    }\n    const { style } = this.hostElement;\n    if (style.overflowY === 'hidden') {\n      return;\n    }\n    this.disabled = true;\n    const overflow = style.overflowY;\n    setTimeout(() => {\n      this.disabled = false;\n      style.overflowY = overflow;\n    });\n    style.overflowY = 'hidden';\n  }\n\n  getSize(): number {\n    return this.routines.getSize(this.hostElement, true);\n  }\n\n  getScrollableSize(): number {\n    return this.routines.getSize(this.element);\n  }\n\n  getBufferPadding(): number {\n    return this.getSize() * this.settings.padding;\n  }\n\n  getEdge(direction: Direction): number {\n    return this.routines.getEdge(this.hostElement, direction, true);\n  }\n\n  setOffset(): void {\n    this.offset = this.routines.getOffset(this.element);\n    if (!this.settings.windowViewport) {\n      this.offset -= this.routines.getOffset(this.hostElement);\n    }\n  }\n\n  getEdgeVisibleItem(items: Item[], direction: Direction): { item?: Item, diff: number } {\n    const bwd = direction === Direction.backward;\n    const opposite = bwd ? Direction.forward : Direction.backward;\n    const viewportEdge = this.getEdge(direction);\n    let item, diff = 0;\n    for (\n      let i = bwd ? 0 : items.length - 1;\n      bwd ? i <= items.length - 1 : i >= 0;\n      i += bwd ? 1 : -1\n    ) {\n      const itemEdge = this.routines.getEdge(items[i].element, opposite);\n      diff = itemEdge - viewportEdge;\n      if (bwd && diff > 0 || !bwd && diff < 0) {\n        item = items[i];\n        break;\n      }\n    }\n    return { item, diff };\n  }\n\n}\n","import { Item } from './item';\nimport { Logger } from './logger';\n\nexport class ItemCache<Data = unknown> {\n  $index: number;\n  nodeId: string;\n  data: Data | null;\n  size: number;\n  position: number;\n\n  constructor(item: Item<Data>, saveData: boolean) {\n    this.$index = item.$index;\n    this.nodeId = item.nodeId;\n    this.data = saveData ? item.data : null;\n    this.size = item.size;\n  }\n\n  changeIndex(value: number): void {\n    this.$index = value;\n    this.nodeId = String(value);\n  }\n}\n\ninterface ItemSize {\n  $index: number;\n  size: number;\n  newSize?: number;\n}\n\nexport class RecalculateAverage {\n  newItems: ItemSize[];\n  oldItems: ItemSize[];\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.newItems = [];\n    this.oldItems = [];\n  }\n}\n\nexport class Cache<Data = unknown> {\n  averageSizeFloat: number;\n  averageSize: number;\n  minIndex: number;\n  maxIndex: number;\n  recalculateAverage: RecalculateAverage;\n\n  private items: Map<number, ItemCache<Data>>;\n  readonly logger: Logger;\n  readonly itemSize: number;\n  readonly saveData: boolean;\n\n  constructor(itemSize: number, saveData: boolean, logger: Logger) {\n    this.averageSizeFloat = itemSize;\n    this.averageSize = itemSize;\n    this.itemSize = itemSize;\n    this.saveData = saveData;\n    this.items = new Map<number, ItemCache<Data>>();\n    this.recalculateAverage = new RecalculateAverage();\n    this.reset();\n    this.logger = logger;\n  }\n\n  reset(): void {\n    this.minIndex = +Infinity;\n    this.maxIndex = -Infinity;\n    this.items.clear();\n    this.averageSizeFloat = this.itemSize;\n    this.averageSize = this.itemSize;\n    this.recalculateAverage.reset();\n  }\n\n  recalculateAverageSize(): boolean {\n    const { oldItems: { length: oldItemsLength }, newItems: { length: newItemsLength } } = this.recalculateAverage;\n    if (!oldItemsLength && !newItemsLength) {\n      return false;\n    }\n    if (oldItemsLength) {\n      const oldItemsSize = this.recalculateAverage.oldItems.reduce((acc, item) => acc + item.size, 0);\n      const newItemsSize = this.recalculateAverage.oldItems.reduce((acc, item) => acc + (item.newSize as number), 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = averageSize - (oldItemsSize - newItemsSize) / (this.items.size - newItemsLength);\n    }\n    if (newItemsLength) {\n      const newItemsSize = this.recalculateAverage.newItems.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      const averageSizeLength = this.items.size - newItemsLength;\n      this.averageSizeFloat = (averageSizeLength * averageSize + newItemsSize) / this.items.size;\n    }\n    this.averageSize = Math.round(this.averageSizeFloat);\n    this.recalculateAverage.reset();\n    this.logger.log(() => `average size has been updated: ${this.averageSize}`);\n    return true;\n  }\n\n  add(item: Item<Data>): ItemCache<Data> {\n    let itemCache = this.get(item.$index);\n    if (itemCache) {\n      itemCache.data = item.data;\n      if (itemCache.size !== item.size) {\n        this.recalculateAverage.oldItems.push({\n          $index: item.$index,\n          size: itemCache.size,\n          newSize: item.size\n        });\n        itemCache.size = item.size;\n      }\n    } else {\n      itemCache = new ItemCache<Data>(item, this.saveData);\n      this.items.set(item.$index, itemCache);\n      if (this.averageSize !== itemCache.size) {\n        this.recalculateAverage.newItems.push({ $index: item.$index, size: itemCache.size });\n      }\n    }\n    if (item.$index < this.minIndex) {\n      this.minIndex = item.$index;\n    }\n    if (item.$index > this.maxIndex) {\n      this.maxIndex = item.$index;\n    }\n    return itemCache;\n  }\n\n  getItemSize(index: number): number {\n    const item = this.get(index);\n    return item ? item.size : 0;\n  }\n\n  get(index: number): ItemCache<Data> | undefined {\n    return this.items.get(index);\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  removeItems(toRemove: number[], immutableTop: boolean): void {\n    const items = new Map<number, ItemCache<Data>>();\n    let min = Infinity, max = -Infinity;\n    this.items.forEach(item => {\n      if (toRemove.some(index => index === item.$index)) {\n        return;\n      }\n      const diff = immutableTop\n        ? toRemove.reduce((acc, index) => acc - (item.$index > index ? 1 : 0), 0)\n        : toRemove.reduce((acc, index) => acc + (item.$index < index ? 1 : 0), 0);\n      item.changeIndex(item.$index + diff);\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    });\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n\n  insertItems(index: number, count: number, immutableTop: boolean): void {\n    // we do not insert new items here, we just shift indexes of the existed items\n    // new items adding must be performed via Cache.add\n    const items = new Map<number, ItemCache<Data>>();\n    this.items.forEach(item => {\n      const { $index } = item;\n      if ($index < index) {\n        if (!immutableTop) {\n          item.changeIndex($index - count);\n        }\n        items.set(item.$index, item);\n      } else {\n        if (immutableTop) {\n          item.changeIndex($index + count);\n        }\n        items.set(item.$index, item);\n      }\n      if (item.$index < this.minIndex) {\n        this.minIndex = item.$index;\n      }\n      if (item.$index > this.maxIndex) {\n        this.maxIndex = item.$index;\n      }\n    });\n    this.items = items;\n  }\n}\n","import { Cache } from './cache';\nimport { Item } from './item';\nimport { Settings } from './settings';\nimport { Logger } from './logger';\nimport { Reactive } from './reactive';\nimport { Direction, OnDataChanged } from '../interfaces/index';\n\nexport class Buffer<Data> {\n\n  private _items: Item<Data>[];\n  private _absMinIndex: number;\n  private _absMaxIndex: number;\n  bof: Reactive<boolean>;\n  eof: Reactive<boolean>;\n\n  changeItems: OnDataChanged<Data>;\n  minIndexUser: number;\n  maxIndexUser: number;\n  startIndexUser: number;\n  startIndex: number;\n\n  private pristine: boolean;\n  private cache: Cache<Data>;\n  readonly logger: Logger;\n\n  constructor(settings: Settings, onDataChanged: OnDataChanged<Data>, logger: Logger) {\n    this.logger = logger;\n    this.changeItems = onDataChanged;\n    this.bof = new Reactive<boolean>(false);\n    this.eof = new Reactive<boolean>(false);\n    this.cache = new Cache<Data>(settings.itemSize, settings.cacheData, logger);\n    this.startIndexUser = settings.startIndex;\n    this.minIndexUser = settings.minIndex;\n    this.maxIndexUser = settings.maxIndex;\n    this.reset();\n  }\n\n  dispose(): void {\n    this.bof.dispose();\n    this.eof.dispose();\n  }\n\n  reset(reload?: boolean, startIndex?: number): void {\n    if (reload) {\n      this.items.forEach(item => item.hide());\n    }\n    this.pristine = true;\n    this.items = [];\n    this.cache.reset();\n    this.absMinIndex = this.minIndexUser;\n    this.absMaxIndex = this.maxIndexUser;\n    this.setCurrentStartIndex(startIndex);\n    this.bof.set(false);\n    this.eof.set(false);\n    this.pristine = false;\n  }\n\n  setCurrentStartIndex(newStartIndex?: unknown): void {\n    const min = this.minIndexUser;\n    const max = this.maxIndexUser;\n    const start = this.startIndexUser;\n    let index = Number(newStartIndex);\n    if (Number.isNaN(index)) {\n      this.logger.log(() => `fallback startIndex to settings.startIndex (${start})`);\n      index = start;\n    }\n    if (index < min) {\n      this.logger.log(() => `setting startIndex to settings.minIndex (${min}) because ${index} < ${min}`);\n      index = min;\n    }\n    if (index > max) {\n      this.logger.log(() => `setting startIndex to settings.maxIndex (${max}) because ${index} > ${max}`);\n      index = max;\n    }\n    this.startIndex = index;\n  }\n\n  set items(items: Item<Data>[]) {\n    this._items = items;\n    this.changeItems(items);\n    if (!this.pristine) {\n      this.checkBOF();\n      this.checkEOF();\n    }\n  }\n\n  get items(): Item<Data>[] {\n    return this._items;\n  }\n\n  set absMinIndex(value: number) {\n    if (this._absMinIndex !== value) {\n      this._absMinIndex = value;\n    }\n    if (!this.pristine) {\n      this.checkBOF();\n    }\n  }\n\n  get absMinIndex(): number {\n    return this._absMinIndex;\n  }\n\n  set absMaxIndex(value: number) {\n    if (this._absMaxIndex !== value) {\n      this._absMaxIndex = value;\n    }\n    if (!this.pristine) {\n      this.checkEOF();\n    }\n  }\n\n  get absMaxIndex(): number {\n    return this._absMaxIndex;\n  }\n\n  private checkBOF() {\n    // since bof has no setter, need to call checkBOF() on items and absMinIndex change\n    const bof = this.items.length\n      ? (this.items[0].$index === this.absMinIndex)\n      : isFinite(this.absMinIndex);\n    this.bof.set(bof);\n  }\n\n  private checkEOF() {\n    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change\n    const eof = this.items.length\n      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)\n      : isFinite(this.absMaxIndex);\n    this.eof.set(eof);\n  }\n\n  get size(): number {\n    return this._items.length;\n  }\n\n  get cacheSize(): number {\n    return this.cache.size;\n  }\n\n  get averageSize(): number {\n    return this.cache.averageSize;\n  }\n\n  get hasItemSize(): boolean {\n    return this.averageSize > 0;\n  }\n\n  get minIndex(): number {\n    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;\n  }\n\n  get maxIndex(): number {\n    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;\n  }\n\n  get firstIndex(): number {\n    return this.items.length ? this.items[0].$index : NaN;\n  }\n\n  get lastIndex(): number {\n    return this.items.length ? this.items[this.items.length - 1].$index : NaN;\n  }\n\n  get finiteAbsMinIndex(): number {\n    return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;\n  }\n\n  get finiteAbsMaxIndex(): number {\n    return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;\n  }\n\n  get($index: number): Item<Data> | undefined {\n    return this.items.find(item => item.$index === $index);\n  }\n\n  setItems(items: Item<Data>[]): boolean {\n    if (!this.items.length) {\n      this.items = [...items];\n    } else if (this.items[0].$index > items[items.length - 1].$index) {\n      this.items = [...items, ...this.items];\n    } else if (items[0].$index > this.items[this.items.length - 1].$index) {\n      this.items = [...this.items, ...items];\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  append(items: Item<Data>[]): void {\n    this.items = [...this.items, ...items];\n  }\n\n  prepend(items: Item<Data>[]): void {\n    this.items = [...items, ...this.items];\n  }\n\n  removeItems(indexes: number[], immutableTop: boolean, virtual = false): void {\n    const result: Item<Data>[] = [];\n    const toRemove: number[] = virtual ? indexes : [];\n    const length = this.items.length;\n    for (\n      let i = immutableTop ? 0 : length - 1;\n      immutableTop ? i < length : i >= 0;\n      immutableTop ? i++ : i--\n    ) {\n      const item = this.items[i];\n      if (!virtual && indexes.indexOf(item.$index) >= 0) {\n        toRemove.push(item.$index);\n        continue;\n      }\n      const diff = toRemove.reduce((acc, index) => acc + (immutableTop\n        ? (item.$index > index ? -1 : 0)\n        : (item.$index < index ? 1 : 0)\n      ), 0);\n      item.updateIndex(item.$index + diff);\n      if (!virtual) {\n        if (immutableTop) {\n          result.push(item);\n        } else {\n          result.unshift(item);\n        }\n      }\n    }\n    if (immutableTop) {\n      this.absMaxIndex -= toRemove.length;\n    } else {\n      this.absMinIndex += toRemove.length;\n      this.startIndex += toRemove.length;\n    }\n    if (!virtual) {\n      this.items = result;\n    }\n    this.cache.removeItems(toRemove, immutableTop);\n  }\n\n  insertItems(items: Item<Data>[], from: Item<Data>, addition: number, immutableTop: boolean): void {\n    const count = items.length;\n    const index = this.items.indexOf(from) + addition;\n    const itemsBefore = this.items.slice(0, index);\n    const itemsAfter = this.items.slice(index);\n    if (immutableTop) {\n      itemsAfter.forEach(item => item.updateIndex(item.$index + count));\n    } else {\n      itemsBefore.forEach(item => item.updateIndex(item.$index - count));\n    }\n    const result = [\n      ...itemsBefore,\n      ...items,\n      ...itemsAfter\n    ];\n    if (immutableTop) {\n      this.absMaxIndex += count;\n    } else {\n      this.absMinIndex -= count;\n      this.startIndex -= count;\n    }\n    this.items = result;\n    this.cache.insertItems(from.$index + addition, count, immutableTop);\n  }\n\n  cacheItem(item: Item<Data>): void {\n    this.cache.add(item);\n  }\n\n  getFirstVisibleItemIndex(): number {\n    const length = this.items.length;\n    for (let i = 0; i < length; i++) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getLastVisibleItemIndex(): number {\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getFirstVisibleItem(): Item<Data> | undefined {\n    const index = this.getFirstVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getLastVisibleItem(): Item<Data> | undefined {\n    const index = this.getLastVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getEdgeVisibleItem(direction: Direction, opposite?: boolean): Item<Data> | undefined {\n    return direction === (!opposite ? Direction.forward : Direction.backward) ?\n      this.getLastVisibleItem() : this.getFirstVisibleItem();\n  }\n\n  getVisibleItemsCount(): number {\n    return this.items.reduce((acc: number, item) => acc + (item.invisible ? 0 : 1), 0);\n  }\n\n  getSizeByIndex(index: number): number {\n    const item = this.cache.get(index);\n    return item ? item.size : this.averageSize;\n  }\n\n  checkAverageSize(): boolean {\n    return this.cache.recalculateAverageSize();\n  }\n\n  getIndexToAppend(eof?: boolean): number {\n    return (!eof\n      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)\n      : this.absMaxIndex\n    ) + (this.size ? 1 : 0);\n  }\n\n  getIndexToPrepend(bof?: boolean): number {\n    return (!bof\n      ? (this.size ? this.items[0].$index : this.minIndex)\n      : this.absMinIndex\n    ) - (this.size ? 1 : 0);\n  }\n\n  getIndexToAdd(eof: boolean, prepend: boolean): number {\n    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);\n  }\n\n}\n","import { ProcessName } from '../../interfaces/index';\nimport { Reactive } from '../reactive';\n\nclass InnerLoopModel {\n  total: number;\n  count: number;\n  isInitial: boolean;\n  busy: Reactive<boolean>;\n\n  get first(): boolean {\n    return this.count === 0;\n  }\n\n  constructor(total: number) {\n    this.total = total;\n    this.isInitial = false;\n    this.busy = new Reactive<boolean>(false);\n  }\n\n  done() {\n    this.count++;\n    this.total++;\n    this.busy.set(false);\n  }\n\n  start() {\n    this.busy.set(true);\n  }\n\n  dispose() {\n    this.busy.dispose();\n  }\n}\n\nexport class WorkflowCycleModel {\n  instanceIndex: number;\n  count: number;\n  isInitial: boolean;\n  initiator: ProcessName;\n  innerLoop: InnerLoopModel;\n  interrupter: ProcessName | null;\n  busy: Reactive<boolean>;\n\n  get loopId(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total}`;\n  }\n\n  get loopIdNext(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total + 1}`;\n  }\n\n  constructor(instanceIndex: number, cycle?: WorkflowCycleModel) {\n    const cycleCount = cycle ? cycle.count : 1;\n    const loopCount = cycle ? cycle.innerLoop.count : 0;\n\n    this.instanceIndex = instanceIndex;\n    this.innerLoop = new InnerLoopModel(loopCount);\n    this.interrupter = null;\n    this.busy = new Reactive<boolean>(false);\n    this.done(cycleCount);\n  }\n\n  done(count: number): void {\n    this.count = count;\n    this.isInitial = false;\n    this.busy.set(false);\n  }\n\n  start(isInitial: boolean, initiator: ProcessName): void {\n    this.isInitial = isInitial;\n    this.initiator = initiator;\n    this.innerLoop.isInitial = isInitial;\n    this.innerLoop.count = 0;\n    this.interrupter = null;\n    this.busy.set(true);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) {\n      // otherwise the value will be persisted during re-instantiation\n      this.busy.dispose();\n    }\n    this.innerLoop.dispose();\n  }\n}\n","import { Item } from '../item';\nimport { Direction } from '../../interfaces/index';\n\nclass Positions {\n  startDelta: number;\n  before: number;\n  relative: number;\n  start: number;\n  end: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.startDelta = 0;\n    this.before = 0;\n  }\n}\n\nclass First {\n  index: number;\n  indexBuffer: number;\n  position: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n    this.position = NaN;\n  }\n}\n\nclass Last {\n  index: number;\n  indexBuffer: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n  }\n}\n\nexport class FetchModel {\n  private _newItemsData: unknown[] | null;\n\n  items: Item[];\n  positions: Positions;\n  first: First;\n  last: Last;\n  hasAnotherPack: boolean;\n  callCount: number;\n  minIndex: number;\n  firstVisibleIndex: number;\n  firstVisibleItemDelta: number;\n  negativeSize: number;\n  direction: Direction | null;\n  cancel: (() => void) | null;\n\n  simulate: boolean;\n  isPrepend: boolean;\n  isReplace: boolean;\n\n  constructor() {\n    this.callCount = 0;\n    this.positions = new Positions();\n    this.first = new First();\n    this.last = new Last();\n    this.reset();\n  }\n\n  reset(): void {\n    this._newItemsData = null;\n    this.items = [];\n    this.positions.reset();\n    this.first.reset();\n    this.last.reset();\n    this.hasAnotherPack = false;\n    this.firstVisibleIndex = NaN;\n    this.firstVisibleItemDelta = NaN;\n    this.negativeSize = 0;\n    this.direction = null;\n    this.cancel = null;\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isReplace = false;\n  }\n\n  get newItemsData(): unknown[] | null {\n    return this._newItemsData;\n  }\n\n  set newItemsData(items: unknown[] | null) {\n    this._newItemsData = items;\n    if (items && items.length) {\n      this.callCount++;\n    }\n  }\n\n  get shouldFetch(): boolean {\n    return !!this.count;\n  }\n\n  get hasNewItems(): boolean {\n    return !!((this._newItemsData && this._newItemsData.length));\n  }\n\n  get index(): number {\n    return this.first.index;\n  }\n\n  get count(): number {\n    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;\n  }\n\n  startSimulate(items: Item[]): void {\n    this.simulate = true;\n    this._newItemsData = items.map(item => item.data);\n    this.items = items;\n    this.hasAnotherPack = false;\n    this.negativeSize = 0;\n  }\n\n  stopSimulate(): void {\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isReplace = false;\n  }\n\n  append(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[items.length - 1].$index;\n    this.first.index = items[0].$index;\n    this.direction = Direction.forward;\n  }\n\n  prepend(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.direction = Direction.backward;\n    this.isPrepend = true;\n  }\n\n  replace(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.isReplace = true;\n  }\n\n  insert(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n  }\n}\n","import { Direction } from '../../interfaces/index';\n\nclass VirtualClip {\n  [Direction.backward]: number[];\n  [Direction.forward]: number[];\n  only: boolean;\n\n  get all(): number[] {\n    return [...this[Direction.backward], ...this[Direction.forward]];\n  }\n\n  get has(): boolean {\n    return !!this[Direction.backward].length || !!this[Direction.forward].length;\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this[Direction.backward] = [];\n    this[Direction.forward] = [];\n    this.only = false;\n  }\n}\n\nexport class ClipModel {\n  noClip: boolean;\n  doClip: boolean;\n  simulate: boolean;\n  increase: boolean;\n  callCount: number;\n  forceForward: boolean;\n  forceBackward: boolean;\n  virtual: VirtualClip;\n\n  get force(): boolean {\n    return this.forceForward || this.forceBackward;\n  }\n\n  private infinite: boolean;\n\n  constructor() {\n    this.infinite = false;\n    this.noClip = this.infinite;\n    this.callCount = 0;\n    this.virtual = new VirtualClip();\n    this.reset();\n  }\n\n  reset(isForce?: boolean): void {\n    this.doClip = false;\n    if (!isForce) {\n      this.forceReset();\n    } else {\n      this.simulate = false;\n    }\n    this.increase = false;\n    this.virtual.reset();\n  }\n\n  forceReset(): void {\n    this.simulate = false;\n    this.forceForward = false;\n    this.forceBackward = false;\n  }\n}\n","export class RenderModel {\n  sizeBefore: number;\n  sizeAfter: number;\n  positionBefore: number;\n  renderTimer: ReturnType<typeof setTimeout> | null;\n\n  get noSize(): boolean {\n    return this.sizeBefore === this.sizeAfter;\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.sizeBefore = 0;\n    this.sizeAfter = 0;\n    this.positionBefore = 0;\n    this.renderTimer = null;\n  }\n}\n","import {\n  ScrollEventData as IScrollEventData,\n  ScrollState as IScrollState\n} from '../../interfaces/index';\n\nexport class ScrollState implements IScrollState {\n  previous: IScrollEventData | null;\n  current: IScrollEventData | null;\n\n  scrollTimer: ReturnType<typeof setTimeout> | null;\n\n  syntheticPosition: number | null;\n  syntheticFulfill: boolean;\n  animationFrameId: number;\n  positionBeforeAsync: number | null;\n  positionBeforeAdjust: number | null;\n  positionAfterAdjust: number | null;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.previous = null;\n    this.current = null;\n    this.syntheticPosition = null;\n    this.syntheticFulfill = false;\n    this.positionBeforeAsync = null;\n    this.positionBeforeAdjust = null;\n    this.positionAfterAdjust = null;\n    this.cleanupTimers();\n  }\n\n  cleanupTimers(): void {\n    if (this.scrollTimer) {\n      clearTimeout(this.scrollTimer);\n      this.scrollTimer = null;\n    }\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = 0;\n    }\n  }\n\n  hasPositionChanged(position: number): boolean {\n    const before = this.positionBeforeAdjust;\n    const after = this.positionAfterAdjust;\n    return before === null || before !== position || after === null || after !== position;\n  }\n}\n","import { Settings } from './settings';\r\nimport { WorkflowCycleModel } from './state/cycle';\r\nimport { FetchModel } from './state/fetch';\r\nimport { ClipModel } from './state/clip';\r\nimport { RenderModel } from './state/render';\r\nimport { ScrollState } from './state/scroll';\r\nimport { State as IState, IPackages, ScrollState as IScrollState } from '../interfaces/index';\r\n\r\nexport class State implements IState {\r\n\r\n  readonly packageInfo: IPackages;\r\n  private settings: Settings;\r\n\r\n  initTime: number;\r\n\r\n  cycle: WorkflowCycleModel;\r\n\r\n  fetch: FetchModel;\r\n  clip: ClipModel;\r\n  render: RenderModel;\r\n\r\n  scrollState: IScrollState;\r\n\r\n  get time(): number {\r\n    return Number(new Date()) - this.initTime;\r\n  }\r\n\r\n  constructor(packageInfo: IPackages, settings: Settings, state?: IState) {\r\n    this.packageInfo = packageInfo;\r\n    this.settings = settings;\r\n\r\n    this.initTime = Number(new Date());\r\n\r\n    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);\r\n\r\n    this.fetch = new FetchModel();\r\n    this.clip = new ClipModel();\r\n    this.render = new RenderModel();\r\n\r\n    this.scrollState = new ScrollState();\r\n  }\r\n\r\n  endInnerLoop(): void {\r\n    const { fetch, render, cycle } = this;\r\n    if (fetch.cancel) {\r\n      fetch.cancel();\r\n      fetch.cancel = null;\r\n    }\r\n    if (render.renderTimer) {\r\n      clearTimeout(render.renderTimer);\r\n      render.renderTimer = null;\r\n    }\r\n    cycle.innerLoop.done();\r\n  }\r\n\r\n  startInnerLoop(): void {\r\n    const { cycle, scrollState: scroll, fetch, render, clip } = this;\r\n    cycle.innerLoop.start();\r\n    scroll.positionBeforeAsync = null;\r\n    if (!fetch.simulate) {\r\n      fetch.reset();\r\n    }\r\n    if (!clip.simulate) {\r\n      clip.reset(clip.force);\r\n    }\r\n    render.reset();\r\n  }\r\n\r\n  dispose(): void {\r\n    this.cycle.dispose();\r\n    this.endInnerLoop();\r\n    this.scrollState.cleanupTimers();\r\n  }\r\n\r\n}\r\n","import { Logger } from './logger';\r\nimport { Buffer } from './buffer';\r\nimport { Reactive } from './reactive';\r\nimport { AdapterPropName, AdapterPropType, getDefaultAdapterProps } from './adapter/props';\r\nimport { AdapterContext } from './adapter/context';\r\nimport { AdapterProcess, ProcessStatus } from '../processes/index';\r\nimport {\r\n  WorkflowGetter,\r\n  IAdapterProp,\r\n  IReactivePropsStore,\r\n  AdapterMethodResult,\r\n  IAdapter,\r\n  ItemAdapter,\r\n  ItemsPredicate,\r\n  AdapterPrependOptions,\r\n  AdapterAppendOptions,\r\n  AdapterRemoveOptions,\r\n  AdapterClipOptions,\r\n  AdapterInsertOptions,\r\n  AdapterReplaceOptions,\r\n  AdapterFixOptions,\r\n  ScrollerWorkflow,\r\n  IDatasourceOptional,\r\n  IPackages,\r\n  IBufferInfo,\r\n  State,\r\n  ProcessSubject,\r\n} from '../interfaces/index';\r\n\r\nconst ADAPTER_PROPS_STUB = getDefaultAdapterProps();\r\n\r\nconst _has = (obj: unknown, prop: string): boolean =>\r\n  typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\nconst convertAppendArgs = <Item>(prepend: boolean, options: unknown, eof?: boolean) => {\r\n  let result = options as AdapterAppendOptions<Item> & AdapterPrependOptions<Item>;\r\n  if (!_has(options, 'items')) {\r\n    const items = !Array.isArray(options) ? [options] : options;\r\n    result = prepend ? { items, bof: eof } : { items, eof: eof };\r\n  }\r\n  return result;\r\n};\r\n\r\nconst convertRemoveArgs = <Item>(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>) => {\r\n  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {\r\n    const predicate = options as ItemsPredicate<Item>;\r\n    options = { predicate };\r\n  }\r\n  return options;\r\n};\r\n\r\nconst adapterMethodPreResult: AdapterMethodResult = {\r\n  success: false,\r\n  immediate: true,\r\n  details: 'Adapter is not initialized'\r\n};\r\n\r\nexport class Adapter<Item = unknown> implements IAdapter<Item> {\r\n  private logger: Logger;\r\n  private getWorkflow: WorkflowGetter<Item>;\r\n  private reloadCounter: number;\r\n  private source: { [key: string]: Reactive<unknown> } = {}; // for Reactive props\r\n  private box: { [key: string]: unknown } = {}; // for Scalars over Reactive props\r\n  private demand: { [key: string]: unknown } = {}; // for Scalars on demand\r\n  public wanted: { [key: string]: boolean } = {};\r\n\r\n  get workflow(): ScrollerWorkflow<Item> {\r\n    return this.getWorkflow();\r\n  }\r\n  get reloadCount(): number {\r\n    return this.reloadCounter;\r\n  }\r\n  get reloadId(): string {\r\n    return this.id + '.' + this.reloadCounter;\r\n  }\r\n\r\n  id: number;\r\n  mock: boolean;\r\n  version: string;\r\n  init: boolean;\r\n  init$: Reactive<boolean>;\r\n  packageInfo: IPackages;\r\n  itemsCount: number;\r\n  bufferInfo: IBufferInfo;\r\n  isLoading: boolean;\r\n  isLoading$: Reactive<boolean>;\r\n  loopPending: boolean;\r\n  loopPending$: Reactive<boolean>;\r\n  firstVisible: ItemAdapter<Item>;\r\n  firstVisible$: Reactive<ItemAdapter<Item>>;\r\n  lastVisible: ItemAdapter<Item>;\r\n  lastVisible$: Reactive<ItemAdapter<Item>>;\r\n  bof: boolean;\r\n  bof$: Reactive<boolean>;\r\n  eof: boolean;\r\n  eof$: Reactive<boolean>;\r\n\r\n  private relax$: Reactive<AdapterMethodResult> | null;\r\n  private relaxRun: Promise<AdapterMethodResult> | null;\r\n\r\n  private getPromisifiedMethod(method: (...args: any[]) => void) {\r\n    return (...args: any[]): Promise<AdapterMethodResult> =>\r\n      new Promise(resolve => {\r\n        if (this.relax$) {\r\n          this.relax$.once(value => resolve(value));\r\n        }\r\n        method.apply(this, args);\r\n        if (!this.relax$) {\r\n          resolve(adapterMethodPreResult);\r\n        }\r\n      });\r\n  }\r\n\r\n  constructor(publicContext: IAdapter<Item> | null, getWorkflow: WorkflowGetter<Item>, logger: Logger) {\r\n    this.getWorkflow = getWorkflow;\r\n    this.logger = logger;\r\n    this.relax$ = null;\r\n    this.relaxRun = null;\r\n    this.reloadCounter = 0;\r\n    const context: AdapterContext | null = publicContext ? (publicContext as unknown as AdapterContext) : null;\r\n\r\n    // public context stores Reactive props configuration\r\n    const reactivePropsStore: IReactivePropsStore =\r\n      context && context.reactiveConfiguredProps || {};\r\n\r\n    // make array of the original values from public context if present\r\n    const adapterProps = context\r\n      ? ADAPTER_PROPS_STUB.map(prop => ({\r\n        ...prop,\r\n        value: context[prop.name]\r\n      }))\r\n      : getDefaultAdapterProps();\r\n\r\n    // restore default reactive props if they were configured\r\n    Object.entries(reactivePropsStore).forEach(([key, value]) => {\r\n      const prop = adapterProps.find(({ name }) => name === key);\r\n      if (prop && value) {\r\n        prop.value = value.default;\r\n      }\r\n    });\r\n\r\n    // Scalar permanent props\r\n    adapterProps\r\n      .filter(({ type, permanent }) => type === AdapterPropType.Scalar && permanent)\r\n      .forEach(({ name, value }: IAdapterProp) =>\r\n        Object.defineProperty(this, name, {\r\n          get: () => value\r\n        })\r\n      );\r\n\r\n    // Reactive props\r\n    // 1) store original values in \"source\" container, to avoid extra .get() calls on scalar twins set\r\n    // 2) \"wanted\" container is bound with scalars; get() updates it\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Reactive)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.source[name] = value as Reactive<unknown>;\r\n        Object.defineProperty(this, name, {\r\n          get: () => {\r\n            const scalarWanted = ADAPTER_PROPS_STUB.find(\r\n              ({ wanted, reactive }) => wanted && reactive === name\r\n            );\r\n            if (scalarWanted) {\r\n              this.wanted[scalarWanted.name] = true;\r\n            }\r\n            return this.source[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props that have Reactive twins\r\n    // 1) scalars should use \"box\" container\r\n    // 2) \"wanted\" should be updated on get\r\n    // 3) reactive props (from \"source\") are triggered on set\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && !!prop.reactive)\r\n      .forEach(({ name, value, reactive, wanted }: IAdapterProp) => {\r\n        if (wanted) {\r\n          this.wanted[name] = false;\r\n        }\r\n        this.box[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          set: (newValue: unknown) => {\r\n            if (newValue !== this.box[name]) {\r\n              this.box[name] = newValue;\r\n              this.source[reactive as AdapterPropName].set(newValue);\r\n              // need to emit new value through the configured reactive prop if present\r\n              const reactiveProp = reactivePropsStore[reactive as AdapterPropName];\r\n              if (reactiveProp) {\r\n                reactiveProp.emit(reactiveProp.source, newValue);\r\n              }\r\n            }\r\n          },\r\n          get: () => {\r\n            if (wanted) {\r\n              this.wanted[name] = true;\r\n            }\r\n            return this.box[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props on-demand\r\n    // these scalars should use \"demand\" container\r\n    // setting defaults should be overridden on init()\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && prop.onDemand)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.demand[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          get: () => this.demand[name]\r\n        });\r\n      });\r\n\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    // Adapter public context augmentation\r\n    adapterProps\r\n      .forEach(({ name, type }: IAdapterProp) => {\r\n        let value = (this as IAdapter)[name];\r\n        if (type === AdapterPropType.Function) {\r\n          value = (value as () => void).bind(this);\r\n        } else if (type === AdapterPropType.WorkflowRunner) {\r\n          value = this.getPromisifiedMethod(value as () => void);\r\n        } else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {\r\n          value = context[name];\r\n        }\r\n        Object.defineProperty(context, name, {\r\n          configurable: false,\r\n          get: () => type === AdapterPropType.Scalar\r\n            ? (this as IAdapter)[name] // Scalars should be taken in runtime\r\n            : value // Reactive props and methods (Functions/WorkflowRunners) can be defined once\r\n        });\r\n      });\r\n\r\n    // public context cleanup\r\n    delete context.reactiveConfiguredProps;\r\n  }\r\n\r\n  initialize(buffer: Buffer<Item>, state: State, logger: Logger, adapterRun$?: Reactive<ProcessSubject>): void {\r\n    // buffer\r\n    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {\r\n      get: () => buffer.getVisibleItemsCount()\r\n    });\r\n    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {\r\n      get: (): IBufferInfo => ({\r\n        firstIndex: buffer.firstIndex,\r\n        lastIndex: buffer.lastIndex,\r\n        minIndex: buffer.minIndex,\r\n        maxIndex: buffer.maxIndex,\r\n        absMinIndex: buffer.absMinIndex,\r\n        absMaxIndex: buffer.absMaxIndex,\r\n      })\r\n    });\r\n    this.bof = buffer.bof.get();\r\n    buffer.bof.on(bof => this.bof = bof);\r\n    this.eof = buffer.eof.get();\r\n    buffer.eof.on(eof => this.eof = eof);\r\n\r\n    // state\r\n    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {\r\n      get: () => state.packageInfo\r\n    });\r\n    this.loopPending = state.cycle.innerLoop.busy.get();\r\n    state.cycle.innerLoop.busy.on(busy => this.loopPending = busy);\r\n    this.isLoading = state.cycle.busy.get();\r\n    state.cycle.busy.on(busy => this.isLoading = busy);\r\n\r\n    // logger\r\n    this.logger = logger;\r\n\r\n    // self-pending subscription; set up only on the very first init\r\n    if (adapterRun$) {\r\n      if (!this.relax$) {\r\n        this.relax$ = new Reactive();\r\n      }\r\n      const relax$ = this.relax$;\r\n      adapterRun$.on(({ status, payload }) => {\r\n        let unSubRelax = () => { };\r\n        if (status === ProcessStatus.start) {\r\n          unSubRelax = this.isLoading$.on(value => {\r\n            if (!value) {\r\n              unSubRelax();\r\n              relax$.set({ success: true, immediate: false, details: null });\r\n            }\r\n          });\r\n        }\r\n        if (status === ProcessStatus.done || status === ProcessStatus.error) {\r\n          unSubRelax();\r\n          relax$.set({\r\n            success: status !== ProcessStatus.error,\r\n            immediate: true,\r\n            details: status === ProcessStatus.error && payload ? String(payload.error) : null\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // init\r\n    this.init = true;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.relax$) {\r\n      this.relax$.dispose();\r\n    }\r\n    Object.values(this.source).forEach(reactive => reactive.dispose());\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reset(options?: IDatasourceOptional): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reset', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reset,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reload(options?: number | string): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reload', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reload,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  append(_options: AdapterAppendOptions<Item> | unknown, eof?: boolean): any {\r\n    const options = convertAppendArgs(false, _options, eof); // support old signature\r\n    this.logger.logAdapterMethod('append', [options.items, options.eof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.append,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  prepend(_options: AdapterPrependOptions<Item> | unknown, bof?: boolean): any {\r\n    const options = convertAppendArgs(true, _options, bof); // support old signature\r\n    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.prepend,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  check(): any {\r\n    this.logger.logAdapterMethod('check');\r\n    this.workflow.call({\r\n      process: AdapterProcess.check,\r\n      status: ProcessStatus.start\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  remove(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>): any {\r\n    options = convertRemoveArgs(options); // support old signature\r\n    this.logger.logAdapterMethod('remove', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.remove,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  clip(options?: AdapterClipOptions): any {\r\n    this.logger.logAdapterMethod('clip', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.clip,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  insert(options: AdapterInsertOptions<Item>): any {\r\n    this.logger.logAdapterMethod('insert', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.insert,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  replace(options: AdapterReplaceOptions<Item>): any {\r\n    this.logger.logAdapterMethod('replace', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.replace,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  fix(options: AdapterFixOptions<Item>): any {\r\n    this.logger.logAdapterMethod('fix', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.fix,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  relaxUnchained(callback: (() => void) | undefined, reloadId: string): Promise<AdapterMethodResult> {\r\n    const runCallback = () => typeof callback === 'function' && reloadId === this.reloadId && callback();\r\n    if (!this.isLoading) {\r\n      runCallback();\r\n    }\r\n    return new Promise<boolean>(resolve => {\r\n      if (!this.isLoading) {\r\n        resolve(true);\r\n        return;\r\n      }\r\n      this.isLoading$.once(() => {\r\n        runCallback();\r\n        resolve(false);\r\n      });\r\n    }).then(immediate => {\r\n      const success = reloadId === this.reloadId;\r\n      this.logger.log(() => !success ? `relax promise cancelled due to ${reloadId} != ${this.reloadId}` : void 0);\r\n      return {\r\n        immediate,\r\n        success,\r\n        details: !success ? 'Interrupted by reload or reset' : null\r\n      };\r\n    });\r\n  }\r\n\r\n  relax(callback?: () => void): Promise<AdapterMethodResult> {\r\n    const reloadId = this.reloadId;\r\n    this.logger.logAdapterMethod('relax', callback, ` of ${reloadId}`);\r\n    if (!this.init) {\r\n      return Promise.resolve(adapterMethodPreResult);\r\n    }\r\n    return this.relaxRun = this.relaxRun\r\n      ? this.relaxRun.then(() => this.relaxUnchained(callback, reloadId))\r\n      : this.relaxUnchained(callback, reloadId).then((result) => {\r\n        this.relaxRun = null;\r\n        return result;\r\n      });\r\n  }\r\n\r\n  showLog(): void {\r\n    this.logger.logAdapterMethod('showLog');\r\n    this.logger.logForce();\r\n  }\r\n}\r\n","import { DatasourceGeneric, makeDatasource } from './classes/datasource';\nimport { Settings } from './classes/settings';\nimport { Logger } from './classes/logger';\nimport { Routines } from './classes/domRoutines';\nimport { Viewport } from './classes/viewport';\nimport { Buffer } from './classes/buffer';\nimport { State } from './classes/state';\nimport { Adapter } from './classes/adapter';\nimport { Reactive } from './classes/reactive';\nimport { validate, DATASOURCE } from './inputs/index';\nimport core from './version';\nimport {\n  ScrollerWorkflow, IDatasource, IDatasourceConstructed, ScrollerParams, IPackages, IAdapter, ProcessSubject\n} from './interfaces/index';\n\nexport const INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';\n\nlet instanceCount = 0;\n\nexport class Scroller<ItemData = unknown> {\n  public datasource: IDatasourceConstructed<ItemData>;\n  public workflow: ScrollerWorkflow<ItemData>;\n\n  public settings: Settings;\n  public logger: Logger;\n  public routines: Routines;\n  public viewport: Viewport;\n  public buffer: Buffer<ItemData>;\n  public state: State;\n  public adapter: Adapter<ItemData>;\n\n  constructor({ datasource, consumer, element, workflow, scroller }: ScrollerParams<ItemData>) {\n    const { params: { get } } = validate(datasource, DATASOURCE);\n    if (!get.isValid) {\n      throw new Error(`${INVALID_DATASOURCE_PREFIX} ${get.errors[0]}`);\n    }\n\n    const packageInfo = scroller ? scroller.state.packageInfo : ({ consumer, core } as IPackages);\n    element = scroller ? scroller.viewport.element : (element as HTMLElement);\n    workflow = scroller ? scroller.workflow : (workflow as ScrollerWorkflow<ItemData>);\n\n    this.workflow = workflow;\n    this.settings = new Settings(datasource.settings, datasource.devSettings, ++instanceCount);\n    this.logger = new Logger(this as Scroller, packageInfo);\n    this.routines = new Routines(this.settings);\n    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);\n    this.buffer = new Buffer<ItemData>(this.settings, workflow.onDataChanged, this.logger);\n    this.viewport = new Viewport(element, this.settings, this.routines, this.state, this.logger);\n    this.logger.object('uiScroll settings object', this.settings, true);\n\n    this.initDatasource(datasource, scroller);\n  }\n\n  initDatasource(datasource: IDatasource<ItemData>, scroller?: Scroller<ItemData>): void {\n    if (scroller) { // scroller re-instantiating case\n      this.datasource = datasource as IDatasourceConstructed<ItemData>;\n      this.adapter = scroller.adapter;\n      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?\n      return;\n    }\n    // scroller is being instantiated for the first time\n    const constructed = datasource instanceof DatasourceGeneric;\n    const mockAdapter = !constructed && !this.settings.adapter;\n    if (constructed) { // datasource is already instantiated\n      this.datasource = datasource as IDatasourceConstructed<ItemData>;\n    } else { // datasource as POJO\n      const DS = makeDatasource<IAdapter>(() => ({ mock: mockAdapter }));\n      this.datasource = new DS(datasource);\n      if (this.settings.adapter) {\n        datasource.adapter = this.datasource.adapter;\n      }\n    }\n    const publicContext = !mockAdapter ? this.datasource.adapter : null;\n    this.adapter = new Adapter<ItemData>(publicContext, () => this.workflow, this.logger);\n  }\n\n  init(adapterRun$?: Reactive<ProcessSubject>): void {\n    this.viewport.reset(this.buffer.startIndex);\n    this.logger.stat('initialization');\n    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) { // Adapter is not re-instantiated on reset\n      this.adapter.dispose();\n    }\n    this.buffer.dispose();\n    this.state.dispose();\n  }\n\n  finalize(): void {\n  }\n\n}\n","import { Scroller } from './scroller';\nimport { runStateMachine } from './workflow-transducer';\nimport { Reactive } from './classes/reactive';\nimport { Item } from './classes/item';\nimport { CommonProcess, ProcessStatus as Status, } from './processes/index';\nimport {\n  WorkflowParams,\n  ProcessName,\n  ProcessPayload,\n  ProcessClass,\n  ProcessSubject,\n  WorkflowError,\n  InterruptParams,\n  StateMachineMethods,\n  ScrollerWorkflow,\n} from './interfaces/index';\n\nexport class Workflow<ItemData = unknown> {\n\n  isInitialized: boolean;\n  initTimer: ReturnType<typeof setTimeout> | null;\n  adapterRun$: Reactive<ProcessSubject>;\n  cyclesDone: number;\n  interruptionCount: number;\n  errors: WorkflowError[];\n\n  private disposeScrollEventHandler: () => void;\n  readonly propagateChanges: WorkflowParams<ItemData>['run'];\n  readonly stateMachineMethods: StateMachineMethods<ItemData>;\n\n  scroller: Scroller<ItemData>;\n\n  constructor({ element, datasource, consumer, run }: WorkflowParams<ItemData>) {\n    this.isInitialized = false;\n    this.initTimer = null;\n    this.adapterRun$ = new Reactive();\n    this.cyclesDone = 0;\n    this.interruptionCount = 0;\n    this.errors = [];\n    this.disposeScrollEventHandler = () => null;\n    this.propagateChanges = run;\n    this.stateMachineMethods = {\n      run: this.runProcess(),\n      interrupt: this.interrupt.bind(this),\n      done: this.done.bind(this),\n      onError: this.onError.bind(this)\n    };\n\n    this.scroller = new Scroller<ItemData>({ element, datasource, consumer, workflow: this.getUpdater() });\n\n    if (this.scroller.settings.initializeDelay) {\n      this.initTimer = setTimeout(() => {\n        this.initTimer = null;\n        this.init();\n      }, this.scroller.settings.initializeDelay);\n    } else {\n      this.init();\n    }\n  }\n\n  init(): void {\n    this.scroller.init(this.adapterRun$);\n    this.isInitialized = true;\n\n    // run the Workflow\n    this.callWorkflow({\n      process: CommonProcess.init,\n      status: Status.start\n    });\n\n    // set up scroll event listener\n    const { scrollEventReceiver } = this.scroller.viewport;\n    const onScrollHandler: EventListener =\n      event => this.callWorkflow({\n        process: CommonProcess.scroll,\n        status: Status.start,\n        payload: { event }\n      });\n    scrollEventReceiver.addEventListener('scroll', onScrollHandler);\n    this.disposeScrollEventHandler = () =>\n      scrollEventReceiver.removeEventListener('scroll', onScrollHandler);\n  }\n\n  changeItems(items: Item<ItemData>[]): void {\n    this.propagateChanges(items);\n  }\n\n  callWorkflow(processSubject: ProcessSubject): void {\n    if (!this.isInitialized) {\n      return;\n    }\n    if (processSubject.process && processSubject.process.startsWith('adapter')) {\n      this.adapterRun$.set(processSubject);\n    }\n    this.process(processSubject);\n  }\n\n  getUpdater(): ScrollerWorkflow<ItemData> {\n    return {\n      call: this.callWorkflow.bind(this),\n      onDataChanged: this.changeItems.bind(this),\n    };\n  }\n\n  process(data: ProcessSubject): void {\n    const { status, process, payload } = data;\n    if (this.scroller.settings.logProcessRun) {\n      this.scroller.logger.log(() => [\n        '%cfire%c', ...['color: #cc7777;', 'color: #000000;'],\n        process, `\"${status}\"`, ...(payload !== void 0 ? [payload] : [])\n      ]);\n    }\n    this.scroller.logger.logProcess(data);\n\n    if (process === CommonProcess.end) {\n      this.scroller.finalize();\n    }\n    runStateMachine({\n      input: data,\n      methods: this.stateMachineMethods as StateMachineMethods<unknown>\n    });\n  }\n\n  runProcess() {\n    return ({ run, process, name }: ProcessClass) =>\n      (...args: any[]): void => {\n        if (this.scroller.settings.logProcessRun) {\n          this.scroller.logger.log(() => [\n            '%crun%c', ...['color: #333399;', 'color: #000000;'],\n            process || name, ...args\n          ]);\n        }\n        run(this.scroller as Scroller, ...args);\n      };\n  }\n\n  onError(process: ProcessName, payload?: ProcessPayload): void {\n    const message: string = payload && String(payload.error) || '';\n    const { time, cycle } = this.scroller.state;\n    this.errors.push({\n      process,\n      message,\n      time,\n      loop: cycle.loopIdNext\n    });\n    this.scroller.logger.logError(message);\n  }\n\n  interrupt({ process, finalize, datasource }: InterruptParams<ItemData>): void {\n    if (finalize) {\n      const { workflow, logger } = this.scroller;\n      // we are going to create a new reference for the scroller.workflow object\n      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped\n      workflow.call = (p: ProcessSubject) => // eslint-disable-line @typescript-eslint/no-unused-vars\n        logger.log('[skip wf call]');\n      workflow.call.interrupted = true;\n      this.scroller.workflow = this.getUpdater();\n      this.interruptionCount++;\n      logger.log(() => `workflow had been interrupted by the ${process} process (${this.interruptionCount})`);\n    }\n    if (datasource) { // Scroller re-initialization case\n      this.scroller.adapter.relax(() => {\n        this.scroller.logger.log('new Scroller instantiation');\n        const scroller = new Scroller<ItemData>({ datasource, scroller: this.scroller });\n        this.scroller.dispose();\n        this.scroller = scroller;\n        this.scroller.init();\n      });\n    }\n  }\n\n  done(): void {\n    const { state, logger } = this.scroller;\n    this.cyclesDone++;\n    logger.logCycle(false);\n    state.cycle.done(this.cyclesDone + 1);\n    this.finalize();\n  }\n\n  dispose(): void {\n    if (this.initTimer) {\n      clearTimeout(this.initTimer);\n    }\n    this.disposeScrollEventHandler();\n    this.adapterRun$.dispose();\n    this.scroller.dispose(true);\n    this.isInitialized = false;\n  }\n\n  finalize(): void {\n  }\n\n}\n","import {\n  CommonProcess,\n  AdapterProcess,\n  ProcessStatus as Status,\n  Init,\n  Scroll,\n  Reset,\n  Reload,\n  Append,\n  Check,\n  Remove,\n  UserClip,\n  Insert,\n  Replace,\n  Fix,\n  Start,\n  PreFetch,\n  Fetch,\n  PostFetch,\n  Render,\n  PreClip,\n  Clip,\n  Adjust,\n  End,\n} from './processes/index';\n\nimport { StateMachineParams } from './interfaces/index';\n\nexport const runStateMachine = ({\n  input: { process, status, payload = {} },\n  methods: { run, interrupt, done, onError }\n}: StateMachineParams): void => {\n  if (status === Status.error) {\n    onError(process, payload);\n    if (!process.startsWith('adapter')) {\n      run(End)(payload);\n    }\n    return;\n  }\n  const { options } = payload;\n  switch (process) {\n    case CommonProcess.init:\n      if (status === Status.start) { // App start\n        run(Init)(process);\n      }\n      if (status === Status.next) {\n        run(Start)();\n      }\n      break;\n    case CommonProcess.scroll:\n      if (status === Status.start) {\n        run(Scroll)(payload);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.reset:\n    case AdapterProcess.reload:\n      if (status === Status.start) {\n        if (process === AdapterProcess.reset) {\n          run(Reset)(options);\n        } else {\n          run(Reload)(options);\n        }\n      }\n      if (status === Status.next) {\n        interrupt({ process, ...payload });\n        if (payload.finalize) {\n          run(End)();\n        } else {\n          run(Init)(process);\n        }\n      }\n      break;\n    case AdapterProcess.append:\n    case AdapterProcess.prepend:\n      if (status === Status.start) {\n        run(Append)({ process, options });\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.check:\n      if (status === Status.start) {\n        run(Check)();\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.remove:\n      if (status === Status.start) {\n        run(Remove)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.clip:\n      if (status === Status.start) {\n        run(UserClip)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.insert:\n      if (status === Status.start) {\n        run(Insert)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.replace:\n      if (status === Status.start) {\n        run(Replace)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.fix:\n      if (status === Status.start) {\n        run(Fix)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case CommonProcess.start:\n      switch (payload.process) {\n        case AdapterProcess.append:\n        case AdapterProcess.check:\n        case AdapterProcess.insert:\n        case AdapterProcess.replace:\n          run(Render)();\n          break;\n        case AdapterProcess.remove:\n          run(Clip)();\n          break;\n        default:\n          run(PreFetch)();\n      }\n      break;\n    case CommonProcess.preFetch:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.clip:\n            run(PreClip)();\n            break;\n          default:\n            run(Fetch)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.fetch:\n      run(PostFetch)();\n      break;\n    case CommonProcess.postFetch:\n      if (status === Status.next) {\n        run(Render)();\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.render:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.append:\n          case AdapterProcess.check:\n          case AdapterProcess.insert:\n          case AdapterProcess.remove:\n            run(Adjust)();\n            break;\n          case AdapterProcess.replace:\n            run(Clip)();\n            break;\n          default:\n            run(PreClip)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.preClip:\n      if (payload.doClip) {\n        run(Clip)();\n      } else {\n        run(Adjust)();\n      }\n      break;\n    case CommonProcess.clip:\n      switch (payload.process) {\n        case AdapterProcess.remove:\n          run(End)();\n          break;\n        default:\n          run(Adjust)();\n      }\n      break;\n    case CommonProcess.adjust:\n      run(End)();\n      break;\n    case CommonProcess.end:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.reset:\n          case AdapterProcess.reload:\n            done();\n            run(Init)(payload.process);\n            break;\n          default:\n            run(Start)();\n        }\n      }\n      if (status === Status.done) {\n        done();\n      }\n      break;\n  }\n};\n"],"sourceRoot":""}