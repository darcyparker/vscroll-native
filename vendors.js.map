{"version":3,"file":"vendors.js","mappings":"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","sources":["webpack://vscroll-native/./node_modules/tslib/tslib.es6.js","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/props.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/reactive.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/common.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/validation.ts","webpack://vscroll-native/./node_modules/vscroll/src/version.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter/context.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/datasource.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/enums.ts","webpack://vscroll-native/./node_modules/vscroll/src/inputs/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/settings.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/misc/base.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/init.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reset.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/reload.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/item.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/append.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/check.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/remove.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/update.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/insert.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/replace.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adapter/fix.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/start.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/postFetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/adjust.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/preClip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/processes/end.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/logger.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/domRoutines.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/paddings.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/viewport.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer/defaultSize.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer/cache.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/buffer.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/cycle.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/fetch.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/clip.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/render.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state/scroll.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/state.ts","webpack://vscroll-native/./node_modules/vscroll/src/classes/adapter.ts","webpack://vscroll-native/./node_modules/vscroll/src/scroller.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow.ts","webpack://vscroll-native/./node_modules/vscroll/src/workflow-transducer.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { Reactive } from '../reactive';\nimport {\n  IAdapterProp, IBufferInfo, ItemAdapter, IPackages, AdapterMethodResult, IReactivePropsStore\n} from '../../interfaces/index';\n\nexport enum AdapterPropName {\n  id = 'id',\n  mock = 'mock',\n  augmented = 'augmented',\n  version = 'version',\n  init = 'init',\n  init$ = 'init$',\n  packageInfo = 'packageInfo',\n  itemsCount = 'itemsCount',\n  bufferInfo = 'bufferInfo',\n  isLoading = 'isLoading',\n  isLoading$ = 'isLoading$',\n  loopPending = 'loopPending',\n  loopPending$ = 'loopPending$',\n  firstVisible = 'firstVisible',\n  firstVisible$ = 'firstVisible$',\n  lastVisible = 'lastVisible',\n  lastVisible$ = 'lastVisible$',\n  bof = 'bof',\n  bof$ = 'bof$',\n  eof = 'eof',\n  eof$ = 'eof$',\n  reset = 'reset',\n  reload = 'reload',\n  append = 'append',\n  prepend = 'prepend',\n  check = 'check',\n  remove = 'remove',\n  clip = 'clip',\n  insert = 'insert',\n  replace = 'replace',\n  update = 'update',\n  fix = 'fix',\n  relax = 'relax',\n  showLog = 'showLog',\n}\n\nexport enum AdapterPropType {\n  Scalar,\n  Reactive,\n  WorkflowRunner,\n  Function,\n}\n\nconst Name = AdapterPropName;\nconst Type = AdapterPropType;\n\nconst noop = () => null;\n\nexport const methodPreResult: AdapterMethodResult = {\n  immediate: true,\n  success: true,\n  details: 'Adapter is not initialized'\n};\n\nconst noopWF = () => Promise.resolve(methodPreResult);\n\nconst emptyPackageInfo: IPackages = {\n  core: {\n    name: '',\n    version: ''\n  },\n  consumer: {\n    name: '',\n    version: ''\n  }\n};\n\nconst bufferInfoDefault: IBufferInfo = {\n  firstIndex: NaN,\n  lastIndex: NaN,\n  minIndex: NaN,\n  maxIndex: NaN,\n  absMinIndex: -Infinity,\n  absMaxIndex: +Infinity,\n  defaultSize: NaN,\n};\n\nexport const EMPTY_ITEM = {\n  data: {},\n  element: {}\n} as ItemAdapter;\n\nexport const getDefaultAdapterProps = (): IAdapterProp[] => [\n  {\n    type: Type.Scalar,\n    name: Name.id,\n    value: 0,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.mock,\n    value: true,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.augmented,\n    value: false,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.version,\n    value: '',\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.init,\n    value: false,\n    reactive: Name.init$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.packageInfo,\n    value: emptyPackageInfo,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.itemsCount,\n    value: 0,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bufferInfo,\n    value: bufferInfoDefault,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.isLoading,\n    value: false,\n    reactive: Name.isLoading$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.loopPending,\n    value: false,\n    reactive: Name.loopPending$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.firstVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.firstVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.lastVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.lastVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bof,\n    value: false,\n    reactive: Name.bof$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.eof,\n    value: false,\n    reactive: Name.eof$\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reset,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reload,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.append,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.prepend,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.check,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.remove,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.clip,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.insert,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.replace,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.update,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.fix,\n    value: noopWF\n  },\n  {\n    type: Type.Function,\n    name: Name.relax,\n    value: noop\n  },\n  {\n    type: Type.Function,\n    name: Name.showLog,\n    value: noop\n  },\n  {\n    type: Type.Reactive,\n    name: Name.init$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.isLoading$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.loopPending$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.firstVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.lastVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.bof$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.eof$,\n    value: new Reactive<boolean>()\n  }\n];\n\nexport const reactiveConfigStorage = new Map<number, IReactivePropsStore>();\n","type On<T> = (value: T) => void;\ntype Off = () => void;\n\ninterface Subscription<T> {\n  emit: On<T>;\n  off: Off;\n}\n\ninterface Options {\n  emitOnSubscribe?: boolean; // if set, emit right on subscribe (like rxjs BehaviorSubject)\n  emitEqual?: boolean; // if set, emit when new value is equal to the old one\n}\n\nexport class Reactive<T> {\n\n  private initialValue: T;\n  private value: T;\n  private id: number;\n  private options: Options;\n  private subscriptions: Map<number, Subscription<T>>;\n\n  constructor(value?: T, options?: Options) {\n    this.id = 0;\n    if (value !== void 0) {\n      this.value = value;\n      this.initialValue = value;\n    }\n    this.options = options || {};\n    this.subscriptions = new Map();\n  }\n\n  set(value: T): void {\n    if (this.value === value && !this.options.emitEqual) {\n      return;\n    }\n    this.value = value;\n    for (const [, sub] of this.subscriptions) {\n      sub.emit(value);\n      if (this.value !== value) {\n        break;\n      }\n    }\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  on(func: On<T>): Off {\n    const id = this.id++;\n    const subscription: Subscription<T> = {\n      emit: func,\n      off: () => {\n        subscription.emit = () => null;\n        this.subscriptions.delete(id);\n      }\n    };\n    this.subscriptions.set(id, subscription);\n    if (this.options.emitOnSubscribe) {\n      subscription.emit(this.value);\n    }\n    return () => subscription.off();\n  }\n\n  once(func: On<T>): Off {\n    const off = this.on(v => {\n      off();\n      func(v);\n    });\n    return off;\n  }\n\n  reset(): void {\n    this.set(this.initialValue);\n  }\n\n  dispose(): void {\n    this.subscriptions.forEach(sub => sub.off());\n  }\n}\n","export enum Direction {\n  forward = 'forward',\n  backward = 'backward'\n}\n\nexport enum SizeStrategy {\n  Average = 'average',\n  Constant = 'constant',\n  Frequent = 'frequent'\n}\n","import { IValidationContext } from '../interfaces/validation';\nimport {\n  IValidator,\n  ValidatedValue,\n  IValidatedData,\n  IValidatedCommonProps,\n  ICommonProps,\n  ICommonProp,\n} from '../interfaces/index';\n\nexport enum ValidatorType {\n  number = 'must be a number',\n  integer = 'must be an integer',\n  integerUnlimited = 'must be an integer or infinity',\n  moreOrEqual = 'must be a number greater than (or equal to) {arg1}',\n  itemList = 'must be an array of items {arg1}',\n  boolean = 'must be a boolean',\n  object = 'must be an object',\n  element = 'must be an html element',\n  function = 'must be a function',\n  funcOfxArguments = 'must have {arg1} argument(s)',\n  funcOfxAndMoreArguments = 'must have at least {arg1} argument(s)',\n  funcOfXToYArguments = 'must have {arg1} to {arg2} arguments',\n  oneOfCan = 'can be present as only one item of {arg1} list',\n  oneOfMust = 'must be present as only one item of {arg1} list',\n  or = 'must satisfy at least 1 validator from {arg1} list',\n  enum = 'must belong to {arg1} list',\n}\n\nconst getError = (msg: ValidatorType, args?: string[]) =>\n  (args || ['']).reduce((acc, arg, index) => acc.replace(`{arg${index + 1}}`, arg), msg);\n\nconst getNumber = (value: unknown): number =>\n  typeof value === 'number' || (typeof value === 'string' && value !== '')\n    ? Number(value)\n    : NaN;\n\nconst onNumber = (value: unknown): ValidatedValue => {\n  const parsedValue = getNumber(value);\n  const errors = [];\n  if (Number.isNaN(parsedValue)) {\n    errors.push(ValidatorType.number);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onInteger = (value: unknown): ValidatedValue => {\n  const errors = [];\n  value = getNumber(value);\n  const parsedValue = parseInt(String(value), 10);\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integer);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onIntegerUnlimited = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  value = getNumber(value);\n  if (!Number.isFinite(value)) {\n    parsedValue = value;\n  } else {\n    parsedValue = parseInt(String(value), 10);\n  }\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integerUnlimited);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onMoreOrEqual = (limit: number, fallback?: boolean) => (value: unknown): ValidatedValue => {\n  const result = onNumber(value);\n  if (!result.isValid) {\n    return result;\n  }\n  let parsedValue = result.value as number;\n  const errors = [];\n  if (parsedValue < limit) {\n    if (!fallback) {\n      errors.push(getError(ValidatorType.moreOrEqual, [String(limit)]));\n    } else {\n      parsedValue = limit;\n    }\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onBoolean = (value: unknown): ValidatedValue => {\n  const errors = [];\n  let parsedValue = value;\n  if (value === 'true') {\n    parsedValue = true;\n  } else if (value === 'false') {\n    parsedValue = false;\n  }\n  if (typeof parsedValue !== 'boolean') {\n    errors.push(ValidatorType.boolean);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onObject = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    errors.push(ValidatorType.object);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onHtmlElement = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {\n    errors.push(ValidatorType.element);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onItemList = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  if (!Array.isArray(value)) {\n    errors.push(ValidatorType.itemList);\n    parsedValue = [];\n  } else if (!value.length) {\n    errors.push(getError(ValidatorType.itemList, ['with at least 1 item']));\n  } else if (value.length > 1) {\n    const type = typeof value[0];\n    if (value.some((v: unknown) => typeof v !== type)) {\n      errors.push(getError(ValidatorType.itemList, ['of items of the same type']));\n    }\n  }\n  return { value: parsedValue as unknown[], isSet: true, isValid: !errors.length, errors };\n};\n\ntype Func = (...args: any[]) => void;\n\nconst onFunction = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (typeof value !== 'function') {\n    errors.push(ValidatorType.function);\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXArguments = (argsCount: number) => (value: unknown) => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length !== argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXAndMoreArguments = (argsCount: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXToYArguments = (from: number, to: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < from || (value as Func).length > to) {\n    errors.push(getError(ValidatorType.funcOfXToYArguments, [String(from), String(to)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onOneOf = (tokens: string[], must: boolean) => (value: unknown, context?: IValidationContext): ValidatedValue => {\n  const errors = [];\n  const isSet = value !== void 0;\n  let noOneIsPresent = !isSet;\n  const err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;\n  if (!Array.isArray(tokens) || !tokens.length) {\n    errors.push(getError(err, ['undefined']));\n  } else {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ' (non-string token)');\n        break;\n      }\n      const isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);\n      if (isSet && isAnotherPresent) {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ` (${token} is present)`);\n        break;\n      }\n      if (noOneIsPresent && isAnotherPresent) {\n        noOneIsPresent = false;\n      }\n    }\n    if (must && noOneIsPresent) {\n      errors.push(getError(err, [tokens.join('\", \"')]));\n    }\n  }\n  return { value, isSet, isValid: !errors.length, errors };\n};\n\nconst onOr = (validators: IValidator[]) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (validators.every(validator => !validator.method(value).isValid)) {\n    errors.push(validators.map(v => v.type).join(' OR '));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nenum AbstractEnum { }\ntype TEnum = typeof AbstractEnum;\n\nconst onEnum = (list: TEnum) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  const values = Object.keys(list).filter(k => isNaN(Number(k))).map(k => list[k as unknown as number]);\n  if (!values.some(item => item === value)) {\n    errors.push(getError(ValidatorType.enum, ['[' + values.join(',') + ']']));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nexport const VALIDATORS = {\n  NUMBER: {\n    type: ValidatorType.number,\n    method: onNumber\n  },\n  INTEGER: {\n    type: ValidatorType.integer,\n    method: onInteger\n  },\n  INTEGER_UNLIMITED: {\n    type: ValidatorType.integerUnlimited,\n    method: onIntegerUnlimited\n  },\n  MORE_OR_EQUAL: (limit: number, fallback?: boolean): IValidator => ({\n    type: ValidatorType.moreOrEqual,\n    method: onMoreOrEqual(limit, fallback)\n  }),\n  BOOLEAN: {\n    type: ValidatorType.boolean,\n    method: onBoolean\n  },\n  OBJECT: {\n    type: ValidatorType.object,\n    method: onObject\n  },\n  ITEM_LIST: {\n    type: ValidatorType.itemList,\n    method: onItemList\n  },\n  ELEMENT: {\n    type: ValidatorType.element,\n    method: onHtmlElement\n  },\n  FUNC: {\n    type: ValidatorType.function,\n    method: onFunction\n  },\n  FUNC_WITH_X_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxArguments,\n    method: onFunctionWithXArguments(count)\n  }),\n  FUNC_WITH_X_AND_MORE_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxAndMoreArguments,\n    method: onFunctionWithXAndMoreArguments(count)\n  }),\n  FUNC_WITH_X_TO_Y_ARGUMENTS: (from: number, to: number): IValidator => ({\n    type: ValidatorType.funcOfXToYArguments,\n    method: onFunctionWithXToYArguments(from, to)\n  }),\n  ONE_OF_CAN: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfCan,\n    method: onOneOf(list, false)\n  }),\n  ONE_OF_MUST: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfMust,\n    method: onOneOf(list, true)\n  }),\n  OR: (list: IValidator[]): IValidator => ({\n    type: ValidatorType.or,\n    method: onOr(list)\n  }),\n  ENUM: (list: TEnum): IValidator => ({\n    type: ValidatorType.enum,\n    method: onEnum(list)\n  })\n};\n\nexport class ValidatedData implements IValidatedData {\n\n  context: IValidationContext;\n  isValidContext: boolean;\n  isValid: boolean;\n  errors: string[];\n  params: IValidatedCommonProps<PropertyKey>;\n\n  private contextErrors: string[];\n\n  constructor(context: unknown) {\n    this.params = {};\n    this.contextErrors = [];\n    this.errors = [];\n    this.isValid = true;\n    this.setContext(context);\n  }\n\n  private setContext(context: unknown): void {\n    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {\n      this.setCommonError('context is not an object');\n      this.isValidContext = false;\n    } else {\n      this.isValidContext = true;\n    }\n    this.context = context as IValidationContext;\n  }\n\n  private setValidity() {\n    this.errors = Object.keys(this.params).reduce((acc: string[], key: string) => [\n      ...acc, ...this.params[key].errors\n    ], []);\n    this.isValid = !this.errors.length;\n  }\n\n  setCommonError(error: string): void {\n    this.contextErrors.push(error);\n    this.errors.push(error);\n    this.isValid = false;\n  }\n\n  setParam(token: string, value: ValidatedValue): void {\n    if (!value.isValid) {\n      value.errors = !value.isSet\n        ? [`\"${token}\" must be set`]\n        : value.errors.map((err: string) =>\n          `\"${token}\" ${err}`\n        );\n    }\n    this.params[token] = value;\n    this.setValidity();\n  }\n\n  showErrors(): string {\n    return this.errors.length\n      ? 'validation failed: ' + this.errors.join(', ')\n      : '';\n  }\n}\n\nexport const runValidator = (\n  current: ValidatedValue,\n  validator: IValidator,\n  context: IValidationContext\n): ValidatedValue => {\n  const { value, errors } = current;\n  const result = validator.method(value, context);\n  const _errors = [...errors, ...result.errors];\n  return {\n    value: result.value,\n    isSet: result.isSet,\n    isValid: !_errors.length,\n    errors: _errors\n  };\n};\n\nconst getDefault = (value: unknown, prop: ICommonProp): ValidatedValue => {\n  const empty = value === void 0;\n  const auto = !prop.mandatory && prop.defaultValue !== void 0;\n  return {\n    value: !empty ? value : (auto ? prop.defaultValue : void 0),\n    isSet: !empty || auto,\n    isValid: !empty || !prop.mandatory,\n    errors: []\n  };\n};\n\nexport const validateOne = (\n  context: IValidationContext, name: string, prop: ICommonProp\n): ValidatedValue => {\n  const result = getDefault(context[name], prop);\n  if (!result.isSet) {\n    const oneOfMust = prop.validators.find(v => v.type === ValidatorType.oneOfMust);\n    if (oneOfMust) {\n      return runValidator(result, oneOfMust, context);\n    }\n  } else {\n    for (const validator of Object.values(prop.validators)) {\n      const current = runValidator(result, validator, context);\n      if (!current.isValid && prop.defaultValue !== void 0) {\n        return {\n          value: prop.defaultValue,\n          isSet: true,\n          isValid: true,\n          errors: []\n        };\n      }\n      Object.assign(result, current);\n    }\n  }\n  return result;\n};\n\nexport const validate = (\n  context: unknown, params: ICommonProps<PropertyKey>\n): IValidatedData => {\n  const data = new ValidatedData(context);\n  Object.entries(params).forEach(([key, prop]) =>\n    data.setParam(key, data.isValidContext\n      ? validateOne(data.context, key, prop)\n      : getDefault(void 0, prop)\n    )\n  );\n  return data;\n};\n","export default {\n  name: 'vscroll',\n  version: '1.2.0'\n};\n","import { AdapterPropName, AdapterPropType, getDefaultAdapterProps, reactiveConfigStorage } from './props';\nimport core from '../../version';\nimport { Reactive } from '../reactive';\nimport { IReactivePropsStore, IAdapterConfig } from '../../interfaces/index';\n\nlet instanceCount = 0;\n\nexport class AdapterContext {\n\n  constructor(config: IAdapterConfig) {\n    const { mock, reactive } = config;\n    const id = ++instanceCount;\n    const conf = { configurable: true };\n    const reactivePropsStore: IReactivePropsStore = {};\n\n    // set up permanent props\n    Object.defineProperty(this, AdapterPropName.id, { get: () => id, ...conf });\n    Object.defineProperty(this, AdapterPropName.mock, { get: () => mock, ...conf });\n    Object.defineProperty(this, AdapterPropName.augmented, { get: () => false, ...conf });\n    Object.defineProperty(this, AdapterPropName.version, { get: () => core.version, ...conf });\n\n    // set up default props, they will be reassigned during the Adapter instantiation\n    getDefaultAdapterProps()\n      .filter(({ permanent }) => !permanent)\n      .forEach(({ name, value, type }) => {\n\n        // reactive props might be reconfigured by the vscroll consumer\n        if (reactive && type === AdapterPropType.Reactive) {\n          const react = reactive[name];\n          if (react) {\n            // here we have a configured reactive property that came from the outer config\n            // this prop must be exposed via Adapter, but at the same time we need to\n            // persist the original default value as it will be used by the Adapter internally\n            reactivePropsStore[name] = {\n              ...react,\n              default: value as Reactive<unknown> // persisting the default native Reactive prop\n            };\n            value = react.source; // exposing the configured prop instead of the default one\n          }\n        }\n\n        Object.defineProperty(this, name, {\n          get: () => value,\n          ...conf\n        });\n      });\n\n    if (reactive) { // save both configured and default reactive props in the store\n      reactiveConfigStorage.set(id, reactivePropsStore);\n    }\n  }\n}\n","import { AdapterContext } from './adapter/context';\r\nimport { reactiveConfigStorage } from './adapter/props';\r\nimport {\r\n  IDatasource,\r\n  IDatasourceConstructed,\r\n  DatasourceGet,\r\n  Settings,\r\n  DevSettings,\r\n  IAdapter,\r\n  IAdapterConfig,\r\n} from '../interfaces/index';\r\n\r\nexport class DatasourceGeneric<Data> implements IDatasourceConstructed<Data> {\r\n  get: DatasourceGet<Data>;\r\n  settings?: Settings<Data>;\r\n  devSettings?: DevSettings;\r\n  adapter: IAdapter<Data>;\r\n\r\n  constructor(datasource: IDatasource<Data>, config?: IAdapterConfig) {\r\n    this.get = datasource.get;\r\n    if (datasource.settings) {\r\n      this.settings = datasource.settings;\r\n    }\r\n    if (datasource.devSettings) {\r\n      this.devSettings = datasource.devSettings;\r\n    }\r\n    const adapterContext = new AdapterContext(config || { mock: false });\r\n    this.adapter = adapterContext as IAdapter<Data>;\r\n  }\r\n\r\n  dispose(): void { // todo: should it be published?\r\n    reactiveConfigStorage.delete(this.adapter.id);\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport const makeDatasource = (getConfig?: () => IAdapterConfig) =>\r\n  class <Data = unknown> extends DatasourceGeneric<Data> {\r\n    constructor(datasource: IDatasource<Data>) {\r\n      const config = typeof getConfig === 'function' ? getConfig() : void 0;\r\n      super(datasource, config);\r\n    }\r\n  };\r\n\r\nexport const Datasource = makeDatasource();\r\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\n\nconst { OBJECT, FUNC_WITH_X_AND_MORE_ARGUMENTS } = VALIDATORS;\n\nexport enum DatasourceProps {\n  get = 'get',\n  settings = 'settings',\n  devSettings = 'devSettings',\n}\n\nexport const DATASOURCE: ICommonProps<DatasourceProps> = {\n  [DatasourceProps.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)],\n    mandatory: true\n  },\n  [DatasourceProps.settings]: {\n    validators: [OBJECT]\n  },\n  [DatasourceProps.devSettings]: {\n    validators: [OBJECT]\n  }\n};\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\nimport { SizeStrategy } from './common';\n\nconst { NUMBER, INTEGER, INTEGER_UNLIMITED, MORE_OR_EQUAL, BOOLEAN, ELEMENT, FUNC, OR, ENUM } = VALIDATORS;\n\nenum Settings {\n  adapter = 'adapter',\n  startIndex = 'startIndex',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  itemSize = 'itemSize',\n  bufferSize = 'bufferSize',\n  padding = 'padding',\n  infinite = 'infinite',\n  horizontal = 'horizontal',\n  windowViewport = 'windowViewport',\n  viewportElement = 'viewportElement',\n  inverse = 'inverse',\n  onBeforeClip = 'onBeforeClip',\n  sizeStrategy = 'sizeStrategy',\n}\n\nenum DevSettings {\n  debug = 'debug',\n  immediateLog = 'immediateLog',\n  logProcessRun = 'logProcessRun',\n  logTime = 'logTime',\n  throttle = 'throttle',\n  initDelay = 'initDelay',\n  initWindowDelay = 'initWindowDelay',\n  cacheData = 'cacheData',\n  cacheOnReload = 'cacheOnReload',\n  changeOverflow = 'changeOverflow',\n  dismissOverflowAnchor = 'dismissOverflowAnchor',\n}\n\nexport const MIN = {\n  [Settings.itemSize]: 1,\n  [Settings.bufferSize]: 1,\n  [Settings.padding]: 0.01,\n  [DevSettings.throttle]: 0,\n  [DevSettings.initDelay]: 0,\n  [DevSettings.initWindowDelay]: 0,\n};\n\nexport const SETTINGS: ICommonProps<Settings> = {\n  [Settings.adapter]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.startIndex]: {\n    validators: [INTEGER],\n    defaultValue: 1\n  },\n  [Settings.minIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: -Infinity\n  },\n  [Settings.maxIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: Infinity\n  },\n  [Settings.itemSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.itemSize], true)],\n    defaultValue: NaN\n  },\n  [Settings.bufferSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.bufferSize], true)],\n    defaultValue: 5\n  },\n  [Settings.padding]: {\n    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings.padding], true)],\n    defaultValue: 0.5\n  },\n  [Settings.infinite]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.horizontal]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.windowViewport]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.viewportElement]: {\n    validators: [OR([ELEMENT, FUNC])],\n    defaultValue: null\n  },\n  [Settings.inverse]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.onBeforeClip]: {\n    validators: [FUNC],\n    defaultValue: null\n  },\n  [Settings.sizeStrategy]: {\n    validators: [ENUM(SizeStrategy)],\n    defaultValue: SizeStrategy.Average\n  },\n};\n\nexport const DEV_SETTINGS: ICommonProps<DevSettings> = {\n  [DevSettings.debug]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.immediateLog]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n  [DevSettings.logProcessRun]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.logTime]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.throttle]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],\n    defaultValue: 40\n  },\n  [DevSettings.initDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],\n    defaultValue: 1\n  },\n  [DevSettings.initWindowDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],\n    defaultValue: 40\n  },\n  [DevSettings.cacheData]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.cacheOnReload]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.changeOverflow]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.dismissOverflowAnchor]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n};\n","export enum CommonProcess {\n  init = 'init',\n  scroll = 'scroll',\n  start = 'start',\n  preFetch = 'preFetch',\n  fetch = 'fetch',\n  postFetch = 'postFetch',\n  render = 'render',\n  preClip = 'preClip',\n  clip = 'clip',\n  adjust = 'adjust',\n  end = 'end',\n}\n\nexport enum AdapterProcess {\n  reset = 'adapter.reset',\n  reload = 'adapter.reload',\n  append = 'adapter.append',\n  prepend = 'adapter.prepend',\n  check = 'adapter.check',\n  remove = 'adapter.remove',\n  replace = 'adapter.replace',\n  update = 'adapter.update',\n  clip = 'adapter.clip',\n  insert = 'adapter.insert',\n  fix = 'adapter.fix',\n}\n\nexport enum ProcessStatus {\n  start = 'start',\n  next = 'next',\n  done = 'done',\n  error = 'error'\n}\n","import { VALIDATORS } from './validation';\nimport { DatasourceProps as AdapterResetParams } from './datasource';\nimport { AdapterProcess as Process } from '../processes/misc/enums';\nimport { ICommonProps, AdapterProcessMap } from '../interfaces/index';\n\nconst {\n  INTEGER,\n  INTEGER_UNLIMITED,\n  BOOLEAN,\n  OBJECT,\n  ITEM_LIST,\n  FUNC_WITH_X_ARGUMENTS,\n  FUNC_WITH_X_AND_MORE_ARGUMENTS,\n  FUNC_WITH_X_TO_Y_ARGUMENTS,\n  ONE_OF_MUST,\n  ONE_OF_CAN,\n  OR,\n} = VALIDATORS;\n\nenum AdapterNoParams { }\nconst NO_METHOD_PARAMS: ICommonProps<AdapterNoParams> = {};\n\nconst RESET_METHOD_PARAMS: ICommonProps<AdapterResetParams> = {\n  [AdapterResetParams.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]\n  },\n  [AdapterResetParams.settings]: {\n    validators: [OBJECT]\n  },\n  [AdapterResetParams.devSettings]: {\n    validators: [OBJECT]\n  },\n};\n\nenum AdapterReloadParams {\n  reloadIndex = 'reloadIndex',\n}\n\nconst RELOAD_METHOD_PARAMS: ICommonProps<AdapterReloadParams> = {\n  [AdapterReloadParams.reloadIndex]: {\n    validators: [INTEGER]\n  },\n};\n\nenum AdapterAppendParams {\n  items = 'items',\n  bof = 'bof',\n  eof = 'eof',\n}\n\nconst APPEND_METHOD_PARAMS: ICommonProps<AdapterAppendParams> = {\n  [AdapterAppendParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterAppendParams.bof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.eof])]\n  },\n  [AdapterAppendParams.eof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.bof])]\n  },\n};\n\nenum AdapterRemoveParams {\n  predicate = 'predicate',\n  indexes = 'indexes',\n  increase = 'increase',\n}\n\nconst REMOVE_METHOD_PARAMS: ICommonProps<AdapterRemoveParams> = {\n  [AdapterRemoveParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]\n  },\n  [AdapterRemoveParams.indexes]: {\n    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]\n  },\n  [AdapterRemoveParams.increase]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterClipParams {\n  backwardOnly = 'backwardOnly',\n  forwardOnly = 'forwardOnly',\n}\n\nconst CLIP_METHOD_PARAMS: ICommonProps<AdapterClipParams> = {\n  [AdapterClipParams.backwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],\n    defaultValue: false\n  },\n  [AdapterClipParams.forwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],\n    defaultValue: false\n  },\n};\n\nenum AdapterInsertParams {\n  items = 'items',\n  before = 'before',\n  after = 'after',\n  decrease = 'decrease',\n}\n\nconst INSERT_METHOD_PARAMS: ICommonProps<AdapterInsertParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterInsertParams.before]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.after])]\n  },\n  [AdapterInsertParams.after]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.before])]\n  },\n  [AdapterInsertParams.decrease]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterReplaceParams {\n  items = 'items',\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst REPLACE_METHOD_PARAMS: ICommonProps<AdapterReplaceParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterReplaceParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterReplaceParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  }\n};\n\nenum AdapterUpdateParams {\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst UPDATE_METHOD_PARAMS: ICommonProps<AdapterUpdateParams> = {\n  [AdapterUpdateParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterUpdateParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterFixParams {\n  scrollPosition = 'scrollPosition',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  updater = 'updater',\n  scrollToItem = 'scrollToItem',\n  scrollToItemOpt = 'scrollToItemOpt',\n}\n\nconst FIX_METHOD_PARAMS: ICommonProps<AdapterFixParams> = {\n  [AdapterFixParams.scrollPosition]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.minIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.maxIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.updater]: {\n    validators: [FUNC_WITH_X_TO_Y_ARGUMENTS(1, 2)]\n  },\n  [AdapterFixParams.scrollToItem]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)]\n  },\n  [AdapterFixParams.scrollToItemOpt]: {\n    validators: [OR([BOOLEAN, OBJECT])]\n  },\n};\n\nexport const AdapterMethods: AdapterProcessMap<{ [key: string]: string }> = {\n  [Process.reset]: AdapterResetParams,\n  [Process.reload]: AdapterReloadParams,\n  [Process.append]: AdapterAppendParams,\n  [Process.prepend]: AdapterAppendParams,\n  [Process.check]: AdapterNoParams,\n  [Process.remove]: AdapterRemoveParams,\n  [Process.clip]: AdapterClipParams,\n  [Process.insert]: AdapterInsertParams,\n  [Process.replace]: AdapterReplaceParams,\n  [Process.update]: AdapterUpdateParams,\n  [Process.fix]: AdapterFixParams,\n};\n\nexport const ADAPTER_METHODS: AdapterProcessMap<ICommonProps<PropertyKey>> = {\n  [Process.reset]: RESET_METHOD_PARAMS,\n  [Process.reload]: RELOAD_METHOD_PARAMS,\n  [Process.append]: APPEND_METHOD_PARAMS,\n  [Process.prepend]: APPEND_METHOD_PARAMS,\n  [Process.check]: NO_METHOD_PARAMS,\n  [Process.remove]: REMOVE_METHOD_PARAMS,\n  [Process.clip]: CLIP_METHOD_PARAMS,\n  [Process.insert]: INSERT_METHOD_PARAMS,\n  [Process.replace]: REPLACE_METHOD_PARAMS,\n  [Process.update]: UPDATE_METHOD_PARAMS,\n  [Process.fix]: FIX_METHOD_PARAMS,\n};\n","import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS, SizeStrategy } from '../inputs/index';\nimport { Settings as ISettings, DevSettings as IDevSettings, ICommonProps, ItemsProcessor } from '../interfaces/index';\n\nexport class Settings<Data = unknown> implements ISettings, IDevSettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n  viewportElement: HTMLElement | (() => void) | null;\n  inverse: boolean; // if true, bwd padding element will have a priority when filling the viewport (if lack of items)\n  onBeforeClip: ItemsProcessor | null; // if set, it will be run before clipping items from Buffer after they are hidden\n  sizeStrategy: SizeStrategy; // \"average\" | \"frequent\", determines behavior of unknown items\n\n  // development settings\n  debug: boolean; // if true, logging is enabled; need to turn off when release\n  immediateLog: boolean; // if false, logging is not immediate and could be done via Workflow.logForce call\n  logTime: boolean; // if true, time differences will be logged\n  logProcessRun: boolean; // if true, process fire/run info will be logged\n  throttle: number; // if > 0, scroll event handling is throttled (ms)\n  initDelay: number; // if set, the Workflow initialization will be postponed (ms)\n  initWindowDelay: number; // if set and the entire window is scrollable, the Workflow init will be postponed (ms)\n  cacheData: boolean; // if true, item's data will be cached along with item's size and index\n  cacheOnReload: boolean; // if true, cache will not be flushed on reload\n  changeOverflow: boolean; // if true, scroll will be disabled per each item's average size change\n  dismissOverflowAnchor: boolean; // if true, the viewport will receive \"overflowAnchor: none\"\n\n  // internal settings, managed by scroller itself\n  instanceIndex: number;\n  initializeDelay: number;\n  viewport: HTMLElement | null;\n\n  constructor(\n    settings: ISettings<Data> | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    this.parseInput(settings, SETTINGS);\n    this.parseInput(devSettings, DEV_SETTINGS);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    this.viewport = this.getViewport();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  parseInput(input: ISettings<Data> | IDevSettings | undefined, props: ICommonProps<PropertyKey>): void {\n    const result = validate(input, props);\n    if (!result.isValid) {\n      throw new Error('Invalid settings');\n    }\n    Object.entries(result.params).forEach(([key, par]) =>\n      Object.assign(this, { [key]: par.value })\n    );\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n\n  getViewport(): HTMLElement | null {\n    if (typeof this.viewportElement !== 'function') {\n      return this.viewportElement;\n    }\n    const value = this.viewportElement();\n    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });\n    if (!result.isValid) {\n      return null; // fallback to default (null) if Function didn't return HTML element synchronously\n    }\n    return result.value as HTMLElement;\n  }\n}\n","import { AdapterProcess, ProcessStatus } from './enums';\nimport { Scroller } from '../../scroller';\nimport { ADAPTER_METHODS, validate } from '../../inputs/index';\nimport { ProcessName, IBaseProcess, IBaseAdapterProcess, IAdapterInput } from '../../interfaces/index';\n\nexport const BaseProcessFactory = (process: ProcessName): IBaseProcess =>\n\n  class BaseProcess {\n\n    static process: ProcessName = process;\n\n  };\n\nexport const BaseAdapterProcessFactory = (process: AdapterProcess): IBaseAdapterProcess =>\n\n  class BaseAdapterProcess extends (BaseProcessFactory(process) as IBaseProcess) {\n\n    static process: AdapterProcess = process;\n\n    static parseInput<T>(scroller: Scroller, options: T, ignoreErrors = false): IAdapterInput<T> {\n      const result: IAdapterInput<T> = {\n        data: validate(options, ADAPTER_METHODS[process])\n      };\n\n      if (result.data.isValid) {\n        result.params = Object.entries(result.data.params)\n          .reduce((acc, [key, { value }]) => ({\n            ...acc,\n            [key]: value\n          }), {} as T);\n      } else {\n        scroller.logger.log(() => result.data.showErrors());\n        if (!ignoreErrors) {\n          scroller.workflow.call({\n            process,\n            status: ProcessStatus.error,\n            payload: { error: `Wrong argument of the \"${process}\" method call` }\n          });\n        }\n      }\n\n      return result;\n    }\n\n  };\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ProcessName } from '../interfaces/index';\n\nconst initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];\n\nexport default class Init extends BaseProcessFactory(CommonProcess.init) {\n\n  static run(scroller: Scroller, process: ProcessName): void {\n    const { state: { cycle }, workflow } = scroller;\n    const isInitial = initProcesses.includes(process);\n    scroller.logger.logCycle(true);\n    cycle.start(isInitial, process);\n    workflow.call({\n      process: Init.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { ScrollEventData, ScrollerWorkflow } from '../interfaces/index';\n\nexport default class Scroll extends BaseProcessFactory(CommonProcess.scroll) {\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static run(scroller: Scroller, payload?: { event?: Event }): void {\n    const { workflow, viewport } = scroller;\n    const position = viewport.scrollPosition;\n\n    if (Scroll.onSynthetic(scroller, position)) {\n      return;\n    }\n\n    Scroll.onThrottle(scroller, position, () =>\n      Scroll.onScroll(scroller, workflow)\n    );\n  }\n\n  static onSynthetic(scroller: Scroller, position: number): boolean {\n    const { scrollState } = scroller.state;\n    const synthPos = scrollState.syntheticPosition;\n    if (synthPos !== null) {\n      if (scrollState.syntheticFulfill) {\n        scrollState.syntheticPosition = null;\n      }\n      if (!scrollState.syntheticFulfill || synthPos === position) {\n        scroller.logger.log(() => [\n          'skipping scroll', position, `[${scrollState.syntheticFulfill ? '' : 'pre-'}synthetic]`\n        ]);\n        return true;\n      }\n      scroller.logger.log(() => [\n        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos\n      ]);\n    }\n    return false;\n  }\n\n  static onThrottle(scroller: Scroller, position: number, done: () => void): void {\n    const { state: { scrollState }, settings: { throttle }, logger } = scroller;\n    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);\n    const { direction, time } = scrollState.current;\n    const timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;\n    const delta = throttle - timeDiff;\n    const shouldDelay = isFinite(delta) && delta > 0;\n    const alreadyDelayed = !!scrollState.scrollTimer;\n    logger.log(() => [\n      direction === Direction.backward ? '\\u2934' : '\\u2935',\n      position,\n      shouldDelay ? (timeDiff + 'ms') : '0ms',\n      shouldDelay ? (alreadyDelayed ? 'delayed' : `/ ${delta}ms delay`) : ''\n    ]);\n    if (!shouldDelay) {\n      if (scrollState.scrollTimer) {\n        clearTimeout(scrollState.scrollTimer);\n        scrollState.scrollTimer = null;\n      }\n      done();\n      return;\n    }\n    if (!alreadyDelayed) {\n      scrollState.scrollTimer = setTimeout(() => {\n        logger.log(() => {\n          const curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);\n          return [\n            curr.direction === Direction.backward ? '\\u2934' : '\\u2935',\n            curr.position,\n            (curr.time - time) + 'ms',\n            'triggered by timer set on',\n            position\n          ];\n        });\n        scrollState.scrollTimer = null;\n        done();\n      }, delta);\n    }\n  }\n\n  static getScrollEvent(position: number, previous: ScrollEventData | null): ScrollEventData {\n    const time = Number(new Date());\n    let direction: Direction | null = Direction.forward;\n    if (previous) {\n      if (position === previous.position) {\n        direction = previous.direction;\n      } else if (position < previous.position) {\n        direction = Direction.backward;\n      }\n    }\n    return { position, direction, time };\n  }\n\n  static onScroll(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { state: { scrollState, cycle } } = scroller;\n    scrollState.previous = { ...(scrollState.current as ScrollEventData) };\n    scrollState.current = null;\n\n    if (cycle.busy.get()) {\n      scroller.logger.log(() => ['skipping scroll', (scrollState.previous as ScrollEventData).position, '[pending]']);\n      return;\n    }\n\n    workflow.call({\n      process: Scroll.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { DatasourceProps } from '../../inputs/index';\nimport { Datasource } from '../../classes/datasource';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { IDatasourceOptional, ProcessPayload } from '../../interfaces/index';\n\nexport default class Reset extends BaseAdapterProcessFactory(AdapterProcess.reset) {\n\n  static run(scroller: Scroller, options?: IDatasourceOptional): void {\n    const { datasource, buffer, viewport: { paddings }, state: { cycle } } = scroller;\n\n    if (options) {\n      const { data } = Reset.parseInput(scroller, options);\n      if (!data.isValid) {\n        return;\n      }\n      const constructed = options instanceof Datasource;\n      Object.keys(DatasourceProps).forEach(key => {\n        const param = data.params[key];\n        const ds = datasource as unknown as { [key: string]: unknown };\n        if (param.isSet || (constructed && ds[key])) {\n          ds[key] = param.value;\n        }\n      });\n    }\n\n    buffer.reset(true);\n    paddings.backward.reset();\n    paddings.forward.reset();\n\n    const payload: ProcessPayload = { datasource };\n    if (cycle.busy.get()) {\n      payload.finalize = true;\n      cycle.interrupter = Reset.process;\n    }\n\n    scroller.workflow.call({\n      process: Reset.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { ProcessPayload } from '../../interfaces/index';\n\nexport default class Reload extends BaseAdapterProcessFactory(AdapterProcess.reload) {\n\n  static run(scroller: Scroller, reloadIndex: number): void {\n    const { viewport, state, buffer } = scroller;\n\n    const { params } = Reload.parseInput(scroller, { reloadIndex }, true);\n\n    buffer.reset(false, params ? params.reloadIndex : void 0);\n    viewport.reset(buffer.startIndex);\n\n    const payload: ProcessPayload = {};\n    if (state.cycle.busy.get()) {\n      state.scrollState.cleanupTimers();\n      payload.finalize = true;\n      state.cycle.interrupter = Reload.process;\n    }\n\n    scroller.workflow.call({\n      process: Reload.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Routines } from './domRoutines';\nimport { Direction } from '../inputs/index';\nimport { Item as _Item, ItemAdapter } from '../interfaces/index';\n\nexport class Item<Data = unknown> implements _Item<Data> {\n  nodeId: string;\n  routines: Routines;\n  size: number;\n  invisible: boolean;\n  toRemove: boolean;\n  toInsert: boolean;\n  removeDirection: Direction;\n\n  private container: ItemAdapter<Data>;\n\n  get $index(): number {\n    return this.container.$index;\n  }\n  set $index(value: number) {\n    this.container.$index = value;\n  }\n\n  get data(): Data {\n    return this.container.data;\n  }\n  set data(value: Data) {\n    this.container.data = value;\n  }\n\n  get element(): HTMLElement {\n    return this.container.element as HTMLElement;\n  }\n  set element(value: HTMLElement) {\n    this.container.element = value;\n  }\n\n  constructor($index: number, data: Data, routines: Routines) {\n    this.container = {\n      $index,\n      data\n    };\n    this.nodeId = String($index);\n    this.routines = routines;\n    this.invisible = true;\n    this.toRemove = false;\n    this.toInsert = false;\n  }\n\n  dispose(): void {\n    delete this.container.element;\n  }\n\n  setSize(): void {\n    this.size = this.routines.getSize(this.element);\n  }\n\n  hide(): void {\n    if (this.element) {\n      this.routines.hideElement(this.element);\n    }\n  }\n\n  scrollTo(argument?: boolean | ScrollIntoViewOptions): void {\n    if (this.element) {\n      this.routines.scrollTo(this.element, argument);\n    }\n  }\n\n  updateIndex(index: number): void {\n    this.$index = index;\n    this.nodeId = String(index);\n  }\n\n  get(): ItemAdapter<Data> {\n    return this.container;\n  }\n}\n","import { Scroller } from '../../scroller';\nimport { Item } from '../../classes/item';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterAppendOptions, AdapterPrependOptions } from '../../interfaces/index';\n\ntype AdapterAppendPrependOptions = AdapterAppendOptions & AdapterPrependOptions;\n\ninterface AppendRunOptions {\n  process: AdapterProcess;\n  options: AdapterAppendPrependOptions;\n}\n\nexport default class Append extends BaseAdapterProcessFactory(AdapterProcess.append) {\n\n  static run(scroller: Scroller, { process, options }: AppendRunOptions): void {\n\n    const { params } = Append.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const { items, bof, eof } = params;\n    const prepend = process !== AdapterProcess.append;\n    const _eof = !!(prepend ? bof : eof);\n\n    // virtual prepend case: shift abs min index and update viewport params\n    if (\n      (prepend && _eof && !scroller.buffer.bof.get()) ||\n      (!prepend && _eof && !scroller.buffer.eof.get())\n    ) {\n      Append.doVirtualize(scroller, items, prepend);\n      scroller.workflow.call({\n        process: Append.process,\n        status: ProcessStatus.done\n      });\n      return;\n    }\n\n    Append.simulateFetch(scroller, items, _eof, prepend);\n\n    scroller.workflow.call({\n      process: Append.process,\n      status: ProcessStatus.next\n    });\n  }\n\n  static doVirtualize(scroller: Scroller, items: unknown[], prepend: boolean): void {\n    const { buffer, viewport: { paddings } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    if (isFinite(buffer[bufferToken])) {\n      const size = items.length * buffer.defaultSize;\n      const padding = prepend ? paddings.backward : paddings.forward;\n      buffer[bufferToken] += (prepend ? -1 : 1) * items.length;\n      padding.size += size;\n      if (prepend) {\n        scroller.viewport.scrollPosition += size;\n      }\n      scroller.logger.log(() => `buffer.${[bufferToken]} value is set to ${buffer[bufferToken]}`);\n      scroller.logger.stat(`after virtual ${prepend ? 'prepend' : 'append'}`);\n    }\n  }\n\n  static simulateFetch(scroller: Scroller, items: unknown[], eof: boolean, prepend: boolean): boolean {\n    const { buffer, state: { fetch } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    let indexToAdd = buffer.getIndexToAdd(eof, prepend);\n    let bufferLimit = buffer[bufferToken];\n    const newItems: Item[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const itemToAdd = new Item(indexToAdd, items[i], scroller.routines);\n      if (isFinite(bufferLimit) && (\n        (prepend && indexToAdd < bufferLimit) ||\n        (!prepend && indexToAdd > bufferLimit)\n      )) {\n        bufferLimit += (prepend ? -1 : 1);\n      }\n      (prepend ? Array.prototype.unshift : Array.prototype.push).apply(newItems, [itemToAdd]);\n      // (prepend ? newItems.unshift : newItems.push)(itemToAdd);\n      indexToAdd += (prepend ? -1 : 1);\n    }\n\n    if (bufferLimit !== buffer[bufferToken]) {\n      buffer[bufferToken] = bufferLimit;\n      scroller.logger.log(() => `buffer.${bufferToken} value is set to ${buffer[bufferToken]}`);\n    }\n\n    (prepend ? fetch.prepend : fetch.append).call(fetch, newItems);\n    (prepend ? buffer.prepend : buffer.append).call(buffer, newItems);\n    fetch.first.indexBuffer = !isNaN(buffer.firstIndex) ? buffer.firstIndex : indexToAdd;\n    fetch.last.indexBuffer = !isNaN(buffer.lastIndex) ? buffer.lastIndex : indexToAdd;\n\n    return true;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\n\nexport default class Check extends BaseAdapterProcessFactory(AdapterProcess.check) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch }, viewport } = scroller;\n    let min = Infinity, max = -Infinity;\n\n    buffer.items.forEach(item => {\n      const size = item.size;\n      item.setSize();\n      if (item.size !== size) {\n        buffer.cacheItem(item);\n        min = Math.min(min, item.$index);\n        max = Math.max(max, item.$index);\n      }\n    });\n\n    if (Number.isFinite(min)) {\n      fetch.first.indexBuffer = buffer.firstIndex;\n      fetch.last.indexBuffer = buffer.lastIndex;\n      const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      fetch.firstVisibleIndex = firstIndex;\n      if (!isNaN(firstIndex)) {\n        fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(firstIndex) + diff;\n      }\n      fetch.check(\n        buffer.items.filter(item => item.$index >= min && item.$index <= max)\n      );\n    }\n\n    scroller.logger.stat('check');\n\n    workflow.call({\n      process: Check.process,\n      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\nimport { AdapterRemoveOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Remove extends BaseAdapterProcessFactory(AdapterProcess.remove) {\n\n  static run(scroller: Scroller, options: AdapterRemoveOptions): void {\n    const { params } = Remove.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldRemove = Remove.doRemove(scroller, params);\n\n    scroller.workflow.call({\n      process: Remove.process,\n      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doRemove(scroller: Scroller, params: AdapterRemoveOptions, sequenceOnly = false): boolean {\n    const { fetch } = scroller.state;\n    fetch.firstVisibleIndex = NaN;\n    const bufferRemoveList = Remove.removeBufferedItems(scroller, params);\n    if (params.indexes && params.indexes.length) { // to avoid duplicate buffer-virtual removals\n      params.indexes = params.indexes.filter(i => !bufferRemoveList.includes(i));\n    }\n    const shouldRemoveBuffered = bufferRemoveList.length > 0;\n    const shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);\n    if (!shouldRemoveBuffered && !shouldRemoveVirtual) {\n      return false;\n    }\n    if (!isNaN(fetch.firstVisibleIndex)) {\n      fetch.remove();\n    }\n    scroller.logger.stat('after remove');\n    return true;\n  }\n\n  static removeBufferedItems(scroller: Scroller, options: AdapterRemoveOptions): number[] {\n    const { predicate, indexes, increase } = options;\n    let result: number[] = [];\n    if (predicate) {\n      result = Remove.runPredicateOverBuffer(scroller, predicate, !!increase);\n    }\n    if (indexes) {\n      const indexPredicate: ItemsPredicate = ({ $index }) => indexes.indexOf($index) >= 0;\n      result = Remove.runPredicateOverBuffer(scroller, indexPredicate, !!increase);\n    }\n    return result;\n  }\n\n  static runPredicateOverBuffer(scroller: Scroller, predicate: ItemsPredicate, increase: boolean): number[] {\n    const { viewport, buffer, buffer: { items }, state: { fetch } } = scroller;\n\n    // get items to remove\n    const clipList = [];\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (predicate(item.get())) {\n        clipList.push(item);\n        item.toRemove = true;\n      } else if (clipList.length) {\n        break; // allow only first strict uninterrupted sequence\n      }\n    }\n    if (!clipList.length) {\n      return [];\n    }\n\n    // what item should be shown after remove (1-4)\n    const firstClipIndex = clipList[0].$index, lastClipIndex = clipList[clipList.length - 1].$index;\n    // 1) current first visible item will remain\n    const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n    if (firstIndex < firstClipIndex || firstIndex > lastClipIndex) {\n      fetch.firstVisibleIndex = firstIndex;\n      fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(firstIndex) + diff;\n    }\n    // 2) next after the last removed item\n    if (isNaN(fetch.firstVisibleIndex) && lastClipIndex < buffer.finiteAbsMaxIndex) {\n      fetch.firstVisibleIndex = lastClipIndex + 1;\n    }\n    // 3) prev before the first removed item\n    if (isNaN(fetch.firstVisibleIndex) && firstClipIndex > buffer.finiteAbsMinIndex) {\n      fetch.firstVisibleIndex = firstClipIndex - 1;\n    }\n    // 4) prev before the first removed item\n    if (isNaN(fetch.firstVisibleIndex)) {\n      fetch.firstVisibleIndex = buffer.finiteAbsMinIndex;\n    }\n\n    // logical removal\n    const indexListToRemove = clipList.map(item => item.$index);\n    scroller.logger.log(() =>\n      `going to remove ${clipList.length} item(s) from Buffer: [${indexListToRemove.join(',')}]`\n    );\n    buffer.removeItems(indexListToRemove, increase, false);\n    buffer.checkDefaultSize();\n    Remove.shiftFirstVisibleIndex(scroller, indexListToRemove, increase);\n\n    // physical removal (hiding)\n    clipList.forEach(item => item.hide());\n\n    return indexListToRemove;\n  }\n\n  static removeVirtualItems(scroller: Scroller, params: AdapterRemoveOptions, sequenceOnly: boolean): boolean {\n    const { indexes, increase } = params;\n    if (!indexes || !indexes.length) {\n      return false;\n    }\n    const { buffer, viewport, state: { fetch } } = scroller;\n\n    // get items to remove\n    const { finiteAbsMinIndex, firstIndex, finiteAbsMaxIndex, lastIndex } = buffer;\n    const toRemove = [];\n    let last = NaN;\n    for (let i = 0, len = indexes.length; i < len; i++) {\n      const index = indexes[i];\n      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {\n        toRemove.push(index); // backward;\n      } else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {\n        toRemove.push(index); // forward;\n      } else {\n        continue;\n      }\n      if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {\n        // allow only first strict uninterrupted sequence\n        break;\n      }\n      last = index;\n    }\n\n    if (!toRemove.length) {\n      return false;\n    }\n\n    // what should be shown after remove; Buffer removal has priority\n    if (isNaN(fetch.firstVisibleIndex)) {\n      const { index, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      if (!isNaN(index)) {\n        fetch.firstVisibleIndex = index;\n        fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(index) + diff;\n      }\n    }\n\n    // virtual removal\n    scroller.logger.log(() => `going to remove ${toRemove.length} item(s) virtually`);\n    buffer.removeItems(toRemove, !!increase, true);\n    buffer.checkDefaultSize();\n    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);\n\n    return true;\n  }\n\n  static shiftFirstVisibleIndex({ state: { fetch } }: Scroller, listToRemove: number[], increase: boolean): void {\n    if (isNaN(fetch.firstVisibleIndex)) {\n      return;\n    }\n    const shift = listToRemove.reduce((acc, index) => acc + (\n      ((increase && index > fetch.firstVisibleIndex) || (!increase && index < fetch.firstVisibleIndex)) ? 1 : 0\n    ), 0);\n    fetch.firstVisibleIndex = fetch.firstVisibleIndex + (increase ? shift : -shift);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterClipOptions } from '../../interfaces/index';\n\nexport default class UserClip extends BaseAdapterProcessFactory(AdapterProcess.clip) {\n\n  static run(scroller: Scroller, options?: AdapterClipOptions): void {\n    const { params } = UserClip.parseInput(scroller, options);\n\n    scroller.state.clip.forceForward = !(params && params.backwardOnly);\n    scroller.state.clip.forceBackward = !(params && params.forwardOnly);\n\n    scroller.workflow.call({\n      process: UserClip.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Item } from '../../classes/item';\nimport { Direction } from '../../inputs/index';\nimport { AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Update extends BaseAdapterProcessFactory(AdapterProcess.update) {\n\n  static run(scroller: Scroller, options: AdapterUpdateOptions): void {\n    const { params } = Update.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    const shouldUpdate = Update.doUpdate(scroller, params);\n\n    scroller.workflow.call({\n      process: Update.process,\n      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doUpdate(scroller: Scroller, params: AdapterUpdateOptions): boolean {\n    const { buffer, viewport, state: { fetch }, routines, logger } = scroller;\n    if (!buffer.items) {\n      logger.log(() => 'no items in Buffer');\n      return false;\n    }\n    const before = [...buffer.items];\n    const { item: firstItem, index: firstIndex, diff: firstItemDiff } =\n      viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n\n    const trackedIndex = buffer.updateItems(\n      params.predicate,\n      (index, data) => new Item(index, data, routines),\n      firstIndex,\n      !!params.fixRight\n    );\n\n    let delta = 0;\n    const trackedItem = buffer.get(trackedIndex);\n    if (firstItem && firstItem === trackedItem) {\n      delta = - buffer.getSizeByIndex(trackedIndex) + firstItemDiff;\n    }\n\n    const itemsToRemove = before.filter(({ toRemove }) => toRemove);\n    itemsToRemove.forEach(item => item.hide());\n    logger.log(() => itemsToRemove.length\n      ? 'items to remove: [' + itemsToRemove.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to remove'\n    );\n\n    const itemsToRender = buffer.items.filter(({ toInsert }) => toInsert);\n    logger.log(() => itemsToRender.length\n      ? 'items to render: [' + itemsToRender.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to render'\n    );\n\n    fetch.update(trackedIndex, delta, itemsToRender, itemsToRemove);\n    return !!itemsToRemove.length || !!itemsToRender.length;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterInsertOptions, AdapterUpdateOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Insert extends BaseAdapterProcessFactory(AdapterProcess.insert) {\n\n  static run(scroller: Scroller, options: AdapterInsertOptions): void {\n    const { params } = Insert.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldInsert = Insert.doInsert(scroller, params);\n\n    scroller.workflow.call({\n      process: Insert.process,\n      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doInsert(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { before, after, items, decrease } = params;\n    const method = (before || after) as ItemsPredicate;\n    const found = scroller.buffer.items.find(item => method(item.get()));\n    if (!found) {\n      scroller.logger.log('no item to insert found');\n      return false;\n    }\n\n    const indexToInsert = found.$index;\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index, data }) => {\n        if (indexToInsert === $index) {\n          return before ? [...items, data] : [data, ...items];\n        }\n        return true;\n      },\n      fixRight: decrease\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterReplaceOptions, AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Replace extends BaseAdapterProcessFactory(AdapterProcess.replace) {\n\n  static run(scroller: Scroller, options: AdapterReplaceOptions): void {\n    const { params } = Replace.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldReplace = Replace.doReplace(scroller, params);\n\n    scroller.workflow.call({\n      process: Replace.process,\n      status: shouldReplace ? ProcessStatus.next : ProcessStatus.done,\n    });\n  }\n\n  static doReplace(scroller: Scroller, params: AdapterReplaceOptions): boolean {\n    const toRemove = scroller.buffer.items\n      .filter(item => params.predicate(item))\n      .map(item => item.$index);\n\n    if (!toRemove.length) {\n      scroller.logger.log('no items to be replaced');\n      return false;\n    }\n\n    let injected = false;\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index }) => {\n        if (!toRemove.includes($index)) {\n          return true;\n        }\n        if (!injected) {\n          injected = true;\n          return params.items;\n        }\n        return false;\n      },\n      fixRight: params.fixRight\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { AdapterMethods } from '../../inputs/index';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport {\n  ItemsPredicate,\n  ItemsUpdater,\n  AdapterFixOptions,\n  IValidatedData,\n} from '../../interfaces/index';\n\nconst { [AdapterProcess.fix]: FixParams } = AdapterMethods;\n\nexport default class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {\n\n  static run(scroller: Scroller, options: AdapterFixOptions): void {\n    const { workflow } = scroller;\n\n    const { data, params } = Fix.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    Object.entries(data.params).forEach(([key, value]) => {\n      if (value.isSet && value.isValid) {\n        Fix.runByType(scroller, key, value.value, data);\n      }\n    });\n\n    workflow.call({\n      process: Fix.process,\n      status: ProcessStatus.done\n    });\n  }\n\n  static runByType(scroller: Scroller, token: string, value: unknown, methodData: IValidatedData): void {\n    switch (token) {\n      case FixParams.scrollPosition:\n        return Fix.setScrollPosition(scroller, value as number);\n      case FixParams.minIndex:\n        return Fix.setMinIndex(scroller, value as number);\n      case FixParams.maxIndex:\n        return Fix.setMaxIndex(scroller, value as number);\n      case FixParams.updater:\n        return Fix.updateItems(scroller, value as ItemsUpdater);\n      case FixParams.scrollToItem:\n        if (methodData.params) {\n          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];\n          const options = scrollToItemOpt ? scrollToItemOpt.value as AdapterFixOptions['scrollToItemOpt'] : void 0;\n          return Fix.scrollToItem(scroller, value as ItemsPredicate, options);\n        }\n        return;\n      case FixParams.scrollToItemOpt:\n        return;\n    }\n  }\n\n  static setScrollPosition({ viewport }: Scroller, value: number): void {\n    let result = value;\n    if (value === -Infinity) {\n      result = 0;\n    } else if (value === Infinity) {\n      result = viewport.getScrollableSize();\n    }\n    viewport.setPosition(result);\n  }\n\n  static setMinIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.minIndex = value;\n    buffer.absMinIndex = value;\n  }\n\n  static setMaxIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.maxIndex = value;\n    buffer.absMaxIndex = value;\n  }\n\n  static updateItems({ buffer, logger }: Scroller, value: ItemsUpdater): void {\n    let updateReference = false;\n    const updater = () => updateReference = true;\n    buffer.items.forEach(item => value(item.get(), updater));\n    if (updateReference) {\n      logger.log(() => 'update Buffer.items reference');\n      buffer.items = [...buffer.items];\n    }\n  }\n\n  static scrollToItem(scroller: Scroller, value: ItemsPredicate, options?: boolean | ScrollIntoViewOptions): void {\n    const found = scroller.buffer.items.find(item => value(item.get()));\n    if (!found) {\n      scroller.logger.log(() => 'scrollToItem cancelled, item not found');\n      return;\n    }\n    found.scrollTo(options);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\n\nexport default class Start extends BaseProcessFactory(CommonProcess.start) {\n\n  static run(scroller: Scroller): void {\n    const payload = scroller.state.startInnerLoop();\n\n    scroller.workflow.call({\n      process: Start.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch, cycle } } = scroller;\n    fetch.minIndex = buffer.minIndex;\n\n    // set first and last indexes of items to fetch\n    PreFetch.setPositionsAndIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    if (scroller.settings.infinite) {\n      // fill indexes to include buffer if no clip\n      PreFetch.checkBufferGaps(scroller);\n    }\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    workflow.call({\n      process: PreFetch.process,\n      status: PreFetch.getStatus(scroller),\n      payload: { process: cycle.initiator }\n    });\n  }\n\n  static setPositionsAndIndexes(scroller: Scroller): void {\n    PreFetch.setPositions(scroller);\n    PreFetch.setFirstIndex(scroller);\n    PreFetch.setLastIndex(scroller);\n    scroller.logger.fetch();\n  }\n\n  static setPositions(scroller: Scroller): void {\n    const { state: { fetch: { positions } }, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    positions.before = viewport.scrollPosition;\n    positions.startDelta = PreFetch.getStartDelta(scroller);\n    positions.relative = positions.before - positions.startDelta;\n    positions.start = positions.relative - paddingDelta;\n    positions.end = positions.relative + viewport.getSize() + paddingDelta;\n  }\n\n  static getStartDelta(scroller: Scroller): number { // calculate size before start index\n    const { buffer, viewport: { offset } } = scroller;\n    let startDelta = 0;\n    if (offset) {\n      startDelta += offset;\n    }\n    if (!buffer.defaultSize) {\n      return startDelta;\n    }\n    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {\n      startDelta += buffer.getSizeByIndex(index);\n    }\n    scroller.logger.log(() => [\n      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])\n    ]);\n    return startDelta;\n  }\n\n  static setFirstIndex(scroller: Scroller): void {\n    const { state, buffer } = scroller;\n    const { positions: { start }, first } = state.fetch;\n    let firstIndex = buffer.startIndex;\n    let firstIndexPosition = 0;\n    if (state.cycle.innerLoop.isInitial) {\n      scroller.logger.log('skipping fetch backward direction [initial loop]');\n    } else if (!buffer.defaultSize) {\n      scroller.logger.log('skipping fetch backward direction [no item size]');\n    } else {\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) { // eslint-disable-line no-constant-condition\n        if (start >= 0) {\n          const size = buffer.getSizeByIndex(index);\n          const diff = (position + size) - start;\n          if (diff > 0) {\n            firstIndex = index;\n            firstIndexPosition = position;\n            break;\n          }\n          position += size;\n          index++;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n        }\n        if (start < 0) {\n          index--;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n          position -= buffer.getSizeByIndex(index);\n          const diff = position - start;\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (diff <= 0) {\n            break;\n          }\n        }\n      }\n    }\n    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    first.position = firstIndexPosition;\n  }\n\n  static setLastIndex(scroller: Scroller): void {\n    const { state: { fetch, cycle }, buffer, settings } = scroller;\n    const { positions: { relative, end }, first, last } = fetch;\n    let lastIndex;\n    if (!buffer.defaultSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = buffer.startIndex + settings.bufferSize - 1;\n      scroller.logger.log('forcing fetch forward direction [no item size]');\n    } else {\n      let index = first.indexBuffer;\n      let position = first.position;\n      lastIndex = index;\n      while (1) { // eslint-disable-line no-constant-condition\n        lastIndex = index;\n        const size = buffer.getSizeByIndex(index);\n        position += size;\n        if (isNaN(fetch.firstVisibleIndex) && position > relative) {\n          fetch.firstVisibleIndex = index;\n          if (!cycle.innerLoop.isInitial) {\n            fetch.firstVisibleItemDelta = position - size - relative;\n          }\n        }\n        if (position >= end) {\n          break;\n        }\n        if (index++ > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller): void {\n    const { buffer } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const packs: number[][] = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);\n    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkBufferGaps(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const fetchFirst = fetch.first.index;\n    const bufferLast = buffer.lastIndex;\n    if (fetchFirst > bufferLast) {\n      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;\n    }\n    const bufferFirst = buffer.firstIndex;\n    const fetchLast = fetch.last.index;\n    if (fetchLast < bufferFirst) {\n      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;\n    }\n    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {\n      scroller.logger.fetch('after Buffer filling (no clip case)');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.last.index = fetch.last.indexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.last.index) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n  static getStatus(scroller: Scroller): ProcessStatus {\n    const { cycle, fetch } = scroller.state;\n    if (cycle.initiator === AdapterProcess.clip) {\n      scroller.logger.log(() => `going to skip fetch due to \"${AdapterProcess.clip}\" process`);\n      return ProcessStatus.next;\n    }\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n      return ProcessStatus.next;\n    }\n    return ProcessStatus.done;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ObservableLike } from '../interfaces/index';\n\ninterface Immediate {\n  data: unknown[] | null;\n  error: unknown | null;\n  isError: boolean;\n}\n\ntype FetchGetResult = Immediate | Promise<unknown>;\n\ninterface FetchBox {\n  success: (value: unknown[]) => void;\n  fail: (value: unknown) => void;\n}\n\nexport default class Fetch extends BaseProcessFactory(CommonProcess.fetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n\n    const box = {\n      success: (data: unknown[]) => {\n        scroller.logger.log(() =>\n          `resolved ${data.length} items ` +\n          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`\n        );\n        scroller.state.fetch.newItemsData = data;\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.next\n        });\n      },\n      fail: (error: unknown) =>\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.error,\n          payload: { error }\n        })\n    };\n\n    const result = Fetch.get(scroller);\n    Fetch.complete(scroller, box, result);\n  }\n\n  static complete(scroller: Scroller, box: FetchBox, result: FetchGetResult): void {\n    if (Object.prototype.hasOwnProperty.call(result, 'data')) {\n      const { data, error, isError } = result as Immediate;\n      if (!isError) {\n        box.success(data || []);\n      } else {\n        box.fail(error);\n      }\n    } else {\n      const { state: { scrollState, fetch }, viewport } = scroller;\n      if (scrollState.positionBeforeAsync === null) {\n        scrollState.positionBeforeAsync = viewport.scrollPosition;\n      }\n      fetch.cancel = () => {\n        box.success = () => null;\n        box.fail = () => null;\n      };\n      (result as Promise<unknown[]>).then(\n        (data) => box.success(data),\n        (error) => box.fail(error)\n      );\n    }\n  }\n\n  static get(scroller: Scroller): FetchGetResult {\n    const _get = scroller.datasource.get;\n    const { index, count } = scroller.state.fetch;\n\n    let immediateData, immediateError;\n    let resolve: (value: unknown) => void, reject: (value: unknown) => void;\n\n    const done = (data: unknown[]) => {\n      if (!resolve) {\n        immediateData = data || null;\n        return;\n      }\n      resolve(data);\n    };\n    const fail = (error: unknown) => {\n      if (!reject) {\n        immediateError = error || null;\n        return;\n      }\n      reject(error);\n    };\n\n    const getResult = _get(index, count, done, fail);\n\n    if (getResult && typeof getResult === 'object' && getResult !== null) {\n      if (typeof (getResult as PromiseLike<unknown>).then === 'function') {\n        return getResult as Promise<unknown>;\n      } else if (typeof (getResult as ObservableLike).subscribe === 'function') {\n        const sub = (getResult as ObservableLike).subscribe(done, fail, () => {\n          if (sub && typeof sub === 'object' && typeof sub.unsubscribe === 'function') {\n            sub.unsubscribe();\n          }\n        });\n      }\n    }\n\n    if (immediateData || immediateError) { // callback case or immediate observable\n      return {\n        data: immediateError ? null : (immediateData || []),\n        error: immediateError,\n        isError: !!immediateError\n      };\n    }\n\n    return new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class PostFetch extends BaseProcessFactory(CommonProcess.postFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n    if (PostFetch.setItems(scroller)) {\n      PostFetch.setBufferLimits(scroller);\n      workflow.call({\n        process: PostFetch.process,\n        status: scroller.state.fetch.hasNewItems\n          ? ProcessStatus.next\n          : ProcessStatus.done\n      });\n    } else {\n      workflow.call({\n        process: PostFetch.process,\n        status: ProcessStatus.error,\n        payload: { error: 'Can\\'t set buffer items' }\n      });\n    }\n  }\n\n  static setBufferLimits(scroller: Scroller): void {\n    const { buffer, state: { fetch, fetch: { items }, cycle: { innerLoop } } } = scroller;\n    const first = fetch.first.index;\n    const last = fetch.last.index;\n    if (!items.length) {\n      if (last < buffer.minIndex || innerLoop.isInitial) {\n        buffer.absMinIndex = buffer.minIndex;\n      }\n      if (first > buffer.maxIndex || innerLoop.isInitial) {\n        buffer.absMaxIndex = buffer.maxIndex;\n      }\n    } else {\n      const lastIndex = items.length - 1;\n      if (first < items[0].$index) {\n        buffer.absMinIndex = items[0].$index;\n      }\n      if (last > items[lastIndex].$index) {\n        buffer.absMaxIndex = items[lastIndex].$index;\n      }\n    }\n  }\n\n  static setItems(scroller: Scroller): boolean {\n    const { buffer, state: { fetch, cycle } } = scroller;\n    const items = fetch.newItemsData;\n    if (!items || !items.length) { // empty result\n      return true;\n    }\n    // eof/bof case, need to shift fetch index if bof\n    let fetchIndex = fetch.index;\n    if (items.length < fetch.count) {\n      if (cycle.innerLoop.isInitial) {\n        // let's treat initial poor fetch as startIndex-bof\n        fetchIndex = buffer.startIndex;\n      } else if (fetch.first.index < buffer.minIndex) { // normal bof\n        fetchIndex = buffer.minIndex - items.length;\n      }\n    }\n    fetch.items = items.map((item, index: number) =>\n      new Item(fetchIndex + index, item, scroller.routines)\n    );\n    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;\n    return buffer.setItems(fetch.items);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class Render extends BaseProcessFactory(CommonProcess.render) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, state: { cycle, render, scrollState }, viewport } = scroller;\n    scroller.logger.stat('before new items render');\n    if (scrollState.positionBeforeAsync === null) {\n      scrollState.positionBeforeAsync = viewport.scrollPosition;\n    }\n    render.renderTimer = setTimeout(() => {\n      render.renderTimer = null;\n      if (Render.doRender(scroller)) {\n        workflow.call({\n          process: Render.process,\n          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,\n          payload: { process: cycle.initiator }\n        });\n      } else {\n        workflow.call({\n          process: Render.process,\n          status: ProcessStatus.error,\n          payload: { error: 'Can\\'t associate item with element' }\n        });\n      }\n    }, 0);\n  }\n\n  static doRender(scroller: Scroller): boolean {\n    const { state: { fetch, render }, viewport, buffer, logger } = scroller;\n    render.positionBefore = viewport.scrollPosition;\n    if (!fetch.isCheck) {\n      render.sizeBefore = viewport.getScrollableSize();\n      if (\n        fetch.items.map(item => Render.processElement(scroller, item)).some(x => !x)\n      ) {\n        return false;\n      }\n    }\n    buffer.checkDefaultSize();\n    render.sizeAfter = viewport.getScrollableSize();\n    logger.stat('after new items render');\n    logger.log(() => render.noSize ? 'viewport size has not been changed' : void 0);\n    return true;\n  }\n\n  static processElement(scroller: Scroller, item: Item): boolean {\n    const { state: { fetch }, viewport, buffer } = scroller;\n    const element = viewport.element.querySelector(`[data-sid=\"${item.nodeId}\"]`);\n    if (!element) {\n      return false;\n    }\n    item.element = element as HTMLElement;\n    item.element.style.left = '';\n    item.element.style.top = '';\n    item.element.style.position = '';\n    item.invisible = false;\n    item.setSize();\n    buffer.cacheItem(item);\n    if (item.$index < fetch.minIndex) {\n      fetch.negativeSize += item.size;\n    }\n    return true;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\n\r\nexport default class Adjust extends BaseProcessFactory(CommonProcess.adjust) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow, viewport, state: { scrollState } } = scroller;\r\n\r\n    scrollState.positionBeforeAdjust = viewport.scrollPosition;\r\n    Adjust.setPaddings(scroller);\r\n    scrollState.positionAfterAdjust = viewport.scrollPosition;\r\n\r\n    // scroll position adjustments\r\n    const position = Adjust.calculatePosition(scroller);\r\n\r\n    // set new position using animation frame\r\n    Adjust.setPosition(scroller, position, () =>\r\n      workflow.call({\r\n        process: Adjust.process,\r\n        status: ProcessStatus.done\r\n      })\r\n    );\r\n  }\r\n\r\n  static setPaddings(scroller: Scroller): void {\r\n    const { viewport, buffer, settings: { inverse }, state: { fetch } } = scroller;\r\n    const firstItem = buffer.getFirstVisibleItem();\r\n    const lastItem = buffer.getLastVisibleItem();\r\n    let first, last;\r\n    if (firstItem && lastItem) {\r\n      first = firstItem.$index;\r\n      last = lastItem.$index;\r\n    } else {\r\n      first = !isNaN(fetch.firstVisibleIndex) ? fetch.firstVisibleIndex : buffer.startIndex;\r\n      last = first - 1;\r\n    }\r\n    const { forward, backward } = viewport.paddings;\r\n    let index, bwdSize = 0, fwdSize = 0;\r\n\r\n    // new backward and forward paddings size\r\n    for (index = buffer.finiteAbsMinIndex; index < first; index++) {\r\n      bwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {\r\n      fwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n\r\n    // lack of items case\r\n    const bufferSize = viewport.getScrollableSize() - forward.size - backward.size;\r\n    const viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);\r\n    if (viewportSizeDiff > 0) {\r\n      if (inverse) {\r\n        bwdSize += viewportSizeDiff;\r\n      } else {\r\n        fwdSize += viewportSizeDiff;\r\n      }\r\n      scroller.logger.log(() =>\r\n        inverse ? 'backward' : 'forward' + ` padding will be increased by ${viewportSizeDiff} to fill the viewport`\r\n      );\r\n    }\r\n\r\n    backward.size = bwdSize;\r\n    forward.size = fwdSize;\r\n\r\n    scroller.logger.stat('after paddings adjustments');\r\n  }\r\n\r\n  static calculatePosition(scroller: Scroller): number {\r\n    const { viewport, buffer, state } = scroller;\r\n    const { fetch, render, scrollState } = state;\r\n    let position = viewport.paddings.backward.size;\r\n\r\n    // backward outlet increase\r\n    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {\r\n      for (let i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {\r\n        position += buffer.getSizeByIndex(i);\r\n      }\r\n      if (fetch.firstVisibleItemDelta) {\r\n        position -= fetch.firstVisibleItemDelta;\r\n      }\r\n    } else {\r\n      if (fetch.isPrepend && fetch.negativeSize) {\r\n        position += fetch.negativeSize;\r\n      }\r\n    }\r\n\r\n    // change per slow fetch/render\r\n    if (scrollState.positionBeforeAsync !== null) {\r\n      const diff = render.positionBefore - scrollState.positionBeforeAsync;\r\n      if (diff !== 0) {\r\n        scroller.logger.log(`shift position due to fetch-render difference (${diff})`);\r\n        position += diff;\r\n      }\r\n    }\r\n\r\n    // offset increase\r\n    if (viewport.offset > 0 && (position || fetch.positions.before)) {\r\n      position += viewport.offset;\r\n    }\r\n\r\n    return Math.round(position);\r\n  }\r\n\r\n  static setPosition(scroller: Scroller, position: number, done: () => void): void {\r\n    const { state: { scrollState }, viewport } = scroller;\r\n    if (!scrollState.hasPositionChanged(position)) {\r\n      return done();\r\n    }\r\n    scrollState.syntheticPosition = position;\r\n    scrollState.syntheticFulfill = false;\r\n\r\n    scrollState.animationFrameId = requestAnimationFrame(() => {\r\n      const inertiaDiff = (scrollState.positionAfterAdjust as number) - viewport.scrollPosition;\r\n      let diffLog = '';\r\n      if (inertiaDiff > 0) {\r\n        position -= inertiaDiff;\r\n        scrollState.syntheticPosition = position;\r\n        diffLog = ` (-${inertiaDiff})`;\r\n      }\r\n      scrollState.syntheticFulfill = true;\r\n      viewport.scrollPosition = position;\r\n      scroller.logger.stat('after scroll adjustment' + diffLog);\r\n      done();\r\n    });\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreClip extends BaseProcessFactory(CommonProcess.preClip) {\n\n  static run(scroller: Scroller): void {\n    PreClip.prepareClip(scroller);\n\n    scroller.workflow.call({\n      process: PreClip.process,\n      status: ProcessStatus.next,\n      payload: {\n        doClip: scroller.state.clip.doClip\n      }\n    });\n  }\n\n  static prepareClip(scroller: Scroller): void {\n    const { state: { fetch, clip } } = scroller;\n    if (PreClip.shouldNotClip(scroller)) {\n      return;\n    }\n    const firstIndex = fetch.first.indexBuffer;\n    const lastIndex = fetch.last.indexBuffer;\n    scroller.logger.log(() =>\n      `looking for ${fetch.direction ? 'anti-' + fetch.direction + ' ' : ''}items ` +\n      `that are out of [${firstIndex}..${lastIndex}] range`);\n    if (PreClip.isBackward(scroller, firstIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);\n    }\n    if (PreClip.isForward(scroller, lastIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);\n    }\n    if (!clip.doClip) {\n      scroller.logger.log('skipping clip [no items to clip]');\n    }\n    return;\n  }\n\n  static shouldNotClip(scroller: Scroller): boolean {\n    const { settings, buffer, state } = scroller;\n    if (settings.infinite && !state.clip.force) {\n      scroller.logger.log('skipping clip [infinite mode]');\n      return true;\n    }\n    if (!buffer.size) {\n      scroller.logger.log('skipping clip [empty buffer]');\n      return true;\n    }\n    if (state.cycle.isInitial) {\n      scroller.logger.log('skipping clip [initial cycle]');\n      return true;\n    }\n    return false;\n  }\n\n  static isBackward(scroller: Scroller, firstIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceBackward;\n    }\n    if (fetch.direction !== Direction.backward) {\n      if (firstIndex - 1 >= buffer.absMinIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static isForward(scroller: Scroller, lastIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceForward;\n    }\n    if (fetch.direction !== Direction.forward) {\n      if (lastIndex + 1 <= buffer.absMaxIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static prepareClipByDirection(scroller: Scroller, direction: Direction, edgeIndex: number): void {\n    const forward = direction === Direction.forward;\n    scroller.buffer.items.forEach(item => {\n      if (\n        (!forward && item.$index < edgeIndex) ||\n        (forward && item.$index > edgeIndex)\n      ) {\n        item.toRemove = true;\n        item.removeDirection = direction;\n        scroller.state.clip.doClip = true;\n      }\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport default class Clip extends BaseProcessFactory(CommonProcess.clip) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow } = scroller;\r\n\r\n    Clip.doClip(scroller);\r\n\r\n    workflow.call({\r\n      process: Clip.process,\r\n      status: ProcessStatus.next\r\n    });\r\n  }\r\n\r\n  static doClip(scroller: Scroller): void {\r\n    const { buffer, viewport: { paddings }, state: { clip }, logger } = scroller;\r\n    const size = { [Direction.backward]: 0, [Direction.forward]: 0 };\r\n\r\n    logger.stat(`before clip (${++clip.callCount})`);\r\n\r\n    const itemsToRemove = buffer.items.filter(item => {\r\n      if (!item.toRemove) {\r\n        return false;\r\n      }\r\n      item.hide();\r\n      size[item.removeDirection] += item.size;\r\n      return true;\r\n    });\r\n\r\n    if (itemsToRemove.length) {\r\n      if (size[Direction.backward]) {\r\n        paddings.byDirection(Direction.backward).size += size[Direction.backward];\r\n      }\r\n      if (size[Direction.forward]) {\r\n        paddings.byDirection(Direction.forward).size += size[Direction.forward];\r\n      }\r\n      if (scroller.settings.onBeforeClip) {\r\n        scroller.settings.onBeforeClip(itemsToRemove.map(item => item.get()));\r\n      }\r\n    }\r\n\r\n    buffer.clip();\r\n\r\n    logger.log(() => {\r\n      const list = itemsToRemove.map(({ $index }) => $index);\r\n      return list.length\r\n        ? [\r\n          `clipped ${list.length} item(s) from Buffer` +\r\n          (size.backward ? `, +${size.backward} fwd px` : '') +\r\n          (size.forward ? `, +${size.forward} bwd px` : '') +\r\n          `, range: [${list[0]}..${list[list.length - 1]}]`\r\n        ]\r\n        : 'clipped 0 items from Buffer';\r\n    });\r\n\r\n    logger.stat('after clip');\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { EMPTY_ITEM } from '../classes/adapter/props';\nimport { ScrollerWorkflow } from '../interfaces/index';\n\nconst isInterrupted = ({ call }: ScrollerWorkflow): boolean => !!call.interrupted;\n\nexport default class End extends BaseProcessFactory(CommonProcess.end) {\n\n  static run(scroller: Scroller, { error }: { error?: unknown } = {}): void {\n    const { workflow, state: { cycle: { interrupter } } } = scroller;\n\n    if (!error && !interrupter) {\n      // set out params accessible via Adapter\n      End.calculateParams(scroller, workflow);\n    }\n\n    // explicit interruption for we don't want to go through the inner loop finalizing\n    if (isInterrupted(workflow)) {\n      workflow.call({ process: End.process, status: ProcessStatus.done });\n      return;\n    }\n\n    const next = End.finalizeInnerLoop(scroller, error);\n\n    workflow.call({\n      process: End.process,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: { ...(interrupter ? { process: interrupter } : {}) }\n    });\n  }\n\n  static calculateParams(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { adapter, viewport, buffer: { items } } = scroller;\n\n    if (adapter.wanted.firstVisible) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.backward);\n      if (!item || item.element !== adapter.firstVisible.element) {\n        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n\n    // the workflow can be interrupter on firstVisible change\n    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.forward);\n      if (!item || item.element !== adapter.lastVisible.element) {\n        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n  }\n\n  static finalizeInnerLoop(scroller: Scroller, error: unknown): boolean {\n    const { state, state: { cycle, clip, fetch } } = scroller;\n    const next = !!cycle.interrupter || (error ? false : End.getNext(scroller));\n    cycle.innerLoop.isInitial = false;\n    fetch.stopSimulate();\n    clip.reset(true);\n    state.endInnerLoop();\n    return next;\n  }\n\n  static getNext(scroller: Scroller): boolean {\n    const { state: { fetch, render } } = scroller;\n    if (fetch.simulate && fetch.isCheck && !render.noSize) { // Adapter.check\n      return true;\n    }\n    if (fetch.simulate && fetch.doRemove) { // Adapter.remove or Adapter.update with clip\n      return true;\n    }\n    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch\n      !fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { CommonProcess, AdapterProcess, ProcessStatus as Status } from '../processes/index';\nimport { IPackages, ProcessSubject } from '../interfaces/index';\n\ntype LogType = [unknown?, ...unknown[]];\n\nexport class Logger {\n\n  readonly debug: boolean;\n  readonly immediateLog: boolean;\n  readonly logTime: boolean;\n  readonly getTime: () => string;\n  readonly getStat: () => string;\n  readonly getFetchRange: () => string;\n  readonly getWorkflowCycleData: () => string;\n  readonly getLoopId: () => string;\n  readonly getLoopIdNext: () => string;\n  readonly getScrollPosition: (element: HTMLElement) => number;\n  private logs: unknown[][] = [];\n\n  constructor(scroller: Scroller, packageInfo: IPackages, adapter?: { id: number }) {\n    const { settings } = scroller;\n    this.debug = settings.debug;\n    this.immediateLog = settings.immediateLog;\n    this.logTime = settings.logTime;\n    this.getTime = (): string =>\n      scroller.state && ` // time: ${scroller.state.time}`;\n    this.getStat = (): string => {\n      const { buffer, viewport } = scroller;\n      const first = buffer.getFirstVisibleItem();\n      const last = buffer.getLastVisibleItem();\n      return 'pos: ' + viewport.scrollPosition + ', ' +\n        'size: ' + viewport.getScrollableSize() + ', ' +\n        'bwd_p: ' + viewport.paddings.backward.size + ', ' +\n        'fwd_p: ' + viewport.paddings.forward.size + ', ' +\n        'default: ' + (buffer.defaultSize || 'no') + ', ' +\n        'items: ' + buffer.getVisibleItemsCount() + ', ' +\n        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');\n    };\n    this.getFetchRange = (): string => {\n      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;\n      return !Number.isNaN(first) && !Number.isNaN(last)\n        ? `[${first}..${last}]`\n        : 'no';\n    };\n    this.getLoopId = (): string => scroller.state.cycle.loopId;\n    this.getLoopIdNext = (): string => scroller.state.cycle.loopIdNext;\n    this.getWorkflowCycleData = (): string =>\n      `${settings.instanceIndex}-${scroller.state.cycle.count}`;\n    this.getScrollPosition = (element: HTMLElement) => scroller.routines.getScrollPosition(element);\n    this.log(() =>\n      'vscroll Workflow has been started, ' +\n      `core: ${packageInfo.core.name} v${packageInfo.core.version}, ` +\n      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}, ` +\n      `workflow instance: ${settings.instanceIndex}, adapter ` +\n      (!adapter ? 'is not instantiated' : `instance: ${adapter.id}`)\n    );\n  }\n\n  object(str: string, obj: unknown, stringify?: boolean): void {\n    this.log(() => [\n      str,\n      stringify\n        ? JSON.stringify(obj, (k, v) => {\n          if (Number.isNaN(v)) {\n            return 'NaN';\n          }\n          if (v === Infinity) {\n            return 'Infinity';\n          }\n          if (v === -Infinity) {\n            return '-Infinity';\n          }\n          if (v instanceof Element) {\n            return 'HTMLElement';\n          }\n          if (v instanceof HTMLDocument) {\n            return 'HTMLDocument';\n          }\n          if (typeof v === 'function') {\n            return 'Function';\n          }\n          return v;\n        })\n          .replace(/\"/g, '')\n          .replace(/(\\{|:|,)/g, '$1 ')\n          .replace(/(\\})/g, ' $1')\n        : obj\n    ]);\n  }\n\n  stat(str?: string): void {\n    if (this.debug) {\n      const logStyles = [\n        'color: #888; border: dashed #888 0; border-bottom-width: 0px',\n        'color: #000; border-width: 0'\n      ];\n      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);\n    }\n  }\n\n  fetch(str?: string): void {\n    if (this.debug) {\n      const _text = 'fetch interval' + (str ? ` ${str}` : '');\n      const logStyles = ['color: #888', 'color: #000'];\n      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);\n    }\n  }\n\n  prepareForLog(data: unknown): unknown {\n    return data instanceof Event && data.target\n      ? this.getScrollPosition(data.target as HTMLElement)\n      : data;\n  }\n\n  logProcess(data: ProcessSubject): void {\n    if (!this.debug) {\n      return;\n    }\n    const { process, status, payload } = data;\n\n    // inner loop start-end log\n    const loopLog: string[] = [];\n    if (\n      process === CommonProcess.init && status === Status.next\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);\n    } else if (\n      process === CommonProcess.end\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);\n      const parent = payload && payload.process;\n      if (status === Status.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {\n        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;\n      }\n    }\n    if (loopLog.length) {\n      this.log(() => [...loopLog, 'color: #006600;']);\n    }\n  }\n\n  logCycle(start = true): void {\n    const logData = this.getWorkflowCycleData();\n    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';\n    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;\n    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);\n  }\n\n  logError(str: string): void {\n    if (this.debug) {\n      const logStyles = ['color: #a00;', 'color: #000'];\n      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);\n    }\n  }\n\n  logAdapterMethod = (methodName: string, args?: unknown, add?: string): void => {\n    if (!this.debug) {\n      return;\n    }\n    const params = (\n      args === void 0 ? [] : (Array.isArray(args) ? args : [args])\n    )\n      .map((arg: unknown) => {\n        if (typeof arg === 'function') {\n          return 'func';\n        } else if (typeof arg !== 'object' || !arg) {\n          return arg;\n        } else if (Array.isArray(arg)) {\n          return `[of ${arg.length}]`;\n        }\n        return '{ ' + Object.keys(arg).join(', ') + ' }';\n      })\n      .join(', ');\n    this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);\n  }\n\n  log(...args: any[]): void {\n    if (this.debug) {\n      if (typeof args[0] === 'function') {\n        args = args[0]();\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n      }\n      if (args.every(item => item === void 0)) {\n        return;\n      }\n      if (this.logTime) {\n        args = [...args, this.getTime()];\n      }\n      args = args.map((arg: unknown) => this.prepareForLog(arg));\n      if (this.immediateLog) {\n        console.log.apply(this, args as LogType);\n      } else {\n        this.logs.push(args);\n      }\n    }\n  }\n\n  // logNow(...args: any[]) {\n  //   const immediateLog = this.immediateLog;\n  //   const debug = this.debug;\n  //   (this as any).debug = true;\n  //   (this as any).immediateLog = true;\n  //   this.log.apply(this, args);\n  //   (this as any).debug = debug;\n  //   (this as any).immediateLog = immediateLog;\n  // }\n\n  logForce(...args: unknown[]): void {\n    if (this.debug) {\n      if (!this.immediateLog && this.logs.length) {\n        this.logs.forEach(logArgs => console.log.apply(this, logArgs));\n        this.logs = [];\n      }\n      if (args.length) {\n        console.log.apply(this, args as LogType);\n      }\n    }\n  }\n}\n","import { Settings } from './settings';\nimport { Direction } from '../inputs/index';\n\nexport class Routines {\n\n  readonly horizontal: boolean;\n  readonly window: boolean;\n\n  constructor(settings: Settings) {\n    this.horizontal = settings.horizontal;\n    this.window = settings.windowViewport;\n  }\n\n  checkElement(element: HTMLElement): void {\n    if (!element) {\n      throw new Error('HTML element is not defined');\n    }\n  }\n\n  getScrollPosition(element: HTMLElement): number {\n    if (this.window) {\n      return window.pageYOffset;\n    }\n    this.checkElement(element);\n    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];\n  }\n\n  setScrollPosition(element: HTMLElement, value: number): void {\n    value = Math.max(0, value);\n    if (this.window) {\n      if (this.horizontal) {\n        window.scrollTo(value, window.scrollY);\n      } else {\n        window.scrollTo(window.scrollX, value);\n      }\n      return;\n    }\n    this.checkElement(element);\n    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;\n  }\n\n  getParams(element: HTMLElement, doNotBind?: boolean): ClientRect {\n    this.checkElement(element);\n    if (this.window && doNotBind) {\n      return {\n        'height': element.clientHeight,\n        'width': element.clientWidth,\n        'top': element.clientTop,\n        'bottom': element.clientTop + element.clientHeight,\n        'left': element.clientLeft,\n        'right': element.clientLeft + element.clientWidth\n      };\n    }\n    return element.getBoundingClientRect();\n  }\n\n  getSize(element: HTMLElement, doNotBind?: boolean): number {\n    return this.getParams(element, doNotBind)[this.horizontal ? 'width' : 'height'];\n  }\n\n  getSizeStyle(element: HTMLElement): number {\n    this.checkElement(element);\n    const size = element.style[this.horizontal ? 'width' : 'height'];\n    return parseFloat(size as string) || 0;\n  }\n\n  setSizeStyle(element: HTMLElement, value: number): void {\n    this.checkElement(element);\n    value = Math.max(0, Math.round(value));\n    element.style[this.horizontal ? 'width' : 'height'] = `${value}px`;\n  }\n\n  getEdge(element: HTMLElement, direction: Direction, doNotBind?: boolean): number {\n    const params = this.getParams(element, doNotBind);\n    const isFwd = direction === Direction.forward;\n    return params[isFwd ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];\n  }\n\n  getEdge2(element: HTMLElement, direction: Direction, relativeElement: HTMLElement, opposite: boolean): number {\n    // vertical only ?\n    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +\n      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);\n  }\n\n  hideElement(element: HTMLElement): void {\n    this.checkElement(element);\n    element.style.display = 'none';\n  }\n\n  getOffset(element: HTMLElement): number {\n    this.checkElement(element);\n    return (this.horizontal ? element.offsetLeft : element.offsetTop) || 0;\n  }\n\n  scrollTo(element: HTMLElement, argument?: boolean | ScrollIntoViewOptions): void {\n    this.checkElement(element);\n    element.scrollIntoView(argument);\n  }\n\n}\n","import { Routines } from './domRoutines';\r\nimport { Settings } from './settings';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport class Padding {\r\n\r\n  element: HTMLElement;\r\n  direction: Direction;\r\n  routines: Routines;\r\n\r\n  constructor(element: HTMLElement, direction: Direction, routines: Routines) {\r\n    this.element = element.querySelector(`[data-padding-${direction}]`) as HTMLElement;\r\n    this.direction = direction;\r\n    this.routines = routines;\r\n  }\r\n\r\n  reset(size?: number): void {\r\n    this.size = size || 0;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.routines.getSizeStyle(this.element);\r\n  }\r\n\r\n  set size(value: number) {\r\n    this.routines.setSizeStyle(this.element, value);\r\n  }\r\n\r\n}\r\n\r\nexport class Paddings {\r\n  settings: Settings;\r\n  forward: Padding;\r\n  backward: Padding;\r\n\r\n  constructor(element: HTMLElement, routines: Routines, settings: Settings) {\r\n    this.settings = settings;\r\n    this.forward = new Padding(element, Direction.forward, routines);\r\n    this.backward = new Padding(element, Direction.backward, routines);\r\n  }\r\n\r\n  byDirection(direction: Direction, opposite?: boolean): Padding {\r\n    return direction === Direction.backward\r\n      ? (opposite ? this.forward : this.backward)\r\n      : (opposite ? this.backward : this.forward);\r\n  }\r\n\r\n  reset(viewportSize: number, startIndex: number, offset: number): void {\r\n    const positive = this.getPositiveSize(startIndex, viewportSize, offset);\r\n    const negative = this.getNegativeSize(startIndex);\r\n    if (this.settings.inverse) {\r\n      this.forward.reset(negative);\r\n      this.backward.reset(positive);\r\n      const diff = viewportSize - this.backward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size += diff;\r\n        this.forward.size -= diff;\r\n      }\r\n    } else {\r\n      this.forward.reset(positive);\r\n      this.backward.reset(negative);\r\n      const diff = viewportSize - this.forward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size -= diff;\r\n        this.forward.size += diff;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  getPositiveSize(startIndex: number, viewportSize: number, offset: number): number {\r\n    const { settings } = this;\r\n    let positiveSize = viewportSize;\r\n    if (isFinite(settings.maxIndex)) {\r\n      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;\r\n    }\r\n    if (offset) {\r\n      positiveSize = Math.max(positiveSize - offset, 0);\r\n    }\r\n    return positiveSize;\r\n  }\r\n\r\n  getNegativeSize(startIndex: number): number {\r\n    const { settings } = this;\r\n    let negativeSize = 0;\r\n    if (isFinite(settings.minIndex)) {\r\n      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;\r\n    }\r\n    return negativeSize;\r\n  }\r\n}\r\n","import { Paddings } from './paddings';\nimport { Settings } from './settings';\nimport { Routines } from './domRoutines';\nimport { Item } from './item';\nimport { State } from './state';\nimport { Logger } from './logger';\nimport { Direction } from '../inputs/index';\n\nexport class Viewport {\n\n  offset: number;\n  paddings: Paddings;\n\n  readonly element: HTMLElement;\n  readonly settings: Settings;\n  readonly routines: Routines;\n  readonly state: State;\n  readonly logger: Logger;\n\n  readonly hostElement: HTMLElement;\n  readonly scrollEventReceiver: HTMLElement | Window;\n\n  private disabled: boolean;\n\n  constructor(element: HTMLElement, settings: Settings, routines: Routines, state: State, logger: Logger) {\n    this.element = element;\n    this.settings = settings;\n    this.routines = routines;\n    this.state = state;\n    this.logger = logger;\n    this.disabled = false;\n\n    if (settings.windowViewport) {\n      this.hostElement = document.documentElement as HTMLElement;\n      this.scrollEventReceiver = window;\n    } else {\n      this.hostElement = settings.viewport || this.element.parentElement as HTMLElement;\n      this.scrollEventReceiver = this.hostElement;\n    }\n\n    this.paddings = new Paddings(this.element, this.routines, settings);\n\n    if (settings.windowViewport && 'scrollRestoration' in history) {\n      history.scrollRestoration = 'manual';\n    }\n\n    if (settings.dismissOverflowAnchor) {\n      this.hostElement.style.overflowAnchor = 'none';\n    }\n  }\n\n  reset(startIndex: number): void {\n    this.setOffset();\n    this.paddings.reset(this.getSize(), startIndex, this.offset);\n    this.scrollPosition = this.paddings.backward.size || 0;\n    this.state.scrollState.reset();\n  }\n\n  setPosition(value: number): number {\n    const oldPosition = this.scrollPosition;\n    if (oldPosition === value) {\n      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);\n      return value;\n    }\n    this.routines.setScrollPosition(this.hostElement, value);\n    const position = this.scrollPosition;\n    this.logger.log(() => [\n      'setting scroll position at', position, ...(position !== value ? [`(${value})`] : [])\n    ]);\n    return position;\n  }\n\n  get scrollPosition(): number {\n    return this.routines.getScrollPosition(this.hostElement);\n  }\n\n  set scrollPosition(value: number) {\n    this.setPosition(value);\n  }\n\n  disableScrollForOneLoop(): void {\n    if (this.disabled) {\n      return;\n    }\n    const { style } = this.hostElement;\n    if (style.overflowY === 'hidden') {\n      return;\n    }\n    this.disabled = true;\n    const overflow = style.overflowY;\n    setTimeout(() => {\n      this.disabled = false;\n      style.overflowY = overflow;\n    });\n    style.overflowY = 'hidden';\n  }\n\n  getSize(): number {\n    return this.routines.getSize(this.hostElement, true);\n  }\n\n  getScrollableSize(): number {\n    return this.routines.getSize(this.element);\n  }\n\n  getBufferPadding(): number {\n    return this.getSize() * this.settings.padding;\n  }\n\n  getEdge(direction: Direction): number {\n    return this.routines.getEdge(this.hostElement, direction, true);\n  }\n\n  setOffset(): void {\n    this.offset = this.routines.getOffset(this.element);\n    if (!this.settings.windowViewport) {\n      this.offset -= this.routines.getOffset(this.hostElement);\n    }\n  }\n\n  getEdgeVisibleItem(items: Item[], direction: Direction): { item?: Item, index: number, diff: number } {\n    const bwd = direction === Direction.backward;\n    const opposite = bwd ? Direction.forward : Direction.backward;\n    const viewportEdge = this.getEdge(direction);\n    let item, diff = 0;\n    for (\n      let i = bwd ? 0 : items.length - 1;\n      bwd ? i <= items.length - 1 : i >= 0;\n      i += bwd ? 1 : -1\n    ) {\n      const itemEdge = this.routines.getEdge(items[i].element, opposite);\n      diff = itemEdge - viewportEdge;\n      if (bwd && diff > 0 || !bwd && diff < 0) {\n        item = items[i];\n        break;\n      }\n    }\n    return { item, index: item ? item.$index : NaN, diff };\n  }\n\n}\n","import { SizeStrategy } from '../../inputs/index';\n\ninterface ItemSize {\n  size: number;\n  newSize?: number;\n}\n\nexport class SizesRecalculation {\n  newItems: ItemSize[];\n  oldItems: ItemSize[];\n  removed: ItemSize[];\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.newItems = [];\n    this.oldItems = [];\n    this.removed = [];\n  }\n}\n\nexport class DefaultSize {\n  private readonly itemSize: number;\n  private readonly sizeStrategy: SizeStrategy;\n  private sizeMap: Map<number, number>;\n  private recalculation: SizesRecalculation;\n\n  private constantSize: number;\n  private frequentSize: number;\n  private averageSize: number;\n  private averageSizeFloat: number;\n\n  constructor(itemSize: number, sizeStrategy: SizeStrategy) {\n    this.itemSize = itemSize;\n    this.sizeStrategy = sizeStrategy;\n    this.sizeMap = new Map<number, number>();\n    this.recalculation = new SizesRecalculation();\n  }\n\n  reset(force: boolean): void {\n    if (force) {\n      this.constantSize = this.itemSize;\n      this.frequentSize = this.itemSize;\n      this.averageSize = this.itemSize;\n      this.averageSizeFloat = this.itemSize;\n      this.sizeMap.clear();\n    }\n    this.recalculation.reset();\n  }\n\n  get(): number {\n    switch (this.sizeStrategy) {\n      case SizeStrategy.Average:\n        return this.averageSize;\n      case SizeStrategy.Frequent:\n        return this.frequentSize;\n      default:\n        return this.constantSize;\n    }\n  }\n\n  private recalculateAverageSize(cacheSize: number): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (oldItems.length) {\n      const oldSize = oldItems.reduce((acc, item) => acc + item.size, 0);\n      const newSize = oldItems.reduce((acc, item) => acc + (item.newSize as number), 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = averageSize - (oldSize - newSize) / (cacheSize - newItems.length);\n    }\n    if (newItems.length) {\n      const newSize = newItems.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize - newItems.length) * averageSize + newSize) / cacheSize;\n    }\n    if (removed.length) {\n      const removedSize = removed.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize + removed.length) * averageSize - removedSize) / cacheSize;\n    }\n    this.averageSize = Math.round(this.averageSizeFloat);\n  }\n\n  private recalculateFrequentSize(): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    const oldFrequentSizeCount = this.sizeMap.get(this.frequentSize);\n    if (newItems.length) {\n      newItems.forEach(({ size }) => this.sizeMap.set(size, (this.sizeMap.get(size) || 0) + 1));\n    }\n    if (oldItems.length) {\n      oldItems.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n      oldItems.forEach(({ newSize: s }) => this.sizeMap.set(s as number, (this.sizeMap.get(s as number) || 0) + 1));\n    }\n    if (removed.length) {\n      removed.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n    }\n    const sorted = [...this.sizeMap.entries()].sort((a, b) => b[1] - a[1]);\n    const mostFrequentCount = sorted[0][1];\n    const listEqual = sorted.filter(i => i[1] === mostFrequentCount);\n    if (listEqual.length > 1 && listEqual.find(i => i[0] === oldFrequentSizeCount)) {\n      // if there are more than 1 most frequent sizes, but the old one is present\n      return;\n    }\n    this.frequentSize = sorted[0][0];\n  }\n\n  recalculate(cacheSize: number): boolean {\n    if (this.sizeStrategy === SizeStrategy.Constant) {\n      return false;\n    }\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (!oldItems.length && !newItems.length && !removed.length) {\n      return false;\n    }\n    const oldValue = this.get();\n    if (this.sizeStrategy === SizeStrategy.Average) {\n      this.recalculateAverageSize(cacheSize);\n    } else {\n      this.recalculateFrequentSize();\n    }\n    this.recalculation.reset();\n    return this.get() !== oldValue;\n  }\n\n  setExisted(oldItem: ItemSize, newItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.oldItems.push({\n        size: oldItem.size,\n        newSize: newItem.size\n      });\n    }\n  }\n\n  setNew(newItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.newItems.push({\n        size: newItem.size\n      });\n    } else {\n      if (!this.constantSize) {\n        this.constantSize = newItem.size;\n      }\n    }\n  }\n\n  setRemoved(oldItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.removed.push({\n        size: oldItem.size\n      });\n    }\n  }\n}\n","import { DefaultSize } from './defaultSize';\nimport { Item } from '../item';\nimport { Settings } from '../settings';\nimport { Logger } from '../logger';\nimport { SizeStrategy } from '../../inputs/index';\n\nexport class ItemCache<Data = unknown> {\n  $index: number;\n  nodeId: string;\n  data: Data | null;\n  size: number;\n  position: number;\n\n  constructor(item: Item<Data>, saveData: boolean) {\n    this.$index = item.$index;\n    this.nodeId = item.nodeId;\n    this.data = saveData ? item.data : null;\n    this.size = item.size;\n  }\n\n  changeIndex(value: number): void {\n    this.$index = value;\n    this.nodeId = String(value);\n  }\n}\n\nexport class Cache<Data = unknown> {\n  minIndex: number;\n  maxIndex: number;\n\n  readonly itemSize: number;\n  readonly saveData: boolean;\n  readonly cacheOnReload: boolean;\n  readonly sizeStrategy: SizeStrategy;\n  readonly logger: Logger;\n  private items: Map<number, ItemCache<Data>>;\n  private defaultSize: DefaultSize;\n\n  constructor({ itemSize, cacheData, cacheOnReload, sizeStrategy }: Settings, logger: Logger) {\n    this.itemSize = itemSize;\n    this.saveData = cacheData;\n    this.cacheOnReload = cacheOnReload;\n    this.sizeStrategy = sizeStrategy;\n    this.logger = logger;\n    this.items = new Map<number, ItemCache<Data>>();\n    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);\n    this.reset(true);\n  }\n\n  reset(force: boolean): void {\n    force = force || !this.cacheOnReload;\n    if (force) {\n      this.minIndex = +Infinity;\n      this.maxIndex = -Infinity;\n      this.items.clear();\n    }\n    this.defaultSize.reset(force);\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  get(index: number): ItemCache<Data> | undefined {\n    return this.items.get(index);\n  }\n\n  getItemSize(index: number): number {\n    const item = this.get(index);\n    return item ? item.size : 0;\n  }\n\n  getDefaultSize(): number {\n    return this.defaultSize.get();\n  }\n\n  recalculateDefaultSize(): boolean {\n    if (this.defaultSize.recalculate(this.size)) {\n      this.logger.log(() => `default size has been updated: ${this.defaultSize.get()}`);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Adds item to Set by $index, replaces existed item if $index matches.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.\n   * \n   * @returns {ItemCache<Data>} Cached item.\n   */\n  add(item: Item<Data>): ItemCache<Data> {\n    let itemCache = this.get(item.$index);\n    if (itemCache) { // adding item is already cached\n      if (this.saveData) {\n        itemCache.data = item.data;\n      }\n      if (itemCache.size !== item.size) { // size changes\n        if (itemCache.size !== void 0) {\n          this.defaultSize.setExisted(itemCache, item);\n        } else {\n          this.defaultSize.setNew(item);\n        }\n        itemCache.size = item.size;\n      }\n    } else {\n      itemCache = new ItemCache<Data>(item, this.saveData);\n      this.items.set(item.$index, itemCache);\n      this.defaultSize.setNew(itemCache);\n    }\n    if (item.$index < this.minIndex) {\n      this.minIndex = item.$index;\n    }\n    if (item.$index > this.maxIndex) {\n      this.maxIndex = item.$index;\n    }\n    return itemCache;\n  }\n\n  /**\n   * Removes items from Set, shifts $indexes of items that remain.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {number[]} toRemove List of indexes to be removed.\n   * @param {boolean} fixRight Defines indexes shifting strategy.\n   * If false, indexes that are greater than the removed ones will be decreased.\n   * If true, indexes that are less than than the removed ones will be increased.\n   */\n  removeItems(toRemove: number[], fixRight: boolean): void {\n    const items = new Map<number, ItemCache<Data>>();\n    let min = Infinity, max = -Infinity;\n    this.items.forEach(item => {\n      if (toRemove.some(index => index === item.$index)) {\n        if (item.size !== void 0) {\n          this.defaultSize.setRemoved(item);\n        }\n        return;\n      }\n      const diff = fixRight\n        ? toRemove.reduce((acc, index) => acc + (item.$index < index ? 1 : 0), 0)\n        : toRemove.reduce((acc, index) => acc - (item.$index > index ? 1 : 0), 0);\n      item.changeIndex(item.$index + diff);\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    });\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n\n  /**\n   * Destructively updates Set based on subset (before-after) changes.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes. Maintains default item size on remove only.\n   * Inserted and replaced items will be taken into account on Cache.add async calls after render.\n   *\n   * @param {number[]} before Initial subset of indexes to be replaced by \"after\". Must be incremental.\n   * @param {Item<Data>[]} after Transformed subset that replaces \"before\". Must be be $index-incremental.\n   * Must contain at least 1 $index from \"before\" or be empty.\n   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if \"after\" is empty.\n   */\n  updateSubset(before: number[], after: Item<Data>[], fixRight?: boolean): void {\n    if (!this.size || !before.length) {\n      return;\n    }\n    const minB = before[0], maxB = before[before.length - 1];\n    let leftDiff: number, rightDiff: number, found;\n    if (after.length) {\n      const minA = after[0].$index, maxA = after[after.length - 1].$index;\n      leftDiff = minA - minB;\n      rightDiff = maxA - maxB;\n    } else {\n      leftDiff = fixRight ? maxB - minB + 1 : 0;\n      rightDiff = fixRight ? 0 : minB - maxB - 1;\n    }\n    const items = new Map<number, ItemCache<Data>>();\n    this.items.forEach(item => {\n      if (item.$index < minB) { // items to the left of the subset\n        item.changeIndex(item.$index + leftDiff);\n        items.set(item.$index, item);\n        return;\n      } else if (item.$index > maxB) { // items to the right of the subset\n        item.changeIndex(item.$index + rightDiff);\n        items.set(item.$index, item);\n        return;\n      }\n    });\n    after.forEach(item => // subset items\n      items.set(item.$index, new ItemCache<Data>(item, this.saveData))\n    );\n    before.forEach(index => { // removed items immediately affect the default size\n      if (!after.some(({ $index }) => index === $index) && (found = this.get(index))) {\n        this.defaultSize.setRemoved(found);\n      }\n    });\n    this.minIndex += leftDiff;\n    this.maxIndex += rightDiff;\n    this.items = items;\n  }\n}\n","import { Cache } from './buffer/cache';\nimport { Item } from './item';\nimport { Settings } from './settings';\nimport { Logger } from './logger';\nimport { Reactive } from './reactive';\nimport { Direction } from '../inputs/index';\nimport { OnDataChanged, BufferUpdater } from '../interfaces/index';\n\nexport class Buffer<Data> {\n\n  private _items: Item<Data>[] = [];\n  private _absMinIndex: number;\n  private _absMaxIndex: number;\n  bof: Reactive<boolean>;\n  eof: Reactive<boolean>;\n\n  changeItems: OnDataChanged<Data>;\n  minIndexUser: number;\n  maxIndexUser: number;\n  startIndexUser: number;\n  startIndex: number;\n\n  private pristine: boolean;\n  private cache: Cache<Data>;\n  private readonly logger: Logger;\n\n  constructor(settings: Settings<Data>, onDataChanged: OnDataChanged<Data>, logger: Logger) {\n    this.logger = logger;\n    this.changeItems = onDataChanged;\n    this.bof = new Reactive<boolean>(false);\n    this.eof = new Reactive<boolean>(false);\n    this.cache = new Cache<Data>(settings, logger);\n    this.startIndexUser = settings.startIndex;\n    this.minIndexUser = settings.minIndex;\n    this.maxIndexUser = settings.maxIndex;\n    this.reset(true);\n  }\n\n  dispose(): void {\n    this.bof.dispose();\n    this.eof.dispose();\n    this._items.forEach(item => item.dispose());\n    this._items = [];\n  }\n\n  reset(force: boolean, startIndex?: number): void {\n    this.items.forEach(item => item.hide());\n    this.pristine = true;\n    this.items = [];\n    this.cache.reset(force);\n    this.absMinIndex = this.minIndexUser;\n    this.absMaxIndex = this.maxIndexUser;\n    this.setCurrentStartIndex(startIndex);\n    this.bof.set(false);\n    this.eof.set(false);\n    this.pristine = false;\n  }\n\n  setCurrentStartIndex(newStartIndex?: unknown): void {\n    const min = this.minIndexUser;\n    const max = this.maxIndexUser;\n    const start = this.startIndexUser;\n    let index = Number(newStartIndex);\n    if (Number.isNaN(index)) {\n      this.logger.log(() => `fallback startIndex to settings.startIndex (${start})`);\n      index = start;\n    }\n    if (index < min) {\n      this.logger.log(() => `setting startIndex to settings.minIndex (${min}) because ${index} < ${min}`);\n      index = min;\n    }\n    if (index > max) {\n      this.logger.log(() => `setting startIndex to settings.maxIndex (${max}) because ${index} > ${max}`);\n      index = max;\n    }\n    this.startIndex = index;\n  }\n\n  set items(items: Item<Data>[]) {\n    this._items = items;\n    this.changeItems(items);\n    if (!this.pristine) {\n      this.checkBOF();\n      this.checkEOF();\n    }\n  }\n\n  get items(): Item<Data>[] {\n    return this._items;\n  }\n\n  set absMinIndex(value: number) {\n    if (this._absMinIndex !== value) {\n      this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkBOF();\n    }\n  }\n\n  get absMinIndex(): number {\n    return this._absMinIndex;\n  }\n\n  set absMaxIndex(value: number) {\n    if (this._absMaxIndex !== value) {\n      this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkEOF();\n    }\n  }\n\n  get absMaxIndex(): number {\n    return this._absMaxIndex;\n  }\n\n  private checkBOF() {\n    // since bof has no setter, need to call checkBOF() on items and absMinIndex change\n    const bof = this.items.length\n      ? (this.items[0].$index === this.absMinIndex)\n      : isFinite(this.absMinIndex);\n    this.bof.set(bof);\n  }\n\n  private checkEOF() {\n    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change\n    const eof = this.items.length\n      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)\n      : isFinite(this.absMaxIndex);\n    this.eof.set(eof);\n  }\n\n  get size(): number {\n    return this._items.length;\n  }\n\n  get cacheSize(): number {\n    return this.cache.size;\n  }\n\n  get defaultSize(): number {\n    return this.cache.getDefaultSize();\n  }\n\n  get minIndex(): number {\n    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;\n  }\n\n  get maxIndex(): number {\n    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;\n  }\n\n  get firstIndex(): number {\n    return this.items.length ? this.items[0].$index : NaN;\n  }\n\n  get lastIndex(): number {\n    return this.items.length ? this.items[this.items.length - 1].$index : NaN;\n  }\n\n  get finiteAbsMinIndex(): number {\n    return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;\n  }\n\n  get finiteAbsMaxIndex(): number {\n    return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;\n  }\n\n  get($index: number): Item<Data> | undefined {\n    return this.items.find(item => item.$index === $index);\n  }\n\n  setItems(items: Item<Data>[]): boolean {\n    if (!this.items.length) {\n      this.items = [...items];\n    } else if (this.items[0].$index > items[items.length - 1].$index) {\n      this.items = [...items, ...this.items];\n    } else if (items[0].$index > this.items[this.items.length - 1].$index) {\n      this.items = [...this.items, ...items];\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  clip(): void {\n    this.items = this.items.filter(({ toRemove }) => !toRemove);\n  }\n\n  append(items: Item<Data>[]): void {\n    this.items = [...this.items, ...items];\n  }\n\n  prepend(items: Item<Data>[]): void {\n    this.items = [...items, ...this.items];\n  }\n\n  private shiftExtremum(amount: number, fixRight: boolean) {\n    if (!fixRight) {\n      this.absMaxIndex += amount;\n    } else {\n      this.absMinIndex -= amount;\n      this.startIndex -= amount;\n    }\n    if (this.startIndex > this.absMaxIndex) {\n      this.startIndex = this.absMaxIndex;\n    } else if (this.startIndex < this.absMinIndex) {\n      this.startIndex = this.absMinIndex;\n    }\n  }\n\n  removeItems(indexes: number[], fixRight: boolean, virtual = false): void {\n    const result: Item<Data>[] = [];\n    const toRemove: number[] = virtual ? indexes : [];\n    const length = this.items.length;\n    let shifted = false;\n    for (\n      let i = fixRight ? length - 1 : 0;\n      fixRight ? i >= 0 : i < length;\n      fixRight ? i-- : i++\n    ) {\n      const item = this.items[i];\n      if (!virtual && indexes.indexOf(item.$index) >= 0) {\n        toRemove.push(item.$index);\n        continue;\n      }\n      const diff = toRemove.reduce((acc, index) => acc + (fixRight\n        ? (item.$index < index ? 1 : 0)\n        : (item.$index > index ? -1 : 0)\n      ), 0);\n      shifted = shifted || !!diff;\n      item.updateIndex(item.$index + diff);\n      if (!virtual) {\n        if (fixRight) {\n          result.unshift(item);\n        } else {\n          result.push(item);\n        }\n      }\n    }\n    this.shiftExtremum(-toRemove.length, fixRight);\n    if (!virtual) {\n      this.items = result;\n    } else if (shifted) {\n      this.items = [...this.items];\n    }\n    this.cache.removeItems(toRemove, fixRight);\n  }\n\n  updateItems(\n    predicate: BufferUpdater<Data>,\n    generator: (index: number, data: Data) => Item<Data>,\n    indexToTrack: number,\n    fixRight: boolean\n  ): number {\n    if (!this.size || Number.isNaN(this.firstIndex)) {\n      return NaN;\n    }\n    let _indexToTrack = indexToTrack;\n    let index = fixRight ? this.lastIndex : this.firstIndex;\n    const items: Item<Data>[] = [];\n    const diff = fixRight ? -1 : 1;\n    const initialIndexList = this.items.map(({ $index }) => $index);\n    (fixRight ? this.items.reverse() : this.items).forEach(item => {\n      const result = predicate(item);\n      // if predicate result is falsy or empty array -> delete\n      if (!result || (Array.isArray(result) && !result.length)) {\n        item.toRemove = true;\n        _indexToTrack += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);\n        this.shiftExtremum(-1, fixRight);\n        return;\n      }\n      // if predicate result is truthy but not array -> leave\n      if (!Array.isArray(result)) {\n        item.updateIndex(index);\n        items.push(item);\n        index += diff;\n        return;\n      }\n      // if predicate result is non-empty array -> insert/replace\n      if (item.$index < indexToTrack) {\n        _indexToTrack += fixRight ? 0 : result.length - 1;\n      } else if (item.$index > indexToTrack) {\n        _indexToTrack += fixRight ? 1 - result.length : 0;\n      }\n      let toRemove = true;\n      const newItems: Item<Data>[] = [];\n      (fixRight ? [...result].reverse() : result).forEach((data, i) => {\n        let newItem: Item<Data>;\n        if (item.data === data) {\n          if (indexToTrack === item.$index) {\n            _indexToTrack = index + i * diff;\n          }\n          item.updateIndex(index + i * diff);\n          newItem = item;\n          toRemove = false; // insert case\n        } else {\n          newItem = generator(index + i * diff, data);\n          newItem.toInsert = true;\n        }\n        newItems.push(newItem);\n      });\n      item.toRemove = toRemove;\n      items.push(...newItems);\n      index += diff * result.length;\n      if (result.length > 1) {\n        this.shiftExtremum(result.length - 1, fixRight);\n      }\n    });\n    this.items = fixRight ? items.reverse() : items;\n    this.cache.updateSubset(initialIndexList, this.items, fixRight);\n\n    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {\n      _indexToTrack = NaN;\n    } else if (_indexToTrack > this.finiteAbsMaxIndex) {\n      _indexToTrack = this.finiteAbsMaxIndex;\n    } else if (_indexToTrack < this.finiteAbsMinIndex) {\n      _indexToTrack = this.finiteAbsMinIndex;\n    }\n    return _indexToTrack;\n  }\n\n  cacheItem(item: Item<Data>): void {\n    this.cache.add(item);\n  }\n\n  getFirstVisibleItemIndex(): number {\n    const length = this.items.length;\n    for (let i = 0; i < length; i++) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getLastVisibleItemIndex(): number {\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getFirstVisibleItem(): Item<Data> | undefined {\n    const index = this.getFirstVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getLastVisibleItem(): Item<Data> | undefined {\n    const index = this.getLastVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getEdgeVisibleItem(direction: Direction, opposite?: boolean): Item<Data> | undefined {\n    return direction === (!opposite ? Direction.forward : Direction.backward) ?\n      this.getLastVisibleItem() : this.getFirstVisibleItem();\n  }\n\n  getVisibleItemsCount(): number {\n    return this.items.reduce((acc: number, item) => acc + (item.invisible ? 0 : 1), 0);\n  }\n\n  getSizeByIndex(index: number): number {\n    const item = this.cache.get(index);\n    return item ? item.size : this.defaultSize;\n  }\n\n  checkDefaultSize(): boolean {\n    return this.cache.recalculateDefaultSize();\n  }\n\n  getIndexToAppend(eof?: boolean): number {\n    return (!eof\n      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)\n      : this.absMaxIndex\n    ) + (this.size ? 1 : 0);\n  }\n\n  getIndexToPrepend(bof?: boolean): number {\n    return (!bof\n      ? (this.size ? this.items[0].$index : this.minIndex)\n      : this.absMinIndex\n    ) - (this.size ? 1 : 0);\n  }\n\n  getIndexToAdd(eof: boolean, prepend: boolean): number {\n    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);\n  }\n\n}\n","import { ProcessName } from '../../interfaces/index';\nimport { Reactive } from '../reactive';\n\nclass InnerLoopModel {\n  total: number;\n  count: number;\n  isInitial: boolean;\n  busy: Reactive<boolean>;\n\n  get first(): boolean {\n    return this.count === 0;\n  }\n\n  constructor(total: number) {\n    this.total = total;\n    this.isInitial = false;\n    this.busy = new Reactive<boolean>(false);\n  }\n\n  done() {\n    this.count++;\n    this.total++;\n    this.busy.set(false);\n  }\n\n  start() {\n    this.busy.set(true);\n  }\n\n  dispose() {\n    this.busy.dispose();\n  }\n}\n\nexport class WorkflowCycleModel {\n  instanceIndex: number;\n  count: number;\n  isInitial: boolean;\n  initiator: ProcessName;\n  innerLoop: InnerLoopModel;\n  interrupter: ProcessName | null;\n  busy: Reactive<boolean>;\n\n  get loopId(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total}`;\n  }\n\n  get loopIdNext(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total + 1}`;\n  }\n\n  constructor(instanceIndex: number, cycle?: WorkflowCycleModel) {\n    const cycleCount = cycle ? cycle.count : 1;\n    const loopCount = cycle ? cycle.innerLoop.count : 0;\n\n    this.instanceIndex = instanceIndex;\n    this.innerLoop = new InnerLoopModel(loopCount);\n    this.interrupter = null;\n    this.busy = new Reactive<boolean>(false);\n    this.done(cycleCount);\n  }\n\n  done(count: number): void {\n    this.count = count;\n    this.isInitial = false;\n    this.busy.set(false);\n  }\n\n  start(isInitial: boolean, initiator: ProcessName): void {\n    this.isInitial = isInitial;\n    this.initiator = initiator;\n    this.innerLoop.isInitial = isInitial;\n    this.innerLoop.count = 0;\n    this.interrupter = null;\n    this.busy.set(true);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) {\n      // otherwise the value will be persisted during re-instantiation\n      this.busy.dispose();\n    }\n    this.innerLoop.dispose();\n  }\n}\n","import { Item } from '../item';\nimport { Direction } from '../../inputs/index';\n\nclass Positions {\n  startDelta: number;\n  before: number;\n  relative: number;\n  start: number;\n  end: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.startDelta = 0;\n    this.before = 0;\n  }\n}\n\nclass First {\n  index: number;\n  indexBuffer: number;\n  position: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n    this.position = NaN;\n  }\n}\n\nclass Last {\n  index: number;\n  indexBuffer: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n  }\n}\n\nexport class FetchModel {\n  private _newItemsData: unknown[] | null;\n\n  items: Item[];\n  positions: Positions;\n  first: First;\n  last: Last;\n  hasAnotherPack: boolean;\n  callCount: number;\n  minIndex: number;\n  firstVisibleIndex: number;\n  firstVisibleItemDelta: number;\n  negativeSize: number;\n  direction: Direction | null;\n  cancel: (() => void) | null;\n\n  simulate: boolean;\n  isPrepend: boolean;\n  isCheck: boolean;\n  doRemove: boolean;\n\n  constructor() {\n    this.callCount = 0;\n    this.positions = new Positions();\n    this.first = new First();\n    this.last = new Last();\n    this.reset();\n  }\n\n  reset(): void {\n    this._newItemsData = null;\n    this.items = [];\n    this.positions.reset();\n    this.first.reset();\n    this.last.reset();\n    this.hasAnotherPack = false;\n    this.firstVisibleIndex = NaN;\n    this.firstVisibleItemDelta = NaN;\n    this.negativeSize = 0;\n    this.direction = null;\n    this.cancel = null;\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  get newItemsData(): unknown[] | null {\n    return this._newItemsData;\n  }\n\n  set newItemsData(items: unknown[] | null) {\n    this._newItemsData = items;\n    if (items && items.length) {\n      this.callCount++;\n    }\n  }\n\n  get shouldFetch(): boolean {\n    return !!this.count;\n  }\n\n  get hasNewItems(): boolean {\n    return !!((this._newItemsData && this._newItemsData.length));\n  }\n\n  get index(): number {\n    return this.first.index;\n  }\n\n  get count(): number {\n    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;\n  }\n\n  startSimulate(items: Item[]): void {\n    this.simulate = true;\n    this._newItemsData = items.map(item => item.data);\n    this.items = items;\n    this.hasAnotherPack = false;\n    this.negativeSize = 0;\n  }\n\n  stopSimulate(): void {\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  append(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[items.length - 1].$index;\n    this.first.index = items[0].$index;\n    this.direction = Direction.forward;\n  }\n\n  prepend(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.direction = Direction.backward;\n    this.isPrepend = true;\n  }\n\n  check(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.isCheck = true;\n  }\n\n  remove(): void {\n    this.startSimulate([]);\n    this.doRemove = true;\n    // firstVisibleIndex & delta should be set inside process\n  }\n\n  update(index: number, delta: number, items: Item[], itemsToRemove: Item[]): void {\n    this.startSimulate(items);\n    this.firstVisibleIndex = index;\n    this.firstVisibleItemDelta = delta;\n    this.doRemove = itemsToRemove.length > 0;\n  }\n}\n","export class ClipModel {\n  doClip: boolean;\n  callCount: number;\n  forceForward: boolean;\n  forceBackward: boolean;\n\n  get force(): boolean {\n    return this.forceForward || this.forceBackward;\n  }\n\n  constructor() {\n    this.callCount = 0;\n    this.reset();\n  }\n\n  reset(force?: boolean): void {\n    this.doClip = false;\n    if (!force) {\n      this.forceForward = false;\n      this.forceBackward = false;\n    }\n  }\n\n}\n","export class RenderModel {\n  sizeBefore: number;\n  sizeAfter: number;\n  positionBefore: number;\n  renderTimer: ReturnType<typeof setTimeout> | null;\n\n  get noSize(): boolean {\n    return this.sizeBefore === this.sizeAfter;\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.sizeBefore = 0;\n    this.sizeAfter = 0;\n    this.positionBefore = 0;\n    this.renderTimer = null;\n  }\n}\n","import {\n  ScrollEventData as IScrollEventData,\n  ScrollState as IScrollState\n} from '../../interfaces/index';\n\nexport class ScrollState implements IScrollState {\n  previous: IScrollEventData | null;\n  current: IScrollEventData | null;\n\n  scrollTimer: ReturnType<typeof setTimeout> | null;\n\n  syntheticPosition: number | null;\n  syntheticFulfill: boolean;\n  animationFrameId: number;\n  positionBeforeAsync: number | null;\n  positionBeforeAdjust: number | null;\n  positionAfterAdjust: number | null;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.previous = null;\n    this.current = null;\n    this.syntheticPosition = null;\n    this.syntheticFulfill = false;\n    this.positionBeforeAsync = null;\n    this.positionBeforeAdjust = null;\n    this.positionAfterAdjust = null;\n    this.cleanupTimers();\n  }\n\n  cleanupTimers(): void {\n    if (this.scrollTimer) {\n      clearTimeout(this.scrollTimer);\n      this.scrollTimer = null;\n    }\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = 0;\n    }\n  }\n\n  hasPositionChanged(position: number): boolean {\n    const before = this.positionBeforeAdjust;\n    const after = this.positionAfterAdjust;\n    return before === null || before !== position || after === null || after !== position;\n  }\n}\n","import { Settings } from './settings';\r\nimport { WorkflowCycleModel } from './state/cycle';\r\nimport { FetchModel } from './state/fetch';\r\nimport { ClipModel } from './state/clip';\r\nimport { RenderModel } from './state/render';\r\nimport { ScrollState } from './state/scroll';\r\nimport { State as IState, IPackages, ScrollState as IScrollState, ProcessName } from '../interfaces/index';\r\n\r\nexport class State implements IState {\r\n\r\n  readonly packageInfo: IPackages;\r\n  private settings: Settings;\r\n\r\n  initTime: number;\r\n\r\n  cycle: WorkflowCycleModel;\r\n\r\n  fetch: FetchModel;\r\n  clip: ClipModel;\r\n  render: RenderModel;\r\n\r\n  scrollState: IScrollState;\r\n\r\n  get time(): number {\r\n    return Number(new Date()) - this.initTime;\r\n  }\r\n\r\n  constructor(packageInfo: IPackages, settings: Settings, state?: IState) {\r\n    this.packageInfo = packageInfo;\r\n    this.settings = settings;\r\n\r\n    this.initTime = Number(new Date());\r\n\r\n    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);\r\n\r\n    this.fetch = new FetchModel();\r\n    this.clip = new ClipModel();\r\n    this.render = new RenderModel();\r\n\r\n    this.scrollState = new ScrollState();\r\n  }\r\n\r\n  endInnerLoop(): void {\r\n    const { fetch, render, cycle } = this;\r\n    if (fetch.cancel) {\r\n      fetch.cancel();\r\n      fetch.cancel = null;\r\n    }\r\n    if (render.renderTimer) {\r\n      clearTimeout(render.renderTimer);\r\n      render.renderTimer = null;\r\n    }\r\n    cycle.innerLoop.done();\r\n  }\r\n\r\n  startInnerLoop(): { process?: ProcessName, doRender?: boolean } {\r\n    const { cycle, scrollState: scroll, fetch, render, clip } = this;\r\n\r\n    cycle.innerLoop.start();\r\n    scroll.positionBeforeAsync = null;\r\n\r\n    if (!fetch.simulate) {\r\n      fetch.reset();\r\n    }\r\n    clip.reset(clip.force);\r\n    render.reset();\r\n\r\n    return {\r\n      ...(cycle.innerLoop.first ? {\r\n        process: cycle.initiator,\r\n        doRender: fetch.simulate && fetch.items.length > 0\r\n      } : {})\r\n    };\r\n  }\r\n\r\n  dispose(): void {\r\n    this.cycle.dispose();\r\n    this.endInnerLoop();\r\n    this.scrollState.cleanupTimers();\r\n  }\r\n\r\n}\r\n","import { Logger } from './logger';\r\nimport { Buffer } from './buffer';\r\nimport { Reactive } from './reactive';\r\nimport {\r\n  AdapterPropName, AdapterPropType, getDefaultAdapterProps, methodPreResult, reactiveConfigStorage\r\n} from './adapter/props';\r\nimport { AdapterProcess, ProcessStatus } from '../processes/index';\r\nimport {\r\n  WorkflowGetter,\r\n  IAdapterProp,\r\n  AdapterMethodResult,\r\n  IAdapter,\r\n  ItemAdapter,\r\n  ItemsPredicate,\r\n  AdapterPrependOptions,\r\n  AdapterAppendOptions,\r\n  AdapterRemoveOptions,\r\n  AdapterClipOptions,\r\n  AdapterInsertOptions,\r\n  AdapterReplaceOptions,\r\n  AdapterUpdateOptions,\r\n  AdapterFixOptions,\r\n  ScrollerWorkflow,\r\n  IDatasourceOptional,\r\n  IPackages,\r\n  IBufferInfo,\r\n  State,\r\n  ProcessSubject,\r\n} from '../interfaces/index';\r\n\r\ntype MethodResolver = (...args: any[]) => Promise<AdapterMethodResult>;\r\n\r\nconst ADAPTER_PROPS_STUB = getDefaultAdapterProps();\r\n\r\nconst _has = (obj: unknown, prop: string): boolean =>\r\n  typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\nconst convertAppendArgs = <Item>(prepend: boolean, options: unknown, eof?: boolean) => {\r\n  let result = options as AdapterAppendOptions<Item> & AdapterPrependOptions<Item>;\r\n  if (!_has(options, 'items')) {\r\n    const items = !Array.isArray(options) ? [options] : options;\r\n    result = prepend ? { items, bof: eof } : { items, eof: eof };\r\n  }\r\n  return result;\r\n};\r\n\r\nconst convertRemoveArgs = <Item>(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>) => {\r\n  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {\r\n    const predicate = options as ItemsPredicate<Item>;\r\n    options = { predicate };\r\n  }\r\n  return options;\r\n};\r\n\r\nexport class Adapter<Item = unknown> implements IAdapter<Item> {\r\n  private externalContext: IAdapter<Item>;\r\n  private logger: Logger;\r\n  private getWorkflow: WorkflowGetter<Item>;\r\n  private reloadCounter: number;\r\n  private source: { [key: string]: Reactive<unknown> } = {}; // for Reactive props\r\n  private box: { [key: string]: unknown } = {}; // for Scalars over Reactive props\r\n  private demand: { [key: string]: unknown } = {}; // for Scalars on demand\r\n  public wanted: { [key: string]: boolean } = {};\r\n\r\n  get workflow(): ScrollerWorkflow<Item> {\r\n    return this.getWorkflow();\r\n  }\r\n  get reloadCount(): number {\r\n    return this.reloadCounter;\r\n  }\r\n  get reloadId(): string {\r\n    return this.id + '.' + this.reloadCounter;\r\n  }\r\n\r\n  id: number;\r\n  mock: boolean;\r\n  augmented: boolean;\r\n  version: string;\r\n  init: boolean;\r\n  init$: Reactive<boolean>;\r\n  packageInfo: IPackages;\r\n  itemsCount: number;\r\n  bufferInfo: IBufferInfo;\r\n  isLoading: boolean;\r\n  isLoading$: Reactive<boolean>;\r\n  loopPending: boolean;\r\n  loopPending$: Reactive<boolean>;\r\n  firstVisible: ItemAdapter<Item>;\r\n  firstVisible$: Reactive<ItemAdapter<Item>>;\r\n  lastVisible: ItemAdapter<Item>;\r\n  lastVisible$: Reactive<ItemAdapter<Item>>;\r\n  bof: boolean;\r\n  bof$: Reactive<boolean>;\r\n  eof: boolean;\r\n  eof$: Reactive<boolean>;\r\n\r\n  private relax$: Reactive<AdapterMethodResult> | null;\r\n  private relaxRun: Promise<AdapterMethodResult> | null;\r\n\r\n  private getPromisifiedMethod(method: MethodResolver, defaultMethod: MethodResolver) {\r\n    return (...args: any[]): Promise<AdapterMethodResult> =>\r\n      this.relax$\r\n        ? new Promise(resolve => {\r\n          if (this.relax$) {\r\n            this.relax$.once(value => resolve(value));\r\n          }\r\n          method.apply(this, args);\r\n        })\r\n        : defaultMethod.apply(this, args);\r\n  }\r\n\r\n  constructor(context: IAdapter<Item> | null, getWorkflow: WorkflowGetter<Item>, logger: Logger) {\r\n    this.getWorkflow = getWorkflow;\r\n    this.logger = logger;\r\n    this.relax$ = null;\r\n    this.relaxRun = null;\r\n    this.reloadCounter = 0;\r\n\r\n    // public context (if exists) should provide access Reactive props configuration by id\r\n    const reactivePropsStore = context && reactiveConfigStorage.get(context.id) || {};\r\n\r\n    // make array of the original values from public context if present\r\n    const adapterProps = context\r\n      ? ADAPTER_PROPS_STUB.map(prop => {\r\n        let value = context[prop.name];\r\n        // if context is augmented, we need to replace external reactive props with inner ones\r\n        if (context.augmented) {\r\n          const reactiveProp = reactivePropsStore[prop.name];\r\n          if (reactiveProp) {\r\n            value = reactiveProp.default as Reactive<boolean>; // boolean doesn't matter here\r\n          }\r\n        }\r\n        return ({ ...prop, value });\r\n      })\r\n      : getDefaultAdapterProps();\r\n\r\n    // restore default reactive props if they were configured\r\n    Object.entries(reactivePropsStore).forEach(([key, value]) => {\r\n      const prop = adapterProps.find(({ name }) => name === key);\r\n      if (prop && value) {\r\n        prop.value = value.default;\r\n      }\r\n    });\r\n\r\n    // Scalar permanent props\r\n    adapterProps\r\n      .filter(({ type, permanent }) => type === AdapterPropType.Scalar && permanent)\r\n      .forEach(({ name, value }: IAdapterProp) =>\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => value\r\n        })\r\n      );\r\n\r\n    // Reactive props\r\n    // 1) store original values in \"source\" container, to avoid extra .get() calls on scalar twins set\r\n    // 2) \"wanted\" container is bound with scalars; get() updates it\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Reactive)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.source[name] = value as Reactive<unknown>;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => {\r\n            const scalarWanted = ADAPTER_PROPS_STUB.find(\r\n              ({ wanted, reactive }) => wanted && reactive === name\r\n            );\r\n            if (scalarWanted) {\r\n              this.wanted[scalarWanted.name] = true;\r\n            }\r\n            return this.source[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props that have Reactive twins\r\n    // 1) scalars should use \"box\" container\r\n    // 2) \"wanted\" should be updated on get\r\n    // 3) reactive props (from \"source\") are triggered on set\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && !!prop.reactive)\r\n      .forEach(({ name, value, reactive, wanted }: IAdapterProp) => {\r\n        if (wanted) {\r\n          this.wanted[name] = false;\r\n        }\r\n        this.box[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          set: (newValue: unknown) => {\r\n            if (newValue !== this.box[name]) {\r\n              this.box[name] = newValue;\r\n              this.source[reactive as AdapterPropName].set(newValue);\r\n              // need to emit new value through the configured reactive prop if present\r\n              const reactiveProp = reactivePropsStore[reactive as AdapterPropName];\r\n              if (reactiveProp) {\r\n                reactiveProp.emit(reactiveProp.source, newValue);\r\n              }\r\n            }\r\n          },\r\n          get: () => {\r\n            if (wanted) {\r\n              this.wanted[name] = true;\r\n            }\r\n            return this.box[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props on-demand\r\n    // these scalars should use \"demand\" container\r\n    // setting defaults should be overridden on init()\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && prop.onDemand)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.demand[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => this.demand[name]\r\n        });\r\n      });\r\n\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    // Adapter public context augmentation\r\n    adapterProps\r\n      .forEach(({ name, type, value: defaultValue, permanent }: IAdapterProp) => {\r\n        let value = (this as IAdapter)[name];\r\n        if (type === AdapterPropType.Function) {\r\n          value = (value as () => void).bind(this);\r\n        } else if (type === AdapterPropType.WorkflowRunner) {\r\n          value = this.getPromisifiedMethod(value as MethodResolver, defaultValue as MethodResolver);\r\n        } else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {\r\n          value = (context as IAdapter)[name];\r\n        } else if (name === AdapterPropName.augmented) {\r\n          value = true;\r\n        }\r\n        Object.defineProperty(context, name, {\r\n          configurable: true,\r\n          get: () => !permanent && type === AdapterPropType.Scalar\r\n            ? (this as IAdapter)[name] // non-permanent Scalars should be taken in runtime\r\n            : value // Reactive props and methods (Functions/WorkflowRunners) can be defined once\r\n        });\r\n      });\r\n\r\n    this.externalContext = context;\r\n  }\r\n\r\n  initialize(buffer: Buffer<Item>, state: State, logger: Logger, adapterRun$?: Reactive<ProcessSubject>): void {\r\n    // buffer\r\n    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {\r\n      get: () => buffer.getVisibleItemsCount()\r\n    });\r\n    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {\r\n      get: (): IBufferInfo => ({\r\n        firstIndex: buffer.firstIndex,\r\n        lastIndex: buffer.lastIndex,\r\n        minIndex: buffer.minIndex,\r\n        maxIndex: buffer.maxIndex,\r\n        absMinIndex: buffer.absMinIndex,\r\n        absMaxIndex: buffer.absMaxIndex,\r\n        defaultSize: buffer.defaultSize,\r\n      })\r\n    });\r\n    this.bof = buffer.bof.get();\r\n    buffer.bof.on(bof => this.bof = bof);\r\n    this.eof = buffer.eof.get();\r\n    buffer.eof.on(eof => this.eof = eof);\r\n\r\n    // state\r\n    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {\r\n      get: () => state.packageInfo\r\n    });\r\n    this.loopPending = state.cycle.innerLoop.busy.get();\r\n    state.cycle.innerLoop.busy.on(busy => this.loopPending = busy);\r\n    this.isLoading = state.cycle.busy.get();\r\n    state.cycle.busy.on(busy => this.isLoading = busy);\r\n\r\n    // logger\r\n    this.logger = logger;\r\n\r\n    // self-pending subscription; set up only on the very first init\r\n    if (adapterRun$) {\r\n      if (!this.relax$) {\r\n        this.relax$ = new Reactive();\r\n      }\r\n      const relax$ = this.relax$;\r\n      adapterRun$.on(({ status, payload }) => {\r\n        let unSubRelax = () => { };\r\n        if (status === ProcessStatus.start) {\r\n          unSubRelax = this.isLoading$.on(value => {\r\n            if (!value) {\r\n              unSubRelax();\r\n              relax$.set({ success: true, immediate: false, details: null });\r\n            }\r\n          });\r\n        } else if (status === ProcessStatus.done || status === ProcessStatus.error) {\r\n          unSubRelax();\r\n          relax$.set({\r\n            success: status !== ProcessStatus.error,\r\n            immediate: true,\r\n            details: status === ProcessStatus.error && payload ? String(payload.error) : null\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // init\r\n    this.init = true;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.relax$) {\r\n      this.relax$.dispose();\r\n    }\r\n    if (this.externalContext) {\r\n      this.resetContext();\r\n    }\r\n    Object.getOwnPropertyNames(this).forEach(prop => {\r\n      delete (this as Record<string, unknown>)[prop];\r\n    });\r\n  }\r\n\r\n  resetContext(): void {\r\n    const reactiveStore = reactiveConfigStorage.get(this.externalContext.id);\r\n    ADAPTER_PROPS_STUB\r\n      .forEach(({ type, permanent, name, value }) => {\r\n        // assign initial values to non-reactive non-permanent props\r\n        if (type !== AdapterPropType.Reactive && !permanent) {\r\n          Object.defineProperty(this.externalContext, name, {\r\n            configurable: true,\r\n            get: () => value\r\n          });\r\n        }\r\n        // reset reactive props\r\n        if (type === AdapterPropType.Reactive && reactiveStore) {\r\n          const property = reactiveStore[name];\r\n          if (property) {\r\n            property.default.reset();\r\n            property.emit(property.source, property.default.get());\r\n          }\r\n        }\r\n      });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reset(options?: IDatasourceOptional): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reset', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reset,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reload(options?: number | string): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reload', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reload,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  append(_options: AdapterAppendOptions<Item> | unknown, eof?: boolean): any {\r\n    const options = convertAppendArgs(false, _options, eof); // support old signature\r\n    this.logger.logAdapterMethod('append', [options.items, options.eof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.append,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  prepend(_options: AdapterPrependOptions<Item> | unknown, bof?: boolean): any {\r\n    const options = convertAppendArgs(true, _options, bof); // support old signature\r\n    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.prepend,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  check(): any {\r\n    this.logger.logAdapterMethod('check');\r\n    this.workflow.call({\r\n      process: AdapterProcess.check,\r\n      status: ProcessStatus.start\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  remove(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>): any {\r\n    options = convertRemoveArgs(options); // support old signature\r\n    this.logger.logAdapterMethod('remove', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.remove,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  clip(options?: AdapterClipOptions): any {\r\n    this.logger.logAdapterMethod('clip', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.clip,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  insert(options: AdapterInsertOptions<Item>): any {\r\n    this.logger.logAdapterMethod('insert', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.insert,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  replace(options: AdapterReplaceOptions<Item>): any {\r\n    this.logger.logAdapterMethod('replace', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.replace,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  update(options: AdapterUpdateOptions<Item>): any {\r\n    this.logger.logAdapterMethod('update', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.update,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  fix(options: AdapterFixOptions<Item>): any {\r\n    this.logger.logAdapterMethod('fix', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.fix,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  relaxUnchained(callback: (() => void) | undefined, reloadId: string): Promise<AdapterMethodResult> {\r\n    const runCallback = () => typeof callback === 'function' && reloadId === this.reloadId && callback();\r\n    if (!this.isLoading) {\r\n      runCallback();\r\n    }\r\n    return new Promise<boolean>(resolve => {\r\n      if (!this.isLoading) {\r\n        resolve(true);\r\n        return;\r\n      }\r\n      this.isLoading$.once(() => {\r\n        runCallback();\r\n        resolve(false);\r\n      });\r\n    }).then(immediate => {\r\n      const success = reloadId === this.reloadId;\r\n      this.logger.log(() => !success ? `relax promise cancelled due to ${reloadId} != ${this.reloadId}` : void 0);\r\n      return {\r\n        immediate,\r\n        success,\r\n        details: !success ? 'Interrupted by reload or reset' : null\r\n      };\r\n    });\r\n  }\r\n\r\n  relax(callback?: () => void): Promise<AdapterMethodResult> {\r\n    const reloadId = this.reloadId;\r\n    this.logger.logAdapterMethod('relax', callback, ` of ${reloadId}`);\r\n    if (!this.init) {\r\n      return Promise.resolve(methodPreResult);\r\n    }\r\n    return this.relaxRun = this.relaxRun\r\n      ? this.relaxRun.then(() => this.relaxUnchained(callback, reloadId))\r\n      : this.relaxUnchained(callback, reloadId).then((result) => {\r\n        this.relaxRun = null;\r\n        return result;\r\n      });\r\n  }\r\n\r\n  showLog(): void {\r\n    this.logger.logAdapterMethod('showLog');\r\n    this.logger.logForce();\r\n  }\r\n}\r\n","import { DatasourceGeneric, makeDatasource } from './classes/datasource';\nimport { Settings } from './classes/settings';\nimport { Logger } from './classes/logger';\nimport { Routines } from './classes/domRoutines';\nimport { Viewport } from './classes/viewport';\nimport { Buffer } from './classes/buffer';\nimport { State } from './classes/state';\nimport { Adapter } from './classes/adapter';\nimport { Reactive } from './classes/reactive';\nimport { validate, DATASOURCE } from './inputs/index';\nimport core from './version';\nimport {\n  ScrollerWorkflow, IDatasource, IDatasourceConstructed, ScrollerParams, IPackages, ProcessSubject\n} from './interfaces/index';\n\nexport const INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';\n\nlet instanceCount = 0;\n\nexport class Scroller<Data = unknown> {\n  public datasource: IDatasourceConstructed<Data>;\n  public workflow: ScrollerWorkflow<Data>;\n\n  public settings: Settings<Data>;\n  public logger: Logger;\n  public routines: Routines;\n  public viewport: Viewport;\n  public buffer: Buffer<Data>;\n  public state: State;\n  public adapter: Adapter<Data>;\n\n  constructor({ datasource, consumer, element, workflow, scroller }: ScrollerParams<Data>) {\n    const { params: { get } } = validate(datasource, DATASOURCE);\n    if (!get.isValid) {\n      throw new Error(`${INVALID_DATASOURCE_PREFIX} ${get.errors[0]}`);\n    }\n\n    const packageInfo = scroller ? scroller.state.packageInfo : ({ consumer, core } as IPackages);\n    element = scroller ? scroller.viewport.element : (element as HTMLElement);\n    workflow = scroller ? scroller.workflow : (workflow as ScrollerWorkflow<Data>);\n\n    this.workflow = workflow;\n    this.settings = new Settings<Data>(datasource.settings, datasource.devSettings, ++instanceCount);\n    this.logger = new Logger(this as Scroller, packageInfo, datasource.adapter);\n    this.routines = new Routines(this.settings);\n    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);\n    this.buffer = new Buffer<Data>(this.settings, workflow.onDataChanged, this.logger);\n    this.viewport = new Viewport(element, this.settings, this.routines, this.state, this.logger);\n    this.logger.object('vscroll settings object', this.settings, true);\n\n    this.initDatasource(datasource, scroller);\n  }\n\n  initDatasource(datasource: IDatasource<Data>, scroller?: Scroller<Data>): void {\n    if (scroller) { // scroller re-instantiating case\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n      this.adapter = scroller.adapter;\n      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?\n      return;\n    }\n    // scroller is being instantiated for the first time\n    const constructed = datasource instanceof DatasourceGeneric;\n    const mockAdapter = !constructed && !this.settings.adapter;\n    if (constructed) { // datasource is already instantiated\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n    } else { // datasource as POJO\n      const DS = makeDatasource(() => ({ mock: mockAdapter }));\n      this.datasource = new DS<Data>(datasource);\n      if (this.settings.adapter) {\n        datasource.adapter = this.datasource.adapter;\n      }\n    }\n    const publicContext = !mockAdapter ? this.datasource.adapter : null;\n    this.adapter = new Adapter<Data>(publicContext, () => this.workflow, this.logger);\n  }\n\n  init(adapterRun$?: Reactive<ProcessSubject>): void {\n    this.viewport.reset(this.buffer.startIndex);\n    this.logger.stat('initialization');\n    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) { // Adapter is not re-instantiated on reset\n      this.adapter.dispose();\n    }\n    this.buffer.dispose();\n    this.state.dispose();\n  }\n\n  finalize(): void {\n  }\n\n}\n","import { Scroller } from './scroller';\nimport { runStateMachine } from './workflow-transducer';\nimport { Reactive } from './classes/reactive';\nimport { Item } from './classes/item';\nimport { CommonProcess, ProcessStatus as Status, } from './processes/index';\nimport {\n  WorkflowParams,\n  ProcessName,\n  ProcessPayload,\n  ProcessClass,\n  ProcessSubject,\n  WorkflowError,\n  InterruptParams,\n  StateMachineMethods,\n  ScrollerWorkflow,\n} from './interfaces/index';\n\nexport class Workflow<ItemData = unknown> {\n\n  isInitialized: boolean;\n  initTimer: ReturnType<typeof setTimeout> | null;\n  adapterRun$: Reactive<ProcessSubject>;\n  cyclesDone: number;\n  interruptionCount: number;\n  errors: WorkflowError[];\n\n  private disposeScrollEventHandler: () => void;\n  readonly propagateChanges: WorkflowParams<ItemData>['run'];\n  readonly stateMachineMethods: StateMachineMethods<ItemData>;\n\n  scroller: Scroller<ItemData>;\n\n  constructor({ element, datasource, consumer, run }: WorkflowParams<ItemData>) {\n    this.isInitialized = false;\n    this.initTimer = null;\n    this.adapterRun$ = new Reactive();\n    this.cyclesDone = 0;\n    this.interruptionCount = 0;\n    this.errors = [];\n    this.disposeScrollEventHandler = () => null;\n    this.propagateChanges = run;\n    this.stateMachineMethods = {\n      run: this.runProcess(),\n      interrupt: this.interrupt.bind(this),\n      done: this.done.bind(this),\n      onError: this.onError.bind(this)\n    };\n\n    this.scroller = new Scroller<ItemData>({ element, datasource, consumer, workflow: this.getUpdater() });\n\n    if (this.scroller.settings.initializeDelay) {\n      this.initTimer = setTimeout(() => {\n        this.initTimer = null;\n        this.init();\n      }, this.scroller.settings.initializeDelay);\n    } else {\n      this.init();\n    }\n  }\n\n  init(): void {\n    this.scroller.init(this.adapterRun$);\n    this.isInitialized = true;\n\n    // run the Workflow\n    this.callWorkflow({\n      process: CommonProcess.init,\n      status: Status.start\n    });\n\n    // set up scroll event listener\n    const { scrollEventReceiver } = this.scroller.viewport;\n    const onScrollHandler: EventListener =\n      event => this.callWorkflow({\n        process: CommonProcess.scroll,\n        status: Status.start,\n        payload: { event }\n      });\n    scrollEventReceiver.addEventListener('scroll', onScrollHandler);\n    this.disposeScrollEventHandler = () =>\n      scrollEventReceiver.removeEventListener('scroll', onScrollHandler);\n  }\n\n  changeItems(items: Item<ItemData>[]): void {\n    this.propagateChanges(items);\n  }\n\n  callWorkflow(processSubject: ProcessSubject): void {\n    if (!this.isInitialized) {\n      return;\n    }\n    const { process, status } = processSubject;\n    if (process && process.startsWith('adapter') && status !== Status.next) {\n      this.adapterRun$.set(processSubject);\n    }\n    this.process(processSubject);\n  }\n\n  getUpdater(): ScrollerWorkflow<ItemData> {\n    return {\n      call: this.callWorkflow.bind(this),\n      onDataChanged: this.changeItems.bind(this),\n    };\n  }\n\n  process(data: ProcessSubject): void {\n    const { status, process, payload } = data;\n    if (this.scroller.settings.logProcessRun) {\n      this.scroller.logger.log(() => [\n        '%cfire%c', ...['color: #cc7777;', 'color: #000000;'],\n        process, `\"${status}\"`, ...(payload !== void 0 ? [payload] : [])\n      ]);\n    }\n    this.scroller.logger.logProcess(data);\n\n    if (process === CommonProcess.end) {\n      this.scroller.finalize();\n    }\n    runStateMachine({\n      input: data,\n      methods: this.stateMachineMethods as StateMachineMethods<unknown>\n    });\n  }\n\n  runProcess() {\n    return ({ run, process, name }: ProcessClass) =>\n      (...args: any[]): void => {\n        if (this.scroller.settings.logProcessRun) {\n          this.scroller.logger.log(() => [\n            '%crun%c', ...['color: #333399;', 'color: #000000;'],\n            process || name, ...args\n          ]);\n        }\n        run(this.scroller as Scroller, ...args);\n      };\n  }\n\n  onError(process: ProcessName, payload?: ProcessPayload): void {\n    const message: string = payload && String(payload.error) || '';\n    const { time, cycle } = this.scroller.state;\n    this.errors.push({\n      process,\n      message,\n      time,\n      loop: cycle.loopIdNext\n    });\n    this.scroller.logger.logError(message);\n  }\n\n  interrupt({ process, finalize, datasource }: InterruptParams<ItemData>): void {\n    if (finalize) {\n      const { workflow, logger } = this.scroller;\n      // we are going to create a new reference for the scroller.workflow object\n      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped\n      workflow.call = (p: ProcessSubject) => // eslint-disable-line @typescript-eslint/no-unused-vars\n        logger.log('[skip wf call]');\n      workflow.call.interrupted = true;\n      this.scroller.workflow = this.getUpdater();\n      this.interruptionCount++;\n      logger.log(() => `workflow had been interrupted by the ${process} process (${this.interruptionCount})`);\n    }\n    if (datasource) { // Scroller re-initialization case\n      this.scroller.adapter.relax(() => {\n        this.scroller.logger.log('new Scroller instantiation');\n        const scroller = new Scroller<ItemData>({ datasource, scroller: this.scroller });\n        this.scroller.dispose();\n        this.scroller = scroller;\n        this.scroller.init();\n      });\n    }\n  }\n\n  done(): void {\n    const { state, logger } = this.scroller;\n    this.cyclesDone++;\n    logger.logCycle(false);\n    state.cycle.done(this.cyclesDone + 1);\n    this.finalize();\n  }\n\n  dispose(): void {\n    if (this.initTimer) {\n      clearTimeout(this.initTimer);\n    }\n    this.disposeScrollEventHandler();\n    this.adapterRun$.dispose();\n    this.scroller.dispose(true);\n    Object.getOwnPropertyNames(this).forEach(prop => {\n      delete (this as Record<string, unknown>)[prop];\n    });\n  }\n\n  finalize(): void {\n  }\n\n}\n","import {\n  CommonProcess,\n  AdapterProcess,\n  ProcessStatus as Status,\n  Init,\n  Scroll,\n  Reset,\n  Reload,\n  Append,\n  Check,\n  Remove,\n  UserClip,\n  Insert,\n  Replace,\n  Update,\n  Fix,\n  Start,\n  PreFetch,\n  Fetch,\n  PostFetch,\n  Render,\n  PreClip,\n  Clip,\n  Adjust,\n  End,\n} from './processes/index';\n\nimport { StateMachineParams } from './interfaces/index';\n\nexport const runStateMachine = ({\n  input: { process, status, payload = {} },\n  methods: { run, interrupt, done, onError }\n}: StateMachineParams): void => {\n  if (status === Status.error) {\n    onError(process, payload);\n    if (!process.startsWith('adapter')) {\n      run(End)(payload);\n    }\n    return;\n  }\n  const { options } = payload;\n  switch (process) {\n    case CommonProcess.init:\n      if (status === Status.start) { // App start\n        run(Init)(process);\n      }\n      if (status === Status.next) {\n        run(Start)();\n      }\n      break;\n    case CommonProcess.scroll:\n      if (status === Status.start) {\n        run(Scroll)(payload);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.reset:\n    case AdapterProcess.reload:\n      if (status === Status.start) {\n        if (process === AdapterProcess.reset) {\n          run(Reset)(options);\n        } else {\n          run(Reload)(options);\n        }\n      }\n      if (status === Status.next) {\n        interrupt({ process, ...payload });\n        if (payload.finalize) {\n          run(End)();\n        } else {\n          run(Init)(process);\n        }\n      }\n      break;\n    case AdapterProcess.append:\n    case AdapterProcess.prepend:\n      if (status === Status.start) {\n        run(Append)({ process, options });\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.check:\n      if (status === Status.start) {\n        run(Check)();\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.remove:\n      if (status === Status.start) {\n        run(Remove)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.clip:\n      if (status === Status.start) {\n        run(UserClip)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.insert:\n      if (status === Status.start) {\n        run(Insert)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.replace:\n      if (status === Status.start) {\n        run(Replace)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.update:\n      if (status === Status.start) {\n        run(Update)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.fix:\n      if (status === Status.start) {\n        run(Fix)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case CommonProcess.start:\n      switch (payload.process) {\n        case AdapterProcess.append:\n        case AdapterProcess.check:\n        case AdapterProcess.insert:\n          run(Render)();\n          break;\n        case AdapterProcess.remove:\n          run(Adjust)();\n          break;\n        case AdapterProcess.replace:\n        case AdapterProcess.update:\n          if (payload.doRender) {\n            run(Render)();\n          } else {\n            run(Adjust)();\n          }\n          break;\n        default:\n          run(PreFetch)();\n      }\n      break;\n    case CommonProcess.preFetch:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.clip:\n            run(PreClip)();\n            break;\n          default:\n            run(Fetch)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.fetch:\n      run(PostFetch)();\n      break;\n    case CommonProcess.postFetch:\n      if (status === Status.next) {\n        run(Render)();\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.render:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.append:\n          case AdapterProcess.check:\n          case AdapterProcess.insert:\n          case AdapterProcess.replace:\n          case AdapterProcess.update:\n            run(Adjust)();\n            break;\n          default:\n            run(PreClip)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.preClip:\n      if (payload.doClip) {\n        run(Clip)();\n      } else {\n        run(Adjust)();\n      }\n      break;\n    case CommonProcess.clip:\n      run(Adjust)();\n      break;\n    case CommonProcess.adjust:\n      run(End)();\n      break;\n    case CommonProcess.end:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.reset:\n          case AdapterProcess.reload:\n            done();\n            run(Init)(payload.process);\n            break;\n          default:\n            run(Start)();\n        }\n      }\n      if (status === Status.done) {\n        done();\n      }\n      break;\n  }\n};\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","pop","push","__values","o","m","__read","r","ar","error","__spreadArray","to","from","il","j","AdapterPropName","AdapterPropType","Direction","SizeStrategy","ValidatorType","Name","Type","noop","methodPreResult","noopWF","emptyPackageInfo","bufferInfoDefault","EMPTY_ITEM","getDefaultAdapterProps","reactiveConfigStorage","Map","instanceCount","mock","id","makeDatasource","getConfig","Datasource","DatasourceProps","getError","msg","args","getNumber","onNumber","onMoreOrEqual","limit","fallback","onFunction","onFunctionWithXToYArguments","onOneOf","tokens","must","context","onEnum","list","VALIDATORS","argsCount","validators","runValidator","current","validator","getDefault","prop","validateOne","name","validate","params","OBJECT","FUNC_WITH_X_AND_MORE_ARGUMENTS","Settings","DevSettings","DATASOURCE","get","settings","devSettings","NUMBER","INTEGER","INTEGER_UNLIMITED","MORE_OR_EQUAL","BOOLEAN","ELEMENT","FUNC","OR","ENUM","CommonProcess","AdapterProcess","ProcessStatus","MIN","throttle","initDelay","initWindowDelay","SETTINGS","DEV_SETTINGS","debug","immediateLog","logProcessRun","logTime","cacheData","cacheOnReload","changeOverflow","dismissOverflowAnchor","AdapterNoParams","ITEM_LIST","FUNC_WITH_X_ARGUMENTS","FUNC_WITH_X_TO_Y_ARGUMENTS","ONE_OF_MUST","ONE_OF_CAN","AdapterReloadParams","RESET_METHOD_PARAMS","AdapterAppendParams","RELOAD_METHOD_PARAMS","reloadIndex","AdapterRemoveParams","APPEND_METHOD_PARAMS","items","bof","eof","AdapterClipParams","REMOVE_METHOD_PARAMS","predicate","indexes","increase","AdapterInsertParams","CLIP_METHOD_PARAMS","backwardOnly","forwardOnly","AdapterReplaceParams","INSERT_METHOD_PARAMS","before","after","decrease","AdapterUpdateParams","REPLACE_METHOD_PARAMS","fixRight","AdapterFixParams","UPDATE_METHOD_PARAMS","FIX_METHOD_PARAMS","scrollPosition","minIndex","maxIndex","updater","scrollToItem","scrollToItemOpt","AdapterMethods","ADAPTER_METHODS","BaseProcessFactory","process","BaseAdapterProcessFactory","initProcesses","init","reset","reload","cycle","workflow","scrollState","log","position","time","state","scroll","datasource","viewport","$index","data","buffer","append","item","check","sequenceOnly","fetch","diff","finiteAbsMinIndex","remove","clip","update","insert","replace","FixParams","fix","start","positions","last","pack","preFetch","postFetch","render","size","adjust","preClip","isInterrupted","adapter","end","logs","logAdapterMethod","element","style","_items","min","max","virtual","newItem","ADAPTER_PROPS_STUB","_has","obj","convertAppendArgs","prepend","options","source","box","demand","wanted","reactive","core","scrollEventReceiver","status","input","payload","methods","scroller"],"sourceRoot":""}